<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p><strong>3-Promise实践练习-AJAX请求.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Promise 封装 AJAX<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&#x27;anonymous&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>Promise 封装 AJAX 操作<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击发送 AJAX<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//接口地址 https://api.apiopen.top/getJoke</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//获取元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//创建 Promise</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//2. 初始化</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://cors-anywhere.herokuapp.com/https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//3. 发送</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//4. 处理响应结果</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//判断响应状态码 2xx   </span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//控制台输出响应体</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>(xhr.<span class="property">response</span>); <span class="comment">// xhr.response里面存的就是响应体</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//控制台输出响应状态码</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//调用then方法</span></span></span><br><span class="line"><span class="language-javascript">            p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span></span><br><span class="line"><span class="language-javascript">            &#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason); <span class="comment">// warn颜色区分log</span></span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>以向日葵之名 道最后的告别......</title>
    <url>/2023/07/17/%E8%8A%B1%E5%8D%89/</url>
    <content><![CDATA[<h1 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h1><p><strong>草本植物</strong> &#x2F; 维基百科，自由的 百科全书</p>
<p><a href="https://www.wikiwand.com/zh-hans/%E6%9E%9C%E5%AE%9E">果实</a> <a href="https://www.wikiwand.com/zh-hans/%E8%8F%8A%E7%A7%91">菊科</a> <a href="https://www.wikiwand.com/zh-hans/%E8%8A%B1%E5%BA%8F">花序</a></p>
<p> <strong>向日葵</strong> （<a href="https://www.wikiwand.com/zh-hans/%E5%AD%A6%E5%90%8D" title="学名">学名</a>：<em>Helianthus annuus</em>）是<a href="https://www.wikiwand.com/zh-hans/%E8%8F%8A%E7%A7%91" title="菊科">菊科</a><a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5%E5%B1%9E" title="向日葵属">向日葵属</a>的植物。别名 <strong>太阳花</strong> 、 <strong>朝阳花</strong> 、 <strong>日头花</strong> （<a href="https://www.wikiwand.com/zh-hans/%E5%8F%B0%E6%B9%BE%E8%AF%9D" title="台湾话">台湾话</a>：）<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-3"></a>，一般称向日葵。因<a href="https://www.wikiwand.com/zh-hans/%E8%8A%B1%E5%BA%8F" title="花序">花序</a>随太阳转动（太阳花）而得名。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>向日葵<a href="https://www.wikiwand.com/zh-hans/Help:%E5%A6%82%E4%BD%95%E9%96%B1%E8%AE%80%E7%94%9F%E7%89%A9%E8%B3%87%E8%A8%8A%E6%A1%86" title="Help:如何阅读生物资讯框"><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Infobox_info_icon2.svg/18px-Infobox_info_icon2.svg.png"></a></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#Media/File:Eberndorf_K%C3%B6cking_Sonnenblumenfeld_Biohof_Tomic_18072014_0792.jpg"><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Eberndorf_K%C3%B6cking_Sonnenblumenfeld_Biohof_Tomic_18072014_0792.jpg/220px-Eberndorf_K%C3%B6cking_Sonnenblumenfeld_Biohof_Tomic_18072014_0792.jpg"></a></td>
</tr>
<tr>
<td>向日葵</td>
</tr>
<tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E4%BF%9D%E6%8A%A4%E7%8A%B6%E5%86%B5">保护状况</a></td>
</tr>
<tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E6%97%A0%E5%8D%B1%E7%89%A9%E7%A7%8D">无危</a> （<a href="https://www.wikiwand.com/zh-hans/%E5%9B%BD%E9%99%85%E8%87%AA%E7%84%B6%E4%BF%9D%E6%8A%A4%E8%81%94%E7%9B%9F%E6%BF%92%E5%8D%B1%E7%89%A9%E7%A7%8D%E7%BA%A2%E8%89%B2%E5%90%8D%E5%BD%95">IUCN 3.1</a>）</td>
</tr>
<tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E7%94%9F%E7%89%A9%E5%88%86%E7%B1%BB%E5%AD%A6">科学分类</a><a href="https://www.wikiwand.com/zh-hans/Template:Taxonomy/Helianthus"><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Small_Pencil_Icon.svg/16px-Small_Pencil_Icon.svg.png" alt="img"></a></td>
</tr>
<tr>
<td>界：<a href="https://www.wikiwand.com/zh-hans/%E6%A4%8D%E7%89%A9%E7%95%8C"> 植物界</a> Plantae</td>
</tr>
<tr>
<td>演化支：Tracheophyta</td>
</tr>
<tr>
<td>演化支：<a href="https://www.wikiwand.com/zh-hans/%E8%A2%AB%E5%AD%90%E6%A4%8D%E7%89%A9"> 被子植物</a> Angiosperms</td>
</tr>
<tr>
<td>演化支：<a href="https://www.wikiwand.com/zh-hans/%E7%9C%9F%E5%8F%8C%E5%AD%90%E5%8F%B6%E6%A4%8D%E7%89%A9">真双子叶植物</a> Eudicots</td>
</tr>
<tr>
<td>演化支：<a href="https://www.wikiwand.com/zh-hans/%E8%8F%8A%E7%B1%BB%E6%A4%8D%E7%89%A9">菊类植物</a> Asterids</td>
</tr>
<tr>
<td>目：<a href="https://www.wikiwand.com/zh-hans/%E8%8F%8A%E7%9B%AE">菊目</a> Asterales</td>
</tr>
<tr>
<td>科：<a href="https://www.wikiwand.com/zh-hans/%E8%8F%8A%E7%A7%91">菊科</a> Asteraceae</td>
</tr>
<tr>
<td>属：向日葵属<em>Helianthus</em></td>
</tr>
<tr>
<td>种：<strong>向日葵 <em>H. annuus</em></strong></td>
</tr>
<tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E4%BA%8C%E5%90%8D%E6%B3%95" title="二名法">二名法</a></td>
</tr>
<tr>
<td><em><strong>Helianthus annuus</strong></em>&#96;&#96;<a href="https://www.wikiwand.com/zh-hans/%E5%8D%A1%E5%B0%94%C2%B7%E6%9E%97%E5%A5%88" title="卡尔·林奈">L.</a></td>
</tr>
<tr>
<td><a href="https://www.wikiwand.com/zh-hans/%E5%BC%82%E5%90%8D" title="异名">异名</a></td>
</tr>
<tr>
<td>列表<em><em>Helianthus aridus</em> Rydb.<em><em>Helianthus erythrocarpus</em> Bartl.</em> <em>Helianthus indicus</em> L.</em> <em>Helianthus jaegeri</em> Heiser* <em>Helianthus lenticularis</em> Douglas* <em>Helianthus macrocarpus</em> DC. &amp; A.DC.* <em>Helianthus multiflorus</em> Hook.* <em>Helianthus ovatus</em> Lehm.* <em>Helianthus platycephalus</em> Cass.* <em>Helianthus tubaeformis</em> Nutt.</td>
</tr>
</tbody></table>
<h2 id="形态"><a href="#形态" class="headerlink" title="形态"></a>形态</h2><p>一年生<a href="https://www.wikiwand.com/zh-hans/%E8%8D%89%E6%9C%AC" title="草本">草本</a>。茎直立，圆形多棱角，质硬白色粗硬毛。广卵形的叶片通常互生，先端锐突或渐尖，有基出3脉，边缘具粗锯齿，两面粗糙，被毛，有长柄。<a href="https://www.wikiwand.com/zh-hans/%E5%A4%B4%E7%8A%B6%E8%8A%B1%E5%BA%8F" title="头状花序">头状花序</a>，直径9.5～30厘米，单生于茎顶或枝端。总苞片多层，叶质，覆瓦状排列，被长硬毛，花期为7到8月，花序边缘生中性的黄色舌状花，不结实。花序中部为两性管状花，棕色或紫色，能结实。矩卵形<strong>下位瘦果</strong>，果皮木质化，灰色或黑色，称<a href="https://www.wikiwand.com/zh-hans/%E8%91%B5%E8%8A%B1%E7%B1%BD" title="葵花籽">葵花籽</a>。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>最常见的向日葵高度为2.5～3.5公尺。根据1567年的科学文献报告，历来被认为单头向日葵植物是种植在<a href="https://www.wikiwand.com/zh-hans/%E5%B8%95%E5%A4%9A%E7%93%A6" title="帕多瓦">帕多瓦</a>，植株高度最高可达12公尺。同样的种子，种植在其他时间和地点（如<a href="https://www.wikiwand.com/zh-hans/%E9%A9%AC%E5%BE%B7%E9%87%8C" title="马德里">马德里</a>），植株高度可达近8公尺。更近的纪录（约二十年前）则有8公尺以上的植株，在<a href="https://www.wikiwand.com/zh-hans/%E8%8D%B7%E5%85%B0" title="荷兰">荷兰</a>和<a href="https://www.wikiwand.com/zh-hans/%E5%8A%A0%E6%8B%BF%E5%A4%A7" title="加拿大">加拿大</a><a href="https://www.wikiwand.com/zh-hans/%E5%AE%89%E5%A4%A7%E7%95%A5%E7%9C%81" title="安大略省">安大略省</a>。 向日葵高约3（9.8英尺），最高可达9.17（30.1英尺）<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-Guiness-4"></a>。</p>
<h2 id="象征"><a href="#象征" class="headerlink" title="象征"></a>象征</h2><p>向日葵是<a href="https://www.wikiwand.com/zh-hans/%E4%B9%8C%E5%85%8B%E5%85%B0" title="乌克兰">乌克兰</a>的国花。在<a href="https://www.wikiwand.com/zh-hans/2022%E5%B9%B4%E4%BF%84%E5%9B%BD%E5%85%A5%E4%BE%B5%E4%B9%8C%E5%85%8B%E5%85%B0" title="2022年俄国入侵乌克兰">2022年俄国入侵乌克兰</a>期间，社交媒体上广为流传的一个视频中，一名不知名的乌克兰妇女叫侵乌俄军士兵“拿上这些向日葵种子，把它们装在口袋里。这样向日葵就会在你们死掉的地方生长”<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-5"></a>。向日葵从此在乌克兰和全世界成为了抵抗侵略以及团结和希望的象征<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-6"></a>。</p>
<p>向日葵原产地据信为<a href="https://www.wikiwand.com/zh-hans/%E5%8C%97%E7%BE%8E%E6%B4%B2" title="北美洲">北美洲</a>。是<a href="https://www.wikiwand.com/zh-hans/%E4%BF%84%E7%BD%97%E6%96%AF" title="俄罗斯">俄罗斯</a>、<a href="https://www.wikiwand.com/zh-hans/%E4%B9%8C%E5%85%8B%E5%85%B0" title="乌克兰">乌克兰</a>、<a href="https://www.wikiwand.com/zh-hans/%E8%91%A1%E8%90%84%E7%89%99" title="葡萄牙">葡萄牙</a>、<a href="https://www.wikiwand.com/zh-hans/%E7%A7%98%E9%B2%81" title="秘鲁">秘鲁</a>、<a href="https://www.wikiwand.com/zh-hans/%E7%8E%BB%E5%88%A9%E7%BB%B4%E4%BA%9A" title="玻利维亚">玻利维亚</a>的国<strong>花</strong>，<a href="https://www.wikiwand.com/zh-hans/%E6%97%A5%E6%9C%AC" title="日本">日本</a><a href="https://www.wikiwand.com/zh-hans/%E5%8C%97%E4%B9%9D%E5%B7%9E%E5%B8%82" title="北九州市">北九州市</a>的市花及以其象征为名的职业足球队——<a href="https://www.wikiwand.com/zh-hans/%E5%8C%97%E4%B9%9D%E5%B7%9E%E5%90%91%E6%97%A5%E8%91%B5" title="北九州向日葵">北九州向日葵</a>。</p>
<p><a href="https://www.wikiwand.com/zh-hans/%E6%96%87%E5%8C%96%E5%A4%A7%E9%9D%A9%E5%91%BD" title="文化大革命">文化大革命</a>时期，中国兴起对<a href="https://www.wikiwand.com/zh-hans/%E6%AF%9B%E6%B3%BD%E4%B8%9C" title="毛泽东">毛泽东</a>的<strong>个人崇拜</strong>，将毛泽东塑造为“<a href="https://www.wikiwand.com/zh-hans/%E4%B8%9C%E6%96%B9%E7%BA%A2_(%E6%AD%8C%E6%9B%B2)">红太阳</a> “东方红 (歌曲)”)”，因此向日葵被赋予了“心向毛主席”的涵义，<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-7"></a> 向日葵的造型多出现在<a href="https://www.wikiwand.com/zh-hans/%E6%AF%9B%E4%B8%BB%E5%B8%AD%E5%83%8F%E7%AB%A0" title="毛主席像章">毛主席像章</a> <a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-8"></a>、宣传海报<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-9"></a>、群众游行<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-10"></a>中。</p>
<p><a href="https://www.wikiwand.com/zh-hans/%E6%97%A5%E6%9C%AC%E6%B0%94%E8%B1%A1%E5%8E%85" title="日本气象厅">日本气象厅</a>的<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5%E7%B3%BB%E5%88%97%E5%8D%AB%E6%98%9F" title="向日葵系列卫星">系列气象卫星</a>使用“向日葵”作为昵称。</p>
<h2 id="培育和用途"><a href="#培育和用途" class="headerlink" title="培育和用途"></a>培育和用途</h2><p><a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#Media/File:2017-07-15_Ono-himawarino-oka-park_(%E5%B0%8F%E9%87%8E%E5%B8%82%E7%AB%8B%E3%81%B2%E3%81%BE%E3%82%8F%E3%82%8A%E3%81%AE%E4%B8%98%E5%85%AC%E5%9C%92)_6123%E2%98%86%E5%BD%A1.jpg"><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/2017-07-15_Ono-himawarino-oka-park_%28%E5%B0%8F%E9%87%8E%E5%B8%82%E7%AB%8B%E3%81%B2%E3%81%BE%E3%82%8F%E3%82%8A%E3%81%AE%E4%B8%98%E5%85%AC%E5%9C%92%29_6123%E2%98%86%E5%BD%A1.jpg/220px-2017-07-15_Ono-himawarino-oka-park_%28%E5%B0%8F%E9%87%8E%E5%B8%82%E7%AB%8B%E3%81%B2%E3%81%BE%E3%82%8F%E3%82%8A%E3%81%AE%E4%B8%98%E5%85%AC%E5%9C%92%29_6123%E2%98%86%E5%BD%A1.jpg"></a><br>小野市立向日葵公园</p>
<p>主条目：<a href="https://www.wikiwand.com/zh-hans/%E8%91%B5%E8%8A%B1%E7%B1%BD" title="葵花籽">葵花籽</a></p>
<p>种子先由温水泡过，再以种子尖端朝下种植在土中，约4~5天即可发芽。</p>
<p>向日葵可用于在<strong>植生</strong>复<strong>育</strong>（<strong>英语</strong>：Phytoremediation]]<strong>）</strong>提取土壤有毒成份，如铅，砷和铀，并在过滤处理用于中和<a href="https://www.wikiwand.com/zh-hans/%E6%94%BE%E5%B0%84%E6%80%A7%E5%90%8C%E4%BD%8D%E7%B4%A0" title="放射性同位素">放射性同位素</a>和来自水中的其他有毒成分和有害细菌。在<a href="https://www.wikiwand.com/zh-hans/%E5%88%87%E5%B0%94%E8%AF%BA%E8%B4%9D%E5%88%A9%E6%A0%B8%E4%BA%8B%E6%95%85" title="切尔诺贝利核事故">切尔诺贝利核事故</a>之后，它们被用来从附近的一个池塘移除<strong>铯-137</strong>和<strong>锶-90</strong>。<a href="https://www.wikiwand.com/zh-hans/%E5%90%91%E6%97%A5%E8%91%B5#cite_note-11"></a>类似的方法也被运用于<a href="https://www.wikiwand.com/zh-hans/%E7%A6%8F%E5%B2%9B%E7%AC%AC%E4%B8%80%E6%A0%B8%E7%94%B5%E7%AB%99%E4%BA%8B%E6%95%85" title="福岛第一核电站事故">福岛第一核电站事故</a>的处理中。</p>
]]></content>
  </entry>
  <entry>
    <title>Note</title>
    <url>/2023/07/22/Lwarence%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>This is my programming study note, I put it here.</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a><u>STL</u></h2><h3 id="数据类型类"><a href="#数据类型类" class="headerlink" title="数据类型类"></a><strong>数据类型类</strong></h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p><strong>+,&#x3D;,&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;</strong></p>
<p><strong>size() 和 length() 函数 : 他们返回字符串的真实长度，且不会因为空格而截断，这两个方法完全等价。</strong></p>
<p><strong>erase(index,length)函数:该函数删除index位置后length长度的子串，并返回删除后的字串</strong></p>
<p><strong>substr(index,length)函数:该函数从index开始截断到长度为length并返回截断的子串。</strong></p>
<span id="more"></span>

<p><strong>reverse(str1.begin(), str1.end()):翻转字符串</strong></p>
<p><strong>push_back(char c)函数往该字符串的尾端加入一个字符;</strong></p>
<p><strong>pop_back()函数:从该字符串的尾端弹出一个字符;</strong></p>
<p><strong>append(string s)函数:将会在该字符串的末尾添加一个字符串，并且返回添加后字符串的引用</strong></p>
<h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><p><strong>pairpair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair。比如存入一个点(x坐标，y坐标)</strong></p>
<p><strong>当一个函数需要返回2个数据的时候，也可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first ,second 。</strong></p>
<p><strong>其标准库类型–pair类型定义在#include <utility>头文件中；</strong></p>
<p><strong>功能：pair将一对值(T1和T2)组合成一个值,这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个公有函数first和second访问。</strong></p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p><strong>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器(可以理解为动态数组，是封装好了的类）</strong></p>
<p><strong>进行vector操作前应添加头文件#include <vector></strong></p>
<p><strong>可以简单的认为，向量是一个能够存放任意类型的动态数组。</strong></p>
<p><strong>容器中的元素按照严格的<u>线性顺序排序</u>。可以通过元素在序列中的位置访问对应的元素。</strong></p>
<p><strong>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加&#x2F;删除元素的操作。</strong></p>
<h5 id="vector初始化"><a href="#vector初始化" class="headerlink" title="vector初始化"></a><strong>vector初始化</strong></h5><p><strong>方式1：:vector<int>a(10); &#x2F;&#x2F;定义具有10个整型元素的vector</strong></p>
<p><strong>方式2： vector<int>a(10,1); &#x2F;&#x2F;定义具有10个整型元素的向量，且给出的每个元素初值为1</strong></p>
<p><strong>方式3：vector<int>a(b); .&#x2F;&#x2F;用b给a赋值，a的值完全等价于b的值</strong></p>
<p><strong>方式4：vector<int>a(b.begin(),b.begin()+3); &#x2F;&#x2F;将b中从0-2（共三个）的元素赋值给a</strong></p>
<p><strong>方式5：b[7]&#x3D;{1,2,3,4,5,6,7};vector<int> a(b,b+7）; &#x2F;&#x2F;从数组中获得初值int</strong> </p>
<h5 id="vector应用"><a href="#vector应用" class="headerlink" title="vector应用"></a>vector应用</h5><p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102136_OCR\pic.jpg" alt="pic"></p>
<p><a href="https://cdutetcoj.xyz/problem/HDU-1873">看病要排队 - CDUTETCOJ</a></p>
<p><strong>题意：一个医院有a个医生，有n个事件，每个事件要么是病人编号xi，优先级为di的病人找医生ai看</strong><br><strong>病，要么是，医生ai对病人看病，医生看病时要先看优先级高的病人，优先级高的，次序小的先看。每</strong><br><strong>次医生看病输出医生看病的病人编号。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;  <span class="comment">//表示病人的属性(优先级和序号)</span></span><br><span class="line">vector&lt;pii&gt; ve[<span class="number">4</span>];   <span class="comment">//表示医生的病人个数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii a,pii b)</span></span>&#123;  <span class="comment">//医生看病的排序规则</span></span><br><span class="line"><span class="keyword">if</span>(a.first==b.first)&#123;</span><br><span class="line"><span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;  <span class="comment">//cnt表示病人的序号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++) ve[i].<span class="built_in">clear</span>();</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">&quot;IN&quot;</span>)&#123;</span><br><span class="line"><span class="type">int</span> a,b;  <span class="comment">//a表示医生编号，b表示优先级</span></span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">ve[a].<span class="built_in">push_back</span>(<span class="built_in">pii</span>(b,cnt));  <span class="comment">//这个病人要找医生a看病，这个病人的优先级为b，序号为cnt。</span></span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> a;  <span class="comment">//医生a进行看病</span></span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span>(ve[a].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;  <span class="comment">//如果没有找医生看病的人则输出EMPTY</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;EMPTY&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  <span class="comment">//否则有人找医生a看病</span></span><br><span class="line"><span class="built_in">sort</span>(ve[a].<span class="built_in">begin</span>(),ve[a].<span class="built_in">end</span>(),cmp);  <span class="comment">//对医生a的病人排序 </span></span><br><span class="line">cout &lt;&lt; ve[a][ve[a].<span class="built_in">size</span>()<span class="number">-1</span>].second &lt;&lt; endl;  <span class="comment">//找到优先级最高且序号最小的病人看病，输出序号</span></span><br><span class="line">ve[a].<span class="built_in">pop_back</span>();  <span class="comment">//把这个病人弹出表示已经看病</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><strong>set理解成集合，普通的set拥有去重，排序功能multiset则是无去重功能</strong></p>
<p><strong>set集合容器实现了红黑树的平衡二叉检索树的数据结构set不支持随机访问，必须要使用迭代器去访问。</strong></p>
<p><strong>进行set操作前应添加头文件#include <set></strong></p>
<p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102140_OCR\pic.jpg" alt="pic"></p>
<p><a href="https://cdutetcoj.xyz/problem/HDU-2094">产生冠军 - CDUTETCOJ</a></p>
<p><strong>题意：每组n个对决，每个对决的赢家为第一个人，败者为第二个人，在n个对决过后，判断是否能参数</strong><br><strong>唯一的冠军，若能输出Yes，不能输出No。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">set&lt;string&gt; all_set,low_set; <span class="comment">//参赛所有人的集合all_set和败者的集合low_set</span></span><br><span class="line">string win,low;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin &gt;&gt; win &gt;&gt; low;</span><br><span class="line">all_set.<span class="built_in">insert</span>(win);  <span class="comment">//加入到所有人集合和败者集合</span></span><br><span class="line">all_set.<span class="built_in">insert</span>(low);</span><br><span class="line">low_set.<span class="built_in">insert</span>(low);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(all_set.<span class="built_in">size</span>()-low_set.<span class="built_in">size</span>()==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;  <span class="comment">//所有人里面只能由一个胜者</span></span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><strong>map是c++中的映射</strong></p>
<p><strong>multimap容器：与map容器类似，区别只在于multimap容器可以保存键值相同的元素。</strong></p>
<p><strong>构造：map&lt;string,int&gt; ma;(可以为int,double,string,结构体等)map&lt;string, string&gt; authors { {“Joyce”, “James”}, {“Austen”, “Jane”}, {“Dickens”, “Charles”} };初始值为0.</strong></p>
<p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102149_OCR\pic.jpg" alt="pic"></p>
<p><a href="https://cdutetcoj.xyz/problem/HDU-2648">Shopping - CDUTETCOJ</a></p>
<p><strong>题意：有n个商店，每个商店的价格mi在变化，给你m天，输出每天每个商店的价格变化，每天过后，</strong><br><strong>输出商店memory的排名，规定价格高的排名在前面。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; ma;  <span class="comment">//定义map是商店名称s往商店价格num的映射</span></span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  <span class="comment">//输入商店的名称并初始化商店的价格为0</span></span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">ma[s]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;  <span class="comment">//k次循环</span></span><br><span class="line"><span class="keyword">while</span>(k--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  <span class="comment">//每次输入n个商店上涨的价格</span></span><br><span class="line">cin &gt;&gt; num &gt;&gt; s;</span><br><span class="line">ma[s]+=num;  <span class="comment">//商店的价格更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator x=ma.<span class="built_in">begin</span>();x!=ma.<span class="built_in">end</span>();x++)&#123;  <span class="comment">//遍历这n个商店的价格</span></span><br><span class="line"><span class="keyword">if</span>(x-&gt;second&gt;ma[<span class="string">&quot;memory&quot;</span>]) ans++;  <span class="comment">//如果商店的价格比memory大，它的次序靠后</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;  <span class="comment">//输出memory商店它的排名</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈：后进先出（LIFO-last in first out）:最后插入的元素最先出来。</strong></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710140439732.png" alt="image-20220710140439732"></p>
<p><strong>栈的数组实现方法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> stack[<span class="number">10086</span>];	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=stack[top<span class="number">-1</span>];</span><br><span class="line">	top--;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	stack[top++]=value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">funtop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> stack[top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cn;</span><br><span class="line">	cin &gt;&gt; cn;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cn--)&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">push</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(top&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/HDU-1062">Text Reverse - CDUTETCOJ</a></p>
<p><strong>题意：n组样列，每组一行带空格的字符串，但是字符串的单词是反着的，需要你把每个单词翻转过来输出</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;world;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">	<span class="type">int</span> cin =<span class="number">1005</span>;</span><br><span class="line">	<span class="keyword">while</span>(cin--)&#123;</span><br><span class="line">	s=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span>(s==<span class="string">&#x27; &#x27;</span>||s==<span class="string">&#x27;\n&#x27;</span>||s==EOF)&#123;</span><br><span class="line">	<span class="keyword">while</span>(!world.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout &lt;&lt; world.<span class="built_in">top</span>();</span><br><span class="line">			world.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s==EOF||s==<span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		world.<span class="built_in">push</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><strong>队列：先进先出（FIFO-first in first out）:最先插入的元素最先出来。</strong></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710152006431.png" alt="image-20220710152006431"></p>
<h5 id="数组模拟"><a href="#数组模拟" class="headerlink" title="数组模拟"></a>数组模拟</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> front=<span class="number">0</span>,rear=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> queues[<span class="number">10086</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	queues[front++]=value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=queues[rear];</span><br><span class="line">	rear++;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queues[front<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">	front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		<span class="built_in">push</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/HDU-1702">ACboy needs your help again! - CDUTETCOJ</a></p>
<p><strong>题意：t组样列，每组有n个操作和一个字符串s，表示队列操作的”FIFO“和栈操作的”FILO“，每个操作</strong><br><strong>要么是入队(入栈)，要么出队(出栈)并输出到屏幕上。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> t,v;</span><br><span class="line">	string h,u;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; h;</span><br><span class="line">	<span class="keyword">if</span>(h==<span class="string">&quot;FIFO&quot;</span>)&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			cin &gt;&gt; u;</span><br><span class="line">			<span class="keyword">if</span>(u==<span class="string">&quot;IN&quot;</span>)&#123;</span><br><span class="line">				cin &gt;&gt; v;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">				cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">				q.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(h==<span class="string">&quot;FILO&quot;</span>)&#123;</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">		<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">			cin &gt;&gt; u;</span><br><span class="line">			<span class="keyword">if</span>(u==<span class="string">&quot;IN&quot;</span>)&#123;</span><br><span class="line">				cin &gt;&gt; v;</span><br><span class="line">				s.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">				cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">				s.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;None&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/HDU-4841">圆桌问题 - CDUTETCOJ</a></p>
<p><strong>题意：一个圆桌上有n*2个人，循环数m个数，数到第m个人为坏人，之前数过的坏人数到的时候跳</strong><br><strong>过，直到数到n个坏人，即数到一般的人为坏人，另一半的人为好人，输出好人信息和坏人信息。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> aim[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">		<span class="built_in">memset</span>(aim,<span class="number">0</span>,<span class="built_in">sizeof</span>(aim));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) q.<span class="built_in">push</span>(i); <span class="comment">//把每个位置入队</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;  <span class="comment">//找n个坏人的位置</span></span><br><span class="line">			<span class="type">int</span> sum=<span class="number">0</span>;   <span class="comment">//sum统计数的个数</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">				<span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">				q.<span class="built_in">pop</span>(); </span><br><span class="line">            <span class="keyword">if</span>(aim[x]==<span class="number">0</span>) sum++; <span class="comment">//如果这个位置是好人，num+1表示数的人数加一</span></span><br><span class="line">					q.<span class="built_in">push</span>(x); <span class="comment">//重新入队</span></span><br><span class="line">				<span class="keyword">if</span>(sum==m)&#123; <span class="comment">//数到第m个位置</span></span><br><span class="line">					aim[x]=<span class="number">1</span>;<span class="comment">//标记这个位置处的人为坏人</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;<span class="comment">//1为坏人，输出B</span></span><br><span class="line">		<span class="keyword">if</span>(aim[i]) cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;G&quot;</span>;<span class="comment">//否则为好人，输出G</span></span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">50</span>||i==<span class="number">2</span>*n)&#123;<span class="comment">//输出到50或者最后需要换行</span></span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			ans=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="链表形式"><a href="#链表形式" class="headerlink" title="链表形式"></a>链表形式</h5><p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207101530_OCR\pic.jpg" alt="pic"></p>
<h4 id="优先队列（priority-queue）"><a href="#优先队列（priority-queue）" class="headerlink" title="优先队列（priority_queue）"></a>优先队列（priority_queue）</h4><p><strong>优先队列：考虑优先级优先级对它们的设置默认都是数字大的优先级越高队首元素就是优先队列内元素最大的那个</strong></p>
<p><strong>构造：priority_queue&lt;int,vector<int>,greater<int> &gt; pre;(可以为int,double,string,结构体等),（less)priority_queue<int>默认以值最大优先级最高</strong></p>
<h4 id="二叉树与堆"><a href="#二叉树与堆" class="headerlink" title="二叉树与堆"></a>二叉树与堆</h4><h3 id=""><a href="#" class="headerlink" title=""></a><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207101542_OCR\pic.jpg" alt="pic"></h3><p><strong>二叉树的结构：</strong></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710154447651.png" alt="image-20220710154447651"></p>
<p><strong>堆的建立</strong></p>
<p><strong>方法1：通过插入操作，将N个元素一个一个相继插入到一个初始值为空的堆中去。</strong></p>
<p><strong>方法2：将N个元素放入一个一维数组中，然后调节节点位置，满足堆的条件。</strong></p>
<p><a href="https://blog.csdn.net/zhangxiao93/article/details/72461396"> C++实现一个堆（模板）_NearXDU的博客-CSDN博客</a></p>
<p><strong>１．插入：</strong><br><strong>也就是，首先插入一定是插入到完全二叉树的最右下，对应数组中，也就是back()的位置，那么为了满足堆的性质，就需要不断的上溯，也就是将新插入的元素往上到合适的位置．这里沿用ＳＴＬ中的实现方式，并不是直接的swap，而是先生成一个HoleInex也就是产生一个空洞，这个空洞就是待插入的位置，但是这个空洞需要不断的上溯到合适位置，然后将新值插入即可．</strong></p>
<p><strong>２．弹出：</strong><br><strong>弹出堆中的最大值&#x2F;最小值，对应的就是堆顶元素，数组索引位置为0或者1（取决于实现）。这个时候将堆顶元素放到末尾（覆盖最后一个元素），堆顶的这个位置就变成了空洞了，此时需要将原来的末尾的元素插入到这个空洞中，就需要将这个空洞下沉到合适位置，然后将元素插入，并且堆大小减1</strong></p>
<p><strong>３．排序：</strong><br><strong>pop操作每次都会弹出最大或者最小的元素到堆尾，那么执行n-1次弹出操作，数组就有序了。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆模版 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> heap[<span class="number">11</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125; ;</span><br><span class="line"><span class="type">int</span> heapsz=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//维护大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> now,next;<span class="comment">//指向当前与下一个节点</span></span><br><span class="line">	heapsz++;heap[heapsz]=n;now=heapsz;</span><br><span class="line">	<span class="keyword">while</span> (now&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		next=now/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (heap[now]&gt;=heap[next]) <span class="built_in">swap</span>(heap[now],heap[next]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;	</span><br><span class="line">		now=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) cout&lt;&lt;heap[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp;cin&gt;&gt;tmp;</span><br><span class="line">		<span class="built_in">push</span>(tmp);<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树的遍历模版 (前序中序后续) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,tr[<span class="number">110</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(<span class="type">int</span> k)</span><span class="comment">//前序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;tr[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="comment">//如果有左儿子,就继续perorder(左儿子)</span></span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k&lt;=n) <span class="built_in">preorder</span>(<span class="number">2</span>*k);</span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k+<span class="number">1</span>]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k+<span class="number">1</span>&lt;=n) <span class="built_in">preorder</span>(<span class="number">2</span>*k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> k)</span><span class="comment">//中序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k&lt;=n) <span class="built_in">inorder</span>(<span class="number">2</span>*k);</span><br><span class="line">	cout&lt;&lt;tr[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="comment">//如果有左儿子,就继续inorder(左儿子)</span></span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k+<span class="number">1</span>]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k+<span class="number">1</span>&lt;=n) <span class="built_in">inorder</span>(<span class="number">2</span>*k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(<span class="type">int</span> k)</span><span class="comment">//后序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果有左儿子,就继续postorder(左儿子)</span></span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k&lt;=n) <span class="built_in">postorder</span>(<span class="number">2</span>*k);</span><br><span class="line">	<span class="keyword">if</span> (tr[<span class="number">2</span>*k+<span class="number">1</span>]!=<span class="number">-1</span> &amp;&amp; <span class="number">2</span>*k+<span class="number">1</span>&lt;=n) <span class="built_in">postorder</span>(<span class="number">2</span>*k+<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;tr[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(tr,<span class="number">-1</span>,<span class="built_in">sizeof</span>(tr));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;tr[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;前序遍历: &quot;</span>;</span><br><span class="line">	<span class="built_in">preorder</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;后序遍历: &quot;</span>;</span><br><span class="line">	<span class="built_in">postorder</span>(<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h2><h3 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFS模板代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> num )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(  )<span class="comment">//到达边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行相应的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="comment">//尝试每一种可能</span></span><br><span class="line">        <span class="keyword">if</span> <span class="comment">//如果满足情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//标记</span></span><br><span class="line">            <span class="built_in">dfs</span>(  )<span class="comment">//继续下一步</span></span><br><span class="line">            <span class="comment">//恢复初始状态</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><em><em>题意：按照字典序输出自然数 11 到 n</em>n* 所有不重复的排列，即 n*n</em> 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;=n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,a[i]);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			vis[i]=<span class="number">1</span>;</span><br><span class="line">			a[sum]=i;</span><br><span class="line">			<span class="built_in">dfs</span>(sum+<span class="number">1</span>);</span><br><span class="line">			vis[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><p><strong>思路：第一种：全排列思路搜索顺序：枚举每一行皇后可放的位置。第二种：枚举每个格子（放、不放）。</strong></p>
<p>枚举每一行可放皇后的位置</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710220455075.png" alt="image-20220710220455075"></p>
<p>枚举每一个格子</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710220534287.png" alt="image-20220710220534287"></p>
<h4 id="巧解N皇后"><a href="#巧解N皇后" class="headerlink" title="巧解N皇后"></a>巧解N皇后</h4><p><a href="https://blog.csdn.net/daoshen1314/article/details/87353727">n皇后问题（dfs）_qdu_lkc的博客-CSDN博客_n皇后问题dfs</a></p>
<p><strong>只需判断同一列，同一斜线上是否只有一个皇后；</strong><br><strong>同一列很好实现，只需a[i]!&#x3D;a[j];</strong><br><strong>而同一斜线有点别扭，需要认真思考了；</strong><br><strong>同一斜线是哪条线呢？与底线为45度角或135度角的斜线；</strong><br><strong>列方程：</strong><br><strong>x代表行，y代表列；</strong><br><strong>y&#x3D;x+b；y&#x3D;b-x；</strong><br><strong>即y-x&#x3D;b;y+x&#x3D;b；</strong><br><strong>容易发现同一斜线上x与y的关系；所以直接判断就好了：<code>a[x]+x!=a[j]+j;a[x]-x!=a[j]-j;</code></strong></p>
<p><a href="https://cdutetcoj.xyz/problem/HDU-2553">N皇后问题 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//巧解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ok,i; </span><br><span class="line"><span class="comment">//行固定，列在变 </span></span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>];    <span class="comment">//a[col]=row 表示第col列第row行放置皇后</span></span><br><span class="line"><span class="type">int</span> sum[<span class="number">15</span>];  <span class="comment">//表示i皇后的方案数 </span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">//参数row表示要在第row行放置皇后 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(row&gt;n)<span class="comment">//表示一种方案结束 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]) <span class="keyword">continue</span>;<span class="comment">//如果第i列已经放置皇后，就不能再放置 </span></span><br><span class="line">		a[i]=row;         <span class="comment">//假设第i列能放 </span></span><br><span class="line">		<span class="type">int</span> ok=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//判断第i列能不能放置 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)  <span class="keyword">continue</span>; <span class="comment">//本身不需要再比较 </span></span><br><span class="line">			<span class="keyword">if</span>(!a[j]) <span class="keyword">continue</span>; <span class="comment">//如果第j列没有放置皇后, 则对i列无影响 </span></span><br><span class="line">			<span class="keyword">if</span>(a[j]-a[i]==j-i||a[j]-a[i]==i-j)&#123; <span class="comment">//两个对角线不允许放置两个皇后 </span></span><br><span class="line">				ok=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ok) <span class="built_in">dfs</span>(row+<span class="number">1</span>,n);<span class="comment">//可以把皇后放下一行 </span></span><br><span class="line">		a[i]=<span class="number">0</span>;             <span class="comment">//要把此列清空，为了能判断下一种方案 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line">		sum[i]=cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> n; </span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">	   cout&lt;&lt;sum[n]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h3><p><strong>宽度优先：每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。</strong></p>
<p>模板：</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710221258279.png" alt="image-20220710221258279"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> mp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n,m,q,p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt;qu;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin &gt;&gt; q &gt;&gt; p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; mp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	qu.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node u=qu.<span class="built_in">front</span>();</span><br><span class="line">		qu.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(u.x==q<span class="number">-1</span>&amp;&amp;u.y==p<span class="number">-1</span>)&#123;</span><br><span class="line">			cout &lt;&lt; u.step;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> tx=u.x+dx[i];</span><br><span class="line">			<span class="type">int</span> ty=u.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(tx&lt;<span class="number">0</span>||tx&gt;=n||ty&gt;=m)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(mp[ty][tx]==<span class="number">0</span>&amp;&amp;vis[ty][tx]==<span class="number">0</span>)&#123;</span><br><span class="line">				vis[ty][tx]=<span class="number">1</span>;</span><br><span class="line">				qu.<span class="built_in">push</span>(&#123;tx,ty,u.step+<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/T1249">Lake Counting - CDUTETCOJ</a></p>
<p><strong>题意：有一块N×M的土地，雨后积起了水，有水标记为‘W’，干燥为‘.’。八连通的积水被认为是连接在一起的。请求出院子里共有多少水洼？</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深搜</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">110</span>;  </span><br><span class="line"><span class="type">char</span> map[MAX][MAX];  </span><br><span class="line"><span class="type">int</span> vis[MAX][MAX];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(vis[x][y] == <span class="number">1</span> || map[x][y] == <span class="string">&#x27;.&#x27;</span>|| map[x][y] == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//若曾经访问过这个格子，或当前格子是空地，或者当前格子为0（即出界）则返回  </span></span><br><span class="line">    vis[x][y] = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//递归访问周围8个格子  </span></span><br><span class="line">    <span class="built_in">dfs</span>(x<span class="number">-1</span>,y<span class="number">-1</span>);   <span class="built_in">dfs</span>(x<span class="number">-1</span>,y);     <span class="built_in">dfs</span>(x<span class="number">-1</span>,y+<span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">dfs</span>(x,y<span class="number">-1</span>);                     <span class="built_in">dfs</span>(x,y+<span class="number">1</span>);  </span><br><span class="line">    <span class="built_in">dfs</span>(x+<span class="number">1</span>,y<span class="number">-1</span>);   <span class="built_in">dfs</span>(x+<span class="number">1</span>,y);     <span class="built_in">dfs</span>(x+<span class="number">1</span>,y+<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(map,<span class="number">0</span>,<span class="built_in">sizeof</span>(map));<span class="comment">//初始化为0，作为边界  </span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));<span class="comment">//初始化为0，表示全未访问过  </span></span><br><span class="line">    <span class="type">int</span> m,n,cnt = <span class="number">0</span>;  </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;++i)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)  </span><br><span class="line">            cin &gt;&gt; map[i][j];<span class="comment">//将地图放在矩阵中间，周围有一圈0，方便对出界的判断  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;++i)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j] &amp;&amp; map[i][j] == <span class="string">&#x27;W&#x27;</span>)<span class="comment">//若找到未被访问过的格子且当前格子是水  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                ++cnt;  </span><br><span class="line">                <span class="built_in">dfs</span>(i,j);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广搜</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span> , M = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> n,m,sum;</span><br><span class="line"><span class="type">char</span> mp[M][M];</span><br><span class="line"><span class="type">bool</span> st[M][M];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">( <span class="type">int</span> x , <span class="type">int</span> y )</span></span>&#123;</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">st[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( q.<span class="built_in">size</span>() )&#123;</span><br><span class="line">PII t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++ )&#123;</span><br><span class="line"><span class="type">int</span> xt = t.fi+dx[i];</span><br><span class="line"><span class="type">int</span> yt = t.se+dy[i];</span><br><span class="line"><span class="keyword">if</span>( xt &lt; <span class="number">0</span> || yt &lt; <span class="number">0</span> || xt &gt;= n || yt &gt;= m ) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>( mp[xt][yt] == <span class="string">&#x27;.&#x27;</span> ) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>( st[xt][yt] ) <span class="keyword">continue</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;xt,yt&#125;);</span><br><span class="line">st[xt][yt] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; m ; j++ )</span><br><span class="line">cin &gt;&gt; mp[i][j];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; m ; j++ )</span><br><span class="line"><span class="keyword">if</span>( !st[i][j] &amp;&amp; mp[i][j] == <span class="string">&#x27;W&#x27;</span> )&#123;</span><br><span class="line"><span class="built_in">bfs</span>( i , j );</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p><strong>1.可行性剪枝当前状态和题意不符，并且由于题目可以推出，往后的所有情况和题意都不符，那么就可以进行剪枝，直接把这种情况及后续的所有情况判负，直接返回。</strong></p>
<p><strong>2.最优性剪枝我们用搜索方法解决最优化问题的时候的一种常用剪枝。就是当你搜到一半的时候，已经比已经搜到的最优解要不优了，那么这个方案肯定是不行的，即刻停止搜索，进行回溯。</strong></p>
<p><strong>3.排除等效冗余在搜索过程中，如果我们能够判断搜索树的当前节点上沿着某几条分支到达子树是等效的，那么我们就只需要对一个子树进行搜索就可以了。</strong></p>
<p><strong>4.优化搜索顺序在搜索的问题中，搜索树的各个成面，分支的顺序不是固定的。不同的搜索顺序就会导致不同的搜索结果。</strong></p>
<p><strong>5.记忆化可以记录下每个状态的搜索结果，在重复遍历一个状态时直接索引返回。这就好比我们对图进行深度优先搜索时判断当前节点是否有被访问过。</strong></p>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1501">Problem - 1501 (hdu.edu.cn)</a></p>
<p><strong>zipper（DFS+剪枝）</strong></p>
<p><strong>题意：给定三个字符串，您将确定是否可以通过组合前两个字符串中的字符来形成第三个字符串。前两个字符串可以任意混合，但每个字符串必须保持其原始顺序。如果第三个字符串可以从前两个字符串形成，则为 yes</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> f;</span><br><span class="line">string s1,s2,s3;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u1,<span class="type">int</span> u2,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u1+u2==s3.<span class="built_in">size</span>())&#123;</span><br><span class="line">		f=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(vis[u1][u2]||f) <span class="keyword">return</span> ;</span><br><span class="line">	vis[u1][u2]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(u1&lt;n&amp;&amp;s1[u1]==s3[x])&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(u1+<span class="number">1</span>,u2,x+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(u2&lt;m&amp;&amp;s2[u2]==s3[x])&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(u1,u2+<span class="number">1</span>,x+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		n=s1.<span class="built_in">size</span>();</span><br><span class="line">		m=s2.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">if</span>(n+m!=s3.<span class="built_in">size</span>())&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Date set&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: no&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(f) cout &lt;&lt; <span class="string">&quot;Data set &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Data set &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: no&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分和折半枚举"><a href="#二分和折半枚举" class="headerlink" title="二分和折半枚举"></a>二分和折半枚举</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://blog.csdn.net/qq_41913134/article/details/108007808"> 二分查找算法细节详解_kyepaker的博客-CSDN博客_二分查找细节</a></p>
<p><strong>binary_search()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、为什么 while 循环的条件中是 &lt;&#x3D;，而不是 &lt;？</strong></p>
<p><strong>答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。</strong></p>
<p><strong>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</strong></p>
<p><strong>我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。</strong></p>
<p><strong>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。</p>
<p>while(left &lt;&#x3D; right) 的终止条件是 left &#x3D;&#x3D; right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p>while(left &lt; right) 的终止条件是 left &#x3D;&#x3D; right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p>当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、为什么 left &#x3D; mid + 1，right &#x3D; mid - 1？我看有的代码是 right &#x3D; mid 或者 left &#x3D; mid，没有这些加加减减，到底怎么回事，怎么判断？</strong></p>
<p><strong>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</strong></p>
<p><strong>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？</strong></p>
<p><strong>当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。</strong></p>
<p><strong>3、此算法有什么缺陷？</strong></p>
<p><strong>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</strong></p>
<p><strong>比如说给你有序数组 nums &#x3D; [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。</strong></p>
<p><strong>这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</strong></p>
<p><strong>&lt;mid &#x3D; (right- left)  &#x2F; 2+ left（防爆）&gt;</strong></p>
<p><strong>寻找左侧边界的二分搜索</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>二分查找函数：binary_search（）所在头文件：    include<algorithm></strong></p>
<p><strong>函数模板：      binary_search(arrfist,arrlast,value)</strong></p>
<p><strong>arrfist: 数组首地址  arrlast: 数组末地址后一个位置  value :  需要查找的值</strong></p>
<p><strong>函数功能 ：在数组中以二分法检索的方式查找，若在数组(<u>要求数组元素非递减</u>)中查找到value元素则返回真，若查找不到则返回值为假。</strong></p>
<p><strong>二分查找函数：lower_bound()所在头文件：  #include<algorithm></strong></p>
<p><strong>函数模板: lower_bound(arrfist , arrlast, value)</strong></p>
<p><strong>重载优先级：lower_bound(arrfist , arrlast, value, greater<T>()) (返回小于或等于value的） (要加头文件<algorithm>)</strong></p>
<p><strong>arrfist: 函数首地址   arrlast: 函数为地址   value :  需要查找的值</strong></p>
<p><strong>函数功能：  函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回指向<u>大于或等于</u>value的第一个元素的指针。如果所有元素都小于val，则返回last</strong></p>
<p><strong>二分查找函数： upper_bound()头文件：#include<algorithm></strong></p>
<p> <strong>函数模板： upper_bound(arrfist , arrlast, value)</strong></p>
<p><strong>重载优先级： upper_bound(arrfist , arrlast, value, greater<T>()) (返回小于value的)</strong></p>
<p><strong>arrfist: 函数首地址   arrlast: 函数为地址   value :  需要查找的值</strong></p>
<p><strong>函数功能： 函数upper_bound()在first和last中的前闭后开区间进行二分查找，返回指向<u>大于</u>value的第一个元素的指针。如果所有元素都小于val，则返回last</strong></p>
<p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102243_OCR\pic.jpg" alt="pic"></p>
<p><a href="https://codeforces.com/problemset/problem/1133/C">Problem - 1133C - Codeforces</a></p>
<p><strong>平衡队伍</strong></p>
<p><strong>题意：要找一个子序列，使得其中每个数的值得差值不能超过5.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> index=<span class="built_in">upper_bound</span>(a+i,a+n,a[i]+<span class="number">5</span>)-(a+i);</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,index);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一：最大化最小值:</strong> </p>
<p>  <strong>(1).  我们定义两个整数l,r,赋值l一个必定小于答案最小值的数,赋值r一个必定大于答案最大值的数.    (2).当答案区间[l, r]不够小时,不断执行步骤(3)  (3).每次循环取mid&#x3D;(l+r+1)&#x2F;2;判断答案为mid时是否符合条件,符合则令l&#x3D;mid,否则r&#x3D;mid-1,这样答案区间[l,r]一定会以logn的速度快速缩小.  (4).循环结束后的 l 即为答案</strong></p>
<p><strong>二：最小化最大值:</strong>  </p>
<p> <strong>(1). 我们定义两个整数l,r,赋值l一个必定小于答案最小值的数,赋值r一个必定大于答案最大值的数.    (2).当答案区间[l,r ]不够小时,不断执行步骤(3)    (3).每次循环取mid&#x3D;(l+r)&#x2F;2;判断答案为mid时是否符合条件,符合则令r&#x3D;mid,否则l&#x3D;mid+1,这样答案区间[l,r]一定会以logn的速度快速缩小.    (4).循环结束后的 l 即为答案</strong></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710225819199.png" alt="image-20220710225819199"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710225825774.png" alt="image-20220710225825774"></p>
<p><a href="https://www.luogu.com.cn/problem/P8198">P8198 背单词的小智 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><strong>题意大概就是讲序列 a 分成 k段，然后使这 k段 中的数的平方和的最大值尽可能的小，输出这个最大值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll m)</span></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>,day=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(sum+a[i]&gt;m) &#123;</span><br><span class="line">		sum=a[i];</span><br><span class="line">		day++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> day &lt;= k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll c=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		a[i]=a[i]*a[i];</span><br><span class="line">		c+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ll l=<span class="number">0</span>,r=c;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		ll mid=(l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/POJ-2456">Aggressive cows - CDUTETCOJ</a></p>
<p><strong>题意:</strong><br><strong>农民约翰建造了一个新的长形谷仓，有N（2 &lt;&#x3D; N &lt;&#x3D; 100,000）个畜栏。</strong><br><strong>牛棚沿直线位于x1,…,xN（0 &lt;&#x3D; xi &lt;&#x3D; 1,000,000）位置。他的C(2 &lt;&#x3D; C &lt;&#x3D; N)头奶牛不喜欢这种牛舍布局，一旦被放进牛棚，就会相互攻击。为了防止奶牛互相伤害，FJ想把奶牛分配到牛棚里，使任何两头奶牛之间的最小距离尽可能的大。最大的最小距离是多少？（二分最大的最小距离）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> dex[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">1</span>,index=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dex[i]-dex[index]&gt;=mid)&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			index=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;=c) </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin &gt;&gt; dex[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(dex+<span class="number">1</span>,dex+n+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=dex[n];</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="type">int</span> mid= (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) </span><br><span class="line">		l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710230618942.png" alt="image-20220710230618942"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710230628365.png" alt="image-20220710230628365"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710230636181.png" alt="image-20220710230636181"></p>
<p><a href="https://vjudge.net/problem/HihoCoder-1438">Gas Stations - HihoCoder 1438 - Virtual Judge (vjudge.net)</a></p>
<p><strong>加油站（浮点二分枚举）</strong></p>
<p><strong>题意：在一条长m的公路上，有n个加油站，你还可以修k个加油站，使得这条公路上相邻加油站的最大距离最小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> dex[maxn];	</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">		cnt+=dex[i]/mid;</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a,a+n);</span><br><span class="line">	<span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		dex[index++]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=m;</span><br><span class="line">	<span class="type">double</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">0.001</span>)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.llf&quot;</span>,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/problem/POJ-3122">Pie - CDUTETCOJ</a></p>
<p><strong>题意：一个小朋友生日和他的小伙伴们分一个蛋糕，总人数是f+1。保证每个人的体积相等，求每个人能得到的最大的蛋糕的体积（保留4位小数）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">int</span> n, f, t;</span><br><span class="line"><span class="type">double</span> aa[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">   cnt += aa[i] / x;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> cnt &gt;= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cin &gt;&gt; t;</span><br><span class="line">   <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; f;</span><br><span class="line">   f += <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> y;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    aa[i] = y * y * pi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(aa, aa + n);</span><br><span class="line">    <span class="type">double</span> l = <span class="number">0.00001</span>, r = aa[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(r -l &gt; <span class="number">0.00001</span>)&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2.0000</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="折半枚举"><a href="#折半枚举" class="headerlink" title="折半枚举"></a>折半枚举</h3><p><strong>折半思想是针对当数据规模较大时，而无法全部枚举。这时可以采取折半，就是先枚举一半的元素组合。接着在枚举另一半的元素组合，最后将他们的结果进行合并。</strong></p>
<p><strong>例如：给定4个数列A，B，C，D。要从每个数列中取出一个数，使4个数的和为0。（a, b, c, d）∈ Ax B x C x D  (每个数列的元素个数可以达到4000)并且  a + b + c + d &#x3D; 0。  求出这样的组合数个数？  当一个数列中有多个相同的数字，把他们作为不同的数字看待。</strong></p>
<p><strong>这道题第一时间想到的是每个数进行枚举，但这就有四个for循环，时间复杂度为O(n4),这样的情况肯定是不能够接受的。</strong>	</p>
<p><strong>于是我们可以转变思路，因为a + b + c + d &#x3D; 0，所以可变形为a + b &#x3D; -(c + d).这样我们就先枚举a + b、而后在枚举(c+ d)。再排序最后用二分查找进行比对，计算出组合结果有多少个。这样时间复杂度就降到O(n*nlogn^2)，这就是折半枚举。</strong></p>
<p><a href="https://cdutetcoj.xyz/training/4/problem/POJ-2785">4 Values whose Sum is 0 - CDUTETCOJ</a></p>
<p><strong>题意：给出 n 行，每行有 4 个数，每一列看做一个组，现在在每个组中选出一个数，问有多少种组合使得选出的 4 个数和为 0</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N],d[N],cd[N*N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cd[i*n+j]=c[i]+d[j];<span class="comment">//枚举求和；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(cd,cd+n*n);<span class="comment">//排序；</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> kk=-(a[i]+b[j]);<span class="comment">//找一个相反值，这样和就是0了；</span></span><br><span class="line">            res+=<span class="built_in">upper_bound</span>(cd,cd+n*n,kk)-<span class="built_in">lower_bound</span>(cd,cd+n*n,kk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/26/problem/POJ-2549">Sumsets - CDUTETCOJ</a></p>
<p><strong>题意:给出S，一个整数集，找出最大的d，使a+b+c&#x3D;d，其中a，b，c，和d是S的不同元素。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">-600000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a,a + n);</span><br><span class="line"><span class="type">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>;j &gt;= <span class="number">0</span>;j --)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j)</span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> sum = a[i] - a[j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>,r = j - <span class="number">1</span>;l &lt; r;) &#123;</span><br><span class="line"> <span class="keyword">if</span>(a[l] + a[r] == sum)&#123;</span><br><span class="line">ans = a[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(a[l] + a[r] &gt; sum)</span><br><span class="line">r--;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans != INF)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans != INF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans == INF)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><h3 id="高精度四则运算"><a href="#高精度四则运算" class="headerlink" title="高精度四则运算"></a>高精度四则运算</h3><p><strong>由于待处理的数据超过了任何一种数据类型所能容纳的范围，因此必须采用数字串的形式输入，并将其转化为整数数组。该数组的每一个元素对应一位十进制数，由其下标顺序指明位序号。运算规则如同算术运算。由于高精度运算的结果可能使得数据长度发生增减，因此除需要用整数数组存储数据外，还需要用一个整数变量记录整数数组的元素个数,即数据的实际长度。</strong></p>
<p><strong>因为整数的运算涉及到进位后位数的变化，那么正序存储大整数就会难以增加或减少位数，所以我们采用逆序存储的方法。</strong></p>
<p><strong>将数字串转化为整数数组的方法如下</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[N];</span><br><span class="line">bign b;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">b.len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.len; i++)</span><br><span class="line">    b.num[i] = a[b.len - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> num[N];</span><br><span class="line">    <span class="built_in">bign</span>() <span class="comment">//构造函数 方便初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">ch</span><span class="params">(<span class="type">char</span> a[])</span> <span class="comment">//将数字串转化为大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign b;</span><br><span class="line">    b.len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.len; i++)</span><br><span class="line">        b.num[i] = a[b.len - <span class="number">1</span> - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len, b.len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[i] += a.num[i] + b.num[i];</span><br><span class="line">        <span class="keyword">if</span> (c.num[i] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            c.num[i] -= <span class="number">10</span>;</span><br><span class="line">            c.num[i + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c.num[len] != <span class="number">0</span>)</span><br><span class="line">        len++;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; c.num[len - <span class="number">1</span>] == <span class="number">0</span>) <span class="comment">//消除前缀0</span></span><br><span class="line">        len--;</span><br><span class="line">    c.len = len;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span> <span class="comment">// a &gt; b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a.num[i] += <span class="number">10</span>;</span><br><span class="line">            a.num[i + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        c.num[i] = a.num[i] - b.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">mutli</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.num[i + j] += a.num[i] * b.num[j];</span><br><span class="line">            <span class="keyword">if</span> (c.num[i + j] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c.num[i + j + <span class="number">1</span>] += c.num[i + j] / <span class="number">10</span>;</span><br><span class="line">                c.num[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.len = a.len + b.len; <span class="comment">//两个数乘积的位数不超过两个数位数之和</span></span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a &gt;= b true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有前导零，要去除</span></span><br><span class="line">    <span class="keyword">if</span> (a.len &gt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.len &lt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num[i] &gt; b.num[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">copy</span><span class="params">(bign a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b.num[i + n] = a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    b.len = a.len + n;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">div</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len - b.len + <span class="number">1</span>; <span class="comment">//求商的位数（最多有这么多位）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        bign temp = <span class="built_in">copy</span>(b, i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">compare</span>(a, temp))</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">sub</span>(a, temp);</span><br><span class="line">            c.num[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pt</span><span class="params">(bign c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; c.num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a1[N], a2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign b1, b2, c;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; a2;</span><br><span class="line">    b1 = <span class="built_in">ch</span>(a1);</span><br><span class="line">    b2 = <span class="built_in">ch</span>(a2);</span><br><span class="line">    c = <span class="built_in">add</span>(b1, b2);</span><br><span class="line">    <span class="built_in">pt</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/27/problem/HDU-1715">大菲波数 - CDUTETCOJ</a></p>
<p>题意：输入第一行为一个整数N，接下来N行为整数Pi（斐波拉契）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span>,N=<span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> num[N];</span><br><span class="line">    <span class="built_in">bign</span>() <span class="comment">//构造函数 方便初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">ch</span><span class="params">(<span class="type">char</span> a[])</span> <span class="comment">//将数字串转化为大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign b;</span><br><span class="line">    b.len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.len; i++)</span><br><span class="line">        b.num[i] = a[b.len - <span class="number">1</span> - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">max</span>(a.len, b.len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c.num[i] += a.num[i] + b.num[i];</span><br><span class="line">        <span class="keyword">if</span> (c.num[i] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            c.num[i] -= <span class="number">10</span>;</span><br><span class="line">            c.num[i + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c.num[len] != <span class="number">0</span>)</span><br><span class="line">        len++;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; c.num[len - <span class="number">1</span>] == <span class="number">0</span>) <span class="comment">//消除前缀0</span></span><br><span class="line">        len--;</span><br><span class="line">    c.len = len;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span> <span class="comment">// a &gt; b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a.num[i] += <span class="number">10</span>;</span><br><span class="line">            a.num[i + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        c.num[i] = a.num[i] - b.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">mutli</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.num[i + j] += a.num[i] * b.num[j];</span><br><span class="line">            <span class="keyword">if</span> (c.num[i + j] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c.num[i + j + <span class="number">1</span>] += c.num[i + j] / <span class="number">10</span>;</span><br><span class="line">                c.num[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.len = a.len + b.len; <span class="comment">//两个数乘积的位数不超过两个数位数之和</span></span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a &gt;= b true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果有前导零，要去除</span></span><br><span class="line">    <span class="keyword">if</span> (a.len &gt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.len &lt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.num[i] &gt; b.num[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">copy</span><span class="params">(bign a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b.num[i + n] = a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    b.len = a.len + n;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bign <span class="title">div</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len - b.len + <span class="number">1</span>; <span class="comment">//求商的位数（最多有这么多位）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        bign temp = <span class="built_in">copy</span>(b, i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">compare</span>(a, temp))</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="built_in">sub</span>(a, temp);</span><br><span class="line">            c.num[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pt</span><span class="params">(bign c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; c.num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a1[N], a2[N];</span><br><span class="line">bign f[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  f[<span class="number">1</span>].len = <span class="number">1</span>, f[<span class="number">1</span>].num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">2</span>].len = <span class="number">1</span>, f[<span class="number">2</span>].num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">1000</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line">   f[i] = <span class="built_in">add</span>(f[i - <span class="number">1</span>], f[i - <span class="number">2</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">pt</span>(f[x]);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="大浮点数"><a href="#大浮点数" class="headerlink" title="大浮点数"></a>大浮点数</h3><p><a href="https://cdutetcoj.xyz/training/27/problem/POJ-1001">Exponentiation - CDUTETCOJ</a></p>
<p><strong>Exponentiation（幂）</strong></p>
<p><strong>题意：对一个实数R( 0.0 &lt; R &lt; 99.999 )，要求写程序精确计算 R 的 n 次方(Rn)，其中n 是整数并且 0 &lt; n &lt;&#x3D; 25。</strong><br><strong>Input</strong><br><strong>T输入包括多组 R 和 n。 R 的值占第 1 到第 6 列，n 的值占第 8 和第 9 列。</strong><br><strong>Output</strong><br><strong>对于每组输入，要求输出一行，该行包含精确的 R 的 n 次方。输出需要去掉前导的 0 后不要的 0 。如果输出是整数，不要输出小数点。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> num[N];</span><br><span class="line">  <span class="built_in">bign</span>() <span class="comment">//构造函数 方便初始化</span></span><br><span class="line"> &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in">sizeof</span>(num));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">bign <span class="title">ch</span><span class="params">(<span class="type">char</span> a[])</span> <span class="comment">//将数字串转化为大整数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign b;</span><br><span class="line">  b.len = <span class="built_in">strlen</span>(a);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.len; i++)</span><br><span class="line">    b.num[i] = a[b.len - <span class="number">1</span> - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">max</span>(a.len, b.len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    c.num[i] += a.num[i] + b.num[i];</span><br><span class="line">    <span class="keyword">if</span> (c.num[i] &gt;= <span class="number">10</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      c.num[i] -= <span class="number">10</span>;</span><br><span class="line">      c.num[i + <span class="number">1</span>]++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> (c.num[len] != <span class="number">0</span>)</span><br><span class="line">    len++;</span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; c.num[len - <span class="number">1</span>] == <span class="number">0</span>) <span class="comment">//消除前缀0</span></span><br><span class="line">    len--;</span><br><span class="line">  c.len = len;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span> <span class="comment">// a &gt; b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  c.len = a.len;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">   &#123;</span><br><span class="line">      a.num[i] += <span class="number">10</span>;</span><br><span class="line">      a.num[i + <span class="number">1</span>]--;</span><br><span class="line">   &#125;</span><br><span class="line">    c.num[i] = a.num[i] - b.num[i];</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    c.len--;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">mutli</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)</span><br><span class="line">   &#123;</span><br><span class="line">      c.num[i + j] += a.num[i] * b.num[j];</span><br><span class="line">      <span class="keyword">if</span> (c.num[i + j] &gt;= <span class="number">10</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        c.num[i + j + <span class="number">1</span>] += c.num[i + j] / <span class="number">10</span>;</span><br><span class="line">        c.num[i + j] %= <span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  c.len = a.len + b.len; <span class="comment">//两个数乘积的位数不超过两个数位数之和</span></span><br><span class="line">  <span class="comment">/*while (c.len &gt; 1 &amp;&amp; c.num[c.len - 1] == 0)</span></span><br><span class="line"><span class="comment">    c.len--;*/</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a &gt;= b true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//如果有前导零，要去除</span></span><br><span class="line">  <span class="keyword">if</span> (a.len &gt; b.len)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.len &lt; b.len)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num[i] &gt; b.num[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.num[i] &lt; b.num[i])</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">copy</span><span class="params">(bign a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    b.num[i + n] = a.num[i];</span><br><span class="line"> &#125;</span><br><span class="line">   b.len = a.len + n;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bign <span class="title">div</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bign c;</span><br><span class="line">  c.len = a.len - b.len + <span class="number">1</span>; <span class="comment">//求商的位数（最多有这么多位）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"> &#123;</span><br><span class="line">    bign temp = <span class="built_in">copy</span>(b, i);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">compare</span>(a, temp))</span><br><span class="line">   &#123;</span><br><span class="line">      a = <span class="built_in">sub</span>(a, temp);</span><br><span class="line">      c.num[i]++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    c.len--;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> point;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(bign a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt; point - <span class="number">1</span>; --i)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.num[i] != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a.num[i]);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a.num[i]);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cnt &lt;= point - <span class="number">1</span> &amp;&amp; a.num[cnt] == <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    cnt++;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt;= point - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = point - <span class="number">1</span>; i &gt;= cnt; --i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a.num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> a1[N], a2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; a1 &gt;&gt; x)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (a1[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        a2[j] = a1[i];</span><br><span class="line">        j++;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        point = len - i - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    point *= x;</span><br><span class="line">    bign b1 = <span class="built_in">ch</span>(a2);</span><br><span class="line">    bign b2 = b1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x - <span class="number">1</span>; i++)</span><br><span class="line">      b2 = <span class="built_in">mutli</span>(b2, b1);</span><br><span class="line">    <span class="built_in">print</span>(b2);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h3><p><strong>分类讨论：</strong></p>
<p><strong>1、当 n &lt;&#x3D; m 时，这时先手的人可以一次取走所有的；</strong></p>
<p><strong>2、当 n &#x3D; m + 1 时，这时先手无论取走多少个，后手的人都能取走剩下所有的；( m + 1 ) 是 1 次抓不完，2 次必能抓完的石子数，后手收尾局。</strong></p>
<p><strong>3、当 n &#x3D; k * (m + 1) 时 ( k 是整数 ) ，对于每 m + 1 个石子，先手取 x (1≤x≤m) 个，后手一定能将剩下的 (m + 1 - x) 个都取走，因此后手必胜；</strong></p>
<p><strong>4、当 n &#x3D; k * (m + 1) + x (0 &lt; x &lt; m + 1) 时，先手可以先取 x 个，之后的局势就回到了第 3 种情况，无论后手取多少个，先手都能取走 m + 1 个中剩下的，因此先手必胜。</strong></p>
<p><strong>结论：通过上面的分析可以得出结论：当 n 能被 m + 1 整除时，先手必败，否则先手必胜。</strong></p>
<p><strong>关键策略：对每 m + 1 个石子，先手总是无法取完，后手总是可以取完。</strong></p>
<p><strong>两个人轮流报数，一次最少报一最多报十，先报到100的人获胜，谁能赢？</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	<span class="keyword">while</span>(c--)&#123;</span><br><span class="line">		<span class="type">int</span> n,m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="type">int</span> s=n%(m+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/28/problem/HDU-2897">邂逅明下 - CDUTETCOJ</a></p>
<p><strong>巴什变式，仔细分析一下就能很快找出其实就是最大间距和最小间距的问题，因为每次至少取p个，最多取q个，所以现在状态向前找间距不超过最大间距之内只要有P状态那么此状态就是N状态，反之现在状态向前最大间距之内只要全是N状态那么此状态就是P状态。这样就容易得出结论，对于给定的p和q，PN图以（p+q）为周期循环，所以只要对(p+q)取一下模，然后模值在1到p内则为必败状态，模值在p+1到p + q为必胜状态，当模值为0时认为模值为p+q。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,p,q;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;p,&amp;q)==<span class="number">3</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%(p+q)&gt;p||n%(p+q)==<span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;WIN&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;LOST&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h3><p><strong>有两堆石子，石子数可以不同。两人轮流取石子，每次可以在一堆中取任意，或者从两堆中取走相同个数的石子，数量不限，取走最后一个石头的人获胜。判定先手是否必胜。</strong></p>
<p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102347_OCR\pic.jpg" alt="pic"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&gt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">		<span class="type">int</span> ans=(b-a)*((<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>);</span><br><span class="line">		<span class="keyword">if</span>(ans==a) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="斐波拉契博弈"><a href="#斐波拉契博弈" class="headerlink" title="斐波拉契博弈"></a>斐波拉契博弈</h3><p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102349_OCR\pic.jpg" alt="pic"></p>
<p><strong>比如85 ，85在55和89之间，于是可以写成85&#x3D;55+30，然后继续分解30,30在21和34之间，所以可以写成30&#x3D;21+9，依此类推，最后分解成85&#x3D;55+21+8+1。由于其中组成85的斐波那契数在数列中都不相邻，于是组成中的每一个斐波那契数都会大于下一个的两倍，先手先拿去最小的斐波那契数，下个斐波那契数，先手一定拿走最后一个石头。下下个斐波那契数也会是先手拿去最后一个，以此类推，先手会拿走整堆石头的最后一个。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> f[maxn];</span><br><span class="line">		f[<span class="number">1</span>]=<span class="number">1</span>,f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">50</span>;i++) f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>],mp[f[i]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)</span><br><span class="line">			<span class="built_in">puts</span>(mp[n]==<span class="number">1</span>?<span class="string">&quot;Second win&quot;</span>:<span class="string">&quot;First win&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h3><p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207102351_OCR\pic.jpg" alt="pic"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220710235711500.png" alt="image-20220710235711500"></p>
<h3 id="欧几里得博弈"><a href="#欧几里得博弈" class="headerlink" title="欧几里得博弈"></a>欧几里得博弈</h3><p><a href="https://blog.csdn.net/winter2121/article/details/81950819"> upc 【数论】欧几里得的游戏（博弈）_雪的期许的博客-CSDN博客_欧几里得博弈</a></p>
<p><img data-src="C:\Users\QQQ\Desktop\biji\QQ202207110026_OCR\pic.jpg" alt="pic"></p>
<p><strong>不妨设n&gt;m，若n%m&#x3D;&#x3D;0则为必胜状态。</strong></p>
<p><strong>必胜态的前一个状态肯定是（n，m+kn），即现在的必胜态肯定是m+n减掉了k倍的n得来的。如果k大于1,那么我完全可以不把m+kn的k个n都减掉而让对手拿到了必胜态，所以（n，m）的前一个状态一定是（m+n，n）。</strong></p>
<p><strong>所以，如果我遇到了一个状态（n，m），n&#x2F;m&#x3D;&#x3D;1，那我唯一的操作就是让n减掉m，这样下一个状态就有可能是必胜态。我并不想把必胜态让给对手，所以我想尽量不要遇到这样的（n，m）n&#x2F;m&#x3D;&#x3D;1；</strong></p>
<p><strong>那我就把这样的状态尽量留给我的对手，比如（10,4），那我就给对手留（6,4），而不是（2,4）；</strong></p>
<p><strong>然后，讨论一下n&#x2F;m&gt;1的情况：那我就可以掌控大局了，我从n中拿掉一些m，使得剩下的n&#x2F;m&#x3D;&#x3D;1或者m&#x2F;n&#x3D;&#x3D;1，这样对手就别无选择了，只能从大数中减掉一个小数，对手剩给我的就有可能是个必胜态，或者又是个n&#x2F;m&gt;1，或者n&#x2F;m&#x3D;&#x3D;1（这种情况因为我是先手，我可以预判一下，我是不会让这种事情发生的），因此我总是有办法赢。</strong></p>
<p><a href="https://cdutetcoj.xyz/training/28/problem/HDU-1525">Euclid’s Game - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n,m;</span><br><span class="line"> <span class="type">bool</span> p;</span><br><span class="line"> <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)</span><br><span class="line"> &#123;</span><br><span class="line">  p=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(n&lt;m) <span class="built_in">swap</span>(n,m);</span><br><span class="line">   <span class="keyword">if</span>(n%m==<span class="number">0</span>||n-m&gt;m) <span class="keyword">break</span>;</span><br><span class="line">   n-=m;</span><br><span class="line">   p=!p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p) cout &lt;&lt; <span class="string">&quot;Stan wins&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Oliie wins&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>[P3467 <a href="https://www.luogu.com.cn/problem/P3467">POI2008]PLA-Postering - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,temp,a,b,cnt;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">-1</span>);<span class="comment">//设边界</span></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;<span class="comment">//本题中宽度没用</span></span><br><span class="line">    s.<span class="built_in">push</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">top</span>()&gt;=b)<span class="comment">//一旦单调（递增）被破坏就把大与新人的都pop掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp=s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp==b)cnt++;<span class="comment">//若有相同的则可以省一张海报</span></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-cnt&lt;&lt;endl;<span class="comment">//输出共需多少张海报即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以方便(O(n))地求出一个数,左右第一个比它大&#x2F;小的数的位置</p>
<p>如何求—-</p>
<p>给一个序列  2,3,6,9,4,7,1</p>
<p>我们先求左边第一个比它小的</p>
<p>栈为空,a[S.top()]&lt;a[1] 所以 l[1]&#x3D;0,S.push(1)</p>
<p>单调栈里存的是编号<br>接下来a[S.top()]&lt;a[2] 所以l[2]&#x3D;S.top&#x3D;1, S.push(1)</p>
<p>同理</p>
<p>但是到4的时候</p>
<p>a[S.top()]&gt;a[5] 所以S.pop()</p>
<p>知道pop到3 此时 l[5]&#x3D;S.top&#x3D;1</p>
<p>总结一下有三步</p>
<p>1.把比它大的挤出去<br>2.栈顶为答案<br>3.将编号压入栈<br>我们发现栈始终是单调的</p>
<p>因为比当前数大的数会被挤出去</p>
<p>那右边的怎么求呢, 我们把序列反过来-&gt;1,7,4,9,6,3,2</p>
<p>然后按跟左边一样的方法求r[i]<br><a href="https://cdutetcoj.xyz/training/29/problem/5679">青藏高原 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> h[maxn];</span><br><span class="line"><span class="type">int</span> res[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;h[i];</span><br><span class="line">  s.<span class="built_in">push</span>(h[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    res[i] = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=h[i])&#123;</span><br><span class="line">      s.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">    s.<span class="built_in">push</span>(h[i]);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">while</span>(s.<span class="built_in">size</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">  s.<span class="built_in">push</span>(h[n<span class="number">-1</span>]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    res[i+<span class="number">1</span>] += s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=h[i])s.<span class="built_in">pop</span>();</span><br><span class="line">    s.<span class="built_in">push</span>(h[i]);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">   <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, res[i]);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>1、维护区间最值；<br>2、去除冗杂状态；<br>3、保持队列单调（最大值是单调递减序列，最小值是单调递增序列）；<br>4、最优选择在队首。</p>
<p>整理归纳单调队列的使用方法：</p>
<p>1、维护队首；<br>2、在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态） ；<br>3、取出需要的最优解（队列头的值即是）,借助最优解，得到目前所求的最优解（通常此处插入DP方程）。</p>
<p>单调队列的原理：</p>
<p>在处理f[i]时，去除冗杂、多余的状态，使得每个状态在队列中只会出现一次；同时维护一个能瞬间得出最优解的队列，减少重新访问的时间；在取得自己所需的值后，为后续的求解做好准备<br>题意：在机场有一群海象，当有一只年轻海象站在一只年龄大的海象前面时，年龄大的海象就会感到不愉快，它的不愉快值取决于离它最远的年轻海象的距离，让你求每只海象的不愉快值，若没有不愉快值，则输出“-1”。</p>
<p>思路：从最后一个数开始处理，若该数比队列中最后一个都小，则是-1，并加入队尾，否则就对队列中的数进行二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[maxx],b[maxx];</span><br><span class="line"><span class="type">int</span> x[maxx],p[maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span> || x[sum<span class="number">-1</span>]&gt;=a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            x[sum]=a[i];</span><br><span class="line">            p[sum++]=i;</span><br><span class="line">            b[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k,l=<span class="number">0</span>,r=sum<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x[mid]&lt;a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    k=mid;</span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[i]=p[k]-i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈夫曼树及编码，并查集和带权并查集"><a href="#哈夫曼树及编码，并查集和带权并查集" class="headerlink" title="哈夫曼树及编码，并查集和带权并查集"></a>哈夫曼树及编码，并查集和带权并查集</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>哈夫曼树也叫最优二叉树（哈夫曼树）</strong></p>
<p>权值：树的结点带有的某种意义的数值</p>
<p>带权路径长度：从树的跟该结点的路径长度（经过的边数）与该点的权值的乘积</p>
<p>树的带权路径长度（WPL）：所有叶结点的带权路径长度之和</p>
<p><img data-src="https://img-blog.csdnimg.cn/66308140907d46c4a72ca4f7ee405deb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>哈夫曼树：n个结点形成的所有二叉树中，wpl值最低的树（也称为最优二叉树）</p>
<h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><ol>
<li>找到当前权值最低的两个结点，形成一个新的树，其根节点权值为两点之和</li>
<li>在森林中将两个结点删除，并将该树加入。</li>
<li>循环进行1、2，直到森林中仅有一棵树为止</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/6320e1a77d264759a8bee685b26faa5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<ol>
<li>cd结点权值最低，形成新的结点</li>
<li>b（cd）结点权值最低，形成新的结点</li>
<li>a（b（cd））权值最低，形成新的结点</li>
</ol>
<p>哈夫曼树的性质<br>哈夫曼树不唯一<br>权值越小的结点路径长度越大<br>哈夫曼树的结点总数为2n - 1<br>哈夫曼树构造前，结点总数为n<br>构造哈夫曼树需要执行n - 1次合并，每次合并新增一个结点，即新增n - 1个结点<br>n + n - 1 &#x3D; 2n - 1<br>哈夫曼树不存在度为1的点（要么为0（叶子结点），要么为2（分支节点）</p>
<p><strong>哈夫曼编码</strong></p>
<p>前缀编码：没有一个编码是另一个编码的前缀</p>
<p><img data-src="https://img-blog.csdnimg.cn/f5281caa54d8484f84dc38f8c42a13ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>由哈夫曼树构造哈夫曼编码，0向左子树，1向右子树（01指向左还是右没有明确规定）</p>
<p>哈夫曼编码的作用是可以不采用固定长度编码方式，从而压缩数据</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a href="https://blog.csdn.net/the_ZED/article/details/105126583?ops_request_misc=%7B%22request_id%22:%22165777041516782248537500%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165777041516782248537500&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105126583-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2226.3001.4187">【算法与数据结构】—— 并查集_酱懵静的博客-CSDN博客_并查集</a></p>
<p>并查集：将元素划分为若干个互不相干的子集</p>
<p>并：将两个集合归并为一个集合（让一个树成为另一个树的子树）</p>
<p>查：确定一个指定元素的集合（查看其根节点是哪一个）</p>
<p>采用双亲表示法：并和查仅需更改或查看指向其双亲结点的伪指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> UFsets[MAXSIZE];    <span class="comment">//集合数组</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//-1表示集合中（森林）每个元素都是独立的个体（树）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++) S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查找，传入数组和数组下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环遍历查找其根节点，根节点的值为-1</span></span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>) x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//并，两个集合合并为一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> root1, <span class="type">int</span> root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//两个元素是同一个集合</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将root2的根节点改为root1</span></span><br><span class="line">    S[root2] = root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集的Union操作的优化"><a href="#并查集的Union操作的优化" class="headerlink" title="并查集的Union操作的优化"></a>并查集的Union操作的优化</h4><p>如果每次都是大树合并到小树，则树的高度可能会增加，导致并查集的使用效率降低，因此，可以让小树合并到大树，延缓树的增高</p>
<p>优化：根节点的数据的绝对值等于其结点总数，结点总数更大的树为大树，将更小的树并入大树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> root1, <span class="type">int</span> root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//root1的树结点更多，相较下root2为大树</span></span><br><span class="line">    <span class="keyword">if</span> (root1 &lt; root2)&#123;</span><br><span class="line">        S[root1] += S[root2];    <span class="comment">//root1的结点数更新</span></span><br><span class="line">        S[root2] = root1;    <span class="comment">//root2并入root1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    <span class="comment">//root2为大树</span></span><br><span class="line">        S[root2] += S[root1];    <span class="comment">//root2的结点数更新</span></span><br><span class="line">        S[root1] = root2;    <span class="comment">//root1并入root2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并查集的Find操作的优化（压缩路径）"><a href="#并查集的Find操作的优化（压缩路径）" class="headerlink" title="并查集的Find操作的优化（压缩路径）"></a>并查集的Find操作的优化（压缩路径）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="comment">//向上循环遍历树，找到其根节点</span></span><br><span class="line">    <span class="keyword">while</span>(S[root] &gt;= <span class="number">0</span>) root = S[root];</span><br><span class="line">    <span class="keyword">while</span> (x != root)&#123;</span><br><span class="line">        <span class="type">int</span> temp = S[x];</span><br><span class="line">        S[x] = root;    <span class="comment">//将x的双亲结点改为root</span></span><br><span class="line">        x = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/32/problem/T1347">格子游戏 - CDUTETCOJ</a></p>
<p><strong>思路</strong></p>
<p><strong>使用并查集，将点的坐标映射为1个数</strong></p>
<p><strong>已经被连通的点构成一个集合</strong></p>
<p><strong>判断两点成边后是否形成一个连通块，即判断这两点是否之前已经被连通，也就是判断这两点是否在同一个集合内</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[maxn], n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DR</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * n; i ++) p[i] = i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; ch;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        a = <span class="built_in">DR</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;D&#x27;</span>) b=<span class="built_in">DR</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> b=<span class="built_in">DR</span>(x, y + <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> fa = <span class="built_in">find</span>(a), fb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (fa == fb) &#123;</span><br><span class="line">            sum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p[fa] = fb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum&gt;<span class="number">0</span>) cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;draw&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>带权值的并查集只不过是在并查集中加入了一个value[ ]数组</p>
<p>value[ ]可以记录很多种东西，不一定是类似距离这种东西，也可以是相对于根节点的状态</p>
<p>加入了权值，函数应该有一些改变</p>
<p>找到一个点的祖先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfat</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fat[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> tmp=fat[x];</span><br><span class="line">	fat[x]=<span class="built_in">findfat</span>(fat[x]);</span><br><span class="line">	<span class="comment">//在此处修改val比如：</span></span><br><span class="line">	value[x]=value[tmp]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fat[x]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/32/problem/HDU-3038">How Many Answers Are Wrong - CDUTETCOJ</a></p>
<p>题意:</p>
<p>给定一段区间的和为x，问当前区间的和与前面的区间有没有冲突，如果有则是错误答案。最后输出错误答案数。<br>    eg:<br>    [1, 10] &#x3D; 5<br>    [1, 3] &#x3D; 2<br>    [4, 10] &#x3D; 4<br>    很显然第三个区间就是错误的，因为[1,3]+[4,10] !&#x3D; [1,10].</p>
<p><strong><strong>借助一个载体(根节点)，记录左端点到其根节点的和与右端点到根节点的和，</strong><br><strong>我们以集合的最左端为根节点，判断以下三种情况。</strong><br>    <strong>1.l的根节点和r的根节点相同， 判断sum[r] - sum[l] &#x3D;&#x3D; w; w为sum[r - l]</strong><br>    <strong>2.l的根节点大于r的根节点，l的根节点认其r的根节点为根结点。</strong><br>    <strong>更新sum[l的根节点] &#x3D; sum[r] - sum[l] - w;</strong><br>    <strong>3.r的根节点大于l的根节点，r的根节点认其l的根节点为根结点。</strong><br>    <strong>更新sum[r的根节点] &#x3D; sum[l] - sum[r] + w;</strong><br><strong>根据区间合并原理，我们将左端点-1处理成闭区间，以上面的例子为例，处理为(0,3] + (3, 10] &#x3D; (0,10] &#x3D;&#x3D; [1,10].</strong></strong>  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="type">int</span> f[maxn], sum[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == f[x])	<span class="keyword">return</span> f[x];</span><br><span class="line">	<span class="type">int</span> k = <span class="built_in">find</span>(f[x]);</span><br><span class="line">	sum[x] += sum[f[x]];<span class="comment">//进行和的更新</span></span><br><span class="line">	<span class="keyword">return</span> f[x] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		f[i] = i;</span><br><span class="line">		sum[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))&#123;</span><br><span class="line">		<span class="built_in">init</span>(n);</span><br><span class="line">		<span class="type">int</span> l, r, w, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (m--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;w);</span><br><span class="line">			l--;<span class="comment">//根据区间合并原理，左端点需-1. </span></span><br><span class="line">			<span class="type">int</span> sl = <span class="built_in">find</span>(l);</span><br><span class="line">			<span class="type">int</span> sr = <span class="built_in">find</span>(r);</span><br><span class="line">			<span class="keyword">if</span> (sl == sr &amp;&amp; sum[r] - sum[l] != w)&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//进行合并时，认最左端点为父亲。</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (sl &gt; sr)&#123;</span><br><span class="line">				f[sl] = sr;</span><br><span class="line">				sum[sl] = sum[r] - sum[l] - w;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (sl &lt; sr)&#123;</span><br><span class="line">				f[sr] = sl;</span><br><span class="line">				sum[sr] = sum[l] - sum[r] + w;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线段树和树状数组"><a href="#线段树和树状数组" class="headerlink" title="线段树和树状数组"></a>线段树和树状数组</h2><p><a href="https://blog.csdn.net/t_zht/article/details/111871840?ops_request_misc=%7B%22request_id%22:%22165807186616781435422905%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165807186616781435422905&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-111871840-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84&spm=1018.2226.3001.4187">(线段树和树状数组_TtingZh的博客-CSDN博客_树状数组和线段树的区别</a></p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树是一种二叉搜索树，什么叫做二叉搜索树，首先满足二叉树，每个结点度小于等于二，即每个结点最多有两颗子树，何为搜索，我们要知道，线段树的每个结点都存储了一个区间，也可以理解成一个线段，而搜索，就是在这些线段上进行搜索操作得到你想要的答案。</p>
<p>1．线段树的建立</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122818004186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rfemh0,size_16,color_FFFFFF,t_70" alt="img"></p>
<ol start="2">
<li>线段树的存储</li>
</ol>
<p>构建一个满<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">二叉树</a>，这样能很快的找到左右孩子</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122818004193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rfemh0,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">所有和树相关的下标都加一个node</span></span><br><span class="line"><span class="comment">其他的是原始数组的下标 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//arr是原始数组 tree是构建的线段树数组 node表示要构建的线段树数组的下标 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tree[], <span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">if</span>(start == end) &#123;<span class="comment">//递归出口，即走到叶子节点，</span></span><br><span class="line">		tree[node] = arr[start];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> left_node = <span class="number">2</span>*node+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> right_node = <span class="number">2</span>*node+<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//递归，先算左节点，再算右节点</span></span><br><span class="line">		<span class="built_in">build_tree</span>(arr, tree, left_node, start, mid);</span><br><span class="line">		<span class="built_in">build_tree</span>(arr, tree, right_node, mid+<span class="number">1</span>, end);</span><br><span class="line">		<span class="comment">//填值 左边的和右边的相加</span></span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;	</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//把arr的idx改成 val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tree[], <span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> idx, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//递归出口，即到达叶子节点 </span></span><br><span class="line">	<span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">		arr[idx] = val;</span><br><span class="line">		tree[node] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//确定需要修改的区间范围 </span></span><br><span class="line">		<span class="keyword">if</span>(idx &gt;= start &amp;&amp; idx &lt;= mid)&#123;</span><br><span class="line">			<span class="built_in">update_tree</span>(arr, tree, left_node, start, mid, idx, val);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">update_tree</span>(arr, tree, right_node, mid+<span class="number">1</span>, end, idx, val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后更新根节点 </span></span><br><span class="line">		tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查询是左端点L到右端点R的区间和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_tree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tree[], <span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//看递归过程 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;start=&quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot;  end=&quot;</span> &lt;&lt; end &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span>(R &lt; start || L &gt; end)&#123; <span class="comment">//递归出口  空间没有重叠的范围 直接return </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(L &lt;= start &amp;&amp; end &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">return</span> tree[node];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(start == end)&#123; <span class="comment">//算到叶子节点，直接返回这个 </span></span><br><span class="line">		<span class="keyword">return</span> tree[node];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; <span class="comment">//从跟节点出发 从中间劈开 算左边的和右边的，然后将两者相加</span></span><br><span class="line">		<span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> left_node = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> right_node = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> sum_left = <span class="built_in">query_tree</span>(arr, tree, left_node, start, mid, L, R);</span><br><span class="line">		<span class="type">int</span> sum_right = <span class="built_in">query_tree</span>(arr, tree, right_node, mid+<span class="number">1</span>, end, L, R);</span><br><span class="line">		<span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line">	<span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> tree[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">build_tree</span>(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size<span class="number">-1</span>); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;tree[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; tree[i] &lt;&lt; endl; </span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">	<span class="built_in">update_tree</span>(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size<span class="number">-1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;tree[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; tree[i] &lt;&lt; endl; </span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">	<span class="type">int</span> s = <span class="built_in">query_tree</span>(arr, tree, <span class="number">0</span>, <span class="number">0</span>, size<span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/31/problem/HDU-1166">敌兵布阵 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;  <span class="comment">//输入数据,构造线段树数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lft,rht;</span><br><span class="line">    <span class="type">int</span> sum;    <span class="comment">//区间和</span></span><br><span class="line">    <span class="type">int</span> maxx;   <span class="comment">//区间最大值</span></span><br><span class="line">    <span class="type">int</span> minn;   <span class="comment">//区间最小值</span></span><br><span class="line">    <span class="type">int</span> lazy;   <span class="comment">//延迟标记,减小时间复杂度</span></span><br><span class="line">&#125;segTree[N*<span class="number">4</span>];  <span class="comment">//需要开4倍</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;    <span class="comment">//区间合并,上放</span></span><br><span class="line">    segTree[id].sum = segTree[id*<span class="number">2</span>].sum+segTree[id*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(segTree[id].lazy)&#123;   <span class="comment">//区间修改过,需要下放</span></span><br><span class="line">        <span class="comment">//在原来的值上加上val</span></span><br><span class="line">        segTree[id*<span class="number">2</span>].sum += (segTree[id*<span class="number">2</span>].rht-segTree[id*<span class="number">2</span>].lft+<span class="number">1</span>)*segTree[id].lazy;</span><br><span class="line">        segTree[id*<span class="number">2</span>+<span class="number">1</span>].sum += (segTree[id*<span class="number">2</span>+<span class="number">1</span>].rht-segTree[id*<span class="number">2</span>+<span class="number">1</span>].lft+<span class="number">1</span>)*segTree[id].lazy;</span><br><span class="line">        segTree[id*<span class="number">2</span>].lazy += segTree[id].lazy;</span><br><span class="line">        segTree[id*<span class="number">2</span>+<span class="number">1</span>].lazy += segTree[id].lazy;</span><br><span class="line">        segTree[id].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    segTree[id].lft = l, segTree[id].rht = r;</span><br><span class="line">    segTree[id].lazy = <span class="number">0</span>, segTree[id].sum = <span class="number">0</span>;   <span class="comment">//开始一定要清0</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;            <span class="comment">//到达叶子节点,不继续建树</span></span><br><span class="line">        segTree[id].sum = a[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                  <span class="comment">//否则继续建树</span></span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(id*<span class="number">2</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(id*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushUp</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upDate</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;    <span class="comment">//更新l~r区间,加val,或减val(就传-val),或改成val</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=segTree[id].lft&amp;&amp;r&gt;=segTree[id].rht)&#123;</span><br><span class="line">        segTree[id].sum += (segTree[id].rht-segTree[id].lft+<span class="number">1</span>)*val;</span><br><span class="line">        segTree[id].lazy += val;  <span class="comment">//延迟标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">pushDown</span>(id);   <span class="comment">//区间下放</span></span><br><span class="line">        <span class="type">int</span> mid = (segTree[id].lft+segTree[id].rht)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid)</span><br><span class="line">            <span class="built_in">upDate</span>(id*<span class="number">2</span>,l,r,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=mid+<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">upDate</span>(id*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">upDate</span>(id*<span class="number">2</span>,l,r,val);</span><br><span class="line">            <span class="built_in">upDate</span>(id*<span class="number">2</span>+<span class="number">1</span>,l,r,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushUp</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;  <span class="comment">//查询l~r的值</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=segTree[id].lft&amp;&amp;r&gt;=segTree[id].rht)&#123;  <span class="comment">//该区间包含在查询区间内，可直接返回</span></span><br><span class="line">        <span class="keyword">return</span> segTree[id].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(id);  <span class="comment">//区间下放</span></span><br><span class="line">    <span class="type">int</span> mid = (segTree[id].lft+segTree[id].rht)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)&#123;  <span class="comment">//只用管左子树</span></span><br><span class="line">        ans += <span class="built_in">query</span>(id*<span class="number">2</span>,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=mid+<span class="number">1</span>)&#123;  <span class="comment">//只用管右子树</span></span><br><span class="line">        ans+=<span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans += <span class="built_in">query</span>(id*<span class="number">2</span>,l,r)+<span class="built_in">query</span>(id*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,cnt);</span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot; %s&quot;</span>,&amp;op))&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">upDate</span>(<span class="number">1</span>,x,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">upDate</span>(<span class="number">1</span>,x,x,-y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,x,y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/31/problem/HDU-7059">Counting Stars - CDUTETCOJ</a></p>
<p>题意：给你n个数字，你需要对他进行区间操作，共有三种</p>
<p>1.对[l,r]区间求和并取模；</p>
<p>2.对于[l,r]区间里的每一个数减去它的lowbit，也就是去掉这个数二进制的最低位；</p>
<p>3.对于[l,r]区间里的每一个数加上 2的k次方，k满足 2的k次方&lt;&#x3D;ai&lt;2的k+1次方，也就是相当于把这个数的二进制最高位左移一位；</p>
<p><strong>思路：建立一颗线段树，对于每个数拆成两部分存储，sum1存这个数字的二进制最高位，比如10，二进制是1010，那sum1存8，sum2存除最高位外的数，二进制位是1010，sum2就应该存2；</strong></p>
<p><em><em>对于每次加法只需要把区间的sum1</em>&#x3D;2，sum2不变，就是一个简单的线段树加法模板。对于每次减法，需要单点修改，sum2-&#x3D;lowbit（sum2）即可。注意的是需要有个标记，来标记这个区间内是否都为0，如果都为0，就不必走下去，如果有1就继续走。</em>*</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">LL a1[maxn], a2[maxn];</span><br><span class="line"><span class="function">LL <span class="title">lowbit</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线段树：s1维护最高位, s2维护剩余位，tg1表示区间乘2，tg2表示区间全为0。</span></span><br><span class="line">LL s1[maxn&lt;&lt;<span class="number">2</span>], s2[maxn&lt;&lt;<span class="number">2</span>], tg1[maxn&lt;&lt;<span class="number">2</span>], tg2[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lch p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rch p&lt;&lt;1|1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;   <span class="comment">//更新完pushup</span></span><br><span class="line">	s1[p] = (s1[lch]+s1[rch])%mod;	<span class="comment">//维护区间和</span></span><br><span class="line">	s2[p] = (s2[lch]+s2[rch])%mod;  <span class="comment">//维护区间和</span></span><br><span class="line">	tg2[p] = tg2[lch]&amp;tg2[rch];		<span class="comment">//左右子树都全为0了才为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="comment">//查询前pushdown</span></span><br><span class="line">	tg1[lch] = tg1[lch]*tg1[p]%mod;</span><br><span class="line">	tg1[rch] = tg1[rch]*tg1[p]%mod;</span><br><span class="line">	s1[lch] = s1[lch]*tg1[p]%mod;</span><br><span class="line">	s1[rch] = s1[rch]*tg1[p]%mod;</span><br><span class="line">	tg1[p] = <span class="number">1</span>;</span><br><span class="line">	tg2[lch] |= tg2[p];</span><br><span class="line">	tg2[rch] |= tg2[p];</span><br><span class="line">	<span class="keyword">if</span>(tg2[lch])s2[lch] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(tg2[rch])s2[rch] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tg1[p] = <span class="number">1</span>, tg2[p] = <span class="number">0</span>;		 <span class="comment">//区间乘标记1,全为0标记0。</span></span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		s1[p] = a1[l], s2[p] = a2[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(lch, l, mid);</span><br><span class="line">	<span class="built_in">build</span>(rch, mid+<span class="number">1</span>, r);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr)</span></span>&#123;<span class="comment">//return sum&#123;s1+s2&#125;[ll,rr];</span></span><br><span class="line">	<span class="keyword">if</span>(ll&gt;r || rr&lt;l)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(ll&lt;=l &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">		<span class="keyword">return</span> (s1[p]+s2[p])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	LL ans = <span class="number">0</span>;</span><br><span class="line">	ans += <span class="built_in">query</span>(lch, l, mid, ll, rr);</span><br><span class="line">	ans += <span class="built_in">query</span>(rch, mid+<span class="number">1</span>, r, ll, rr);</span><br><span class="line">	ans %=mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update1</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr)</span></span>&#123;<span class="comment">//s2[ll,rr]-=lowbit;(暴力)</span></span><br><span class="line">	<span class="keyword">if</span>(ll&gt;r || rr&lt;l)<span class="keyword">return</span> ;<span class="comment">//区间在范围外</span></span><br><span class="line">	<span class="keyword">if</span>(tg2[p])<span class="keyword">return</span> ;		<span class="comment">//区间全为0，再见</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;				<span class="comment">//到叶节点才能单点暴力修改</span></span><br><span class="line">		<span class="keyword">if</span>(s2[p]!=<span class="number">0</span>)&#123; s2[p]-=<span class="built_in">lowbit</span>(s2[p]);&#125;<span class="comment">//去掉一个lowbit</span></span><br><span class="line">		<span class="keyword">else</span> &#123;s1[p]=<span class="number">0</span>; tg2[p]=<span class="number">1</span>;&#125;<span class="comment">//除了最高位已经都是0了，那最高位没了</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update1</span>(lch, l, mid, ll, rr);</span><br><span class="line">	<span class="built_in">update1</span>(rch, mid+<span class="number">1</span>, r, ll, rr);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr)</span></span>&#123;<span class="comment">//s1[ll,rr] *= 2;(Lazy)</span></span><br><span class="line">	<span class="keyword">if</span>(ll&gt;r || rr&lt;l)<span class="keyword">return</span> ;   <span class="comment">//区间完全在范围外</span></span><br><span class="line">	<span class="keyword">if</span>(ll&lt;=l &amp;&amp; r&lt;=rr)&#123;		   <span class="comment">//区间完全被包含</span></span><br><span class="line">		s1[p] = s1[p]*<span class="number">2</span>%mod;   <span class="comment">//sum[l,r] *= 2;</span></span><br><span class="line">		tg1[p] = tg1[p]*<span class="number">2</span>%mod; <span class="comment">//lazy tag, then return ;</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update2</span>(lch, l, mid, ll, rr);</span><br><span class="line">	<span class="built_in">update2</span>(rch, mid+<span class="number">1</span>, r, ll, rr);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> T;  cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			LL x;  cin&gt;&gt;x;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">30</span>; k&gt;=<span class="number">0</span>; k--)&#123;</span><br><span class="line">				<span class="keyword">if</span>((<span class="number">1ll</span>&lt;&lt;k)&lt;=x)&#123;	<span class="comment">//找到最高位</span></span><br><span class="line">					a1[i] = <span class="number">1ll</span>&lt;&lt;k; <span class="comment">//提取最高位</span></span><br><span class="line">					a2[i] = x-a1[i];<span class="comment">//存剩余的数</span></span><br><span class="line">					<span class="keyword">break</span>; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		<span class="type">int</span> q;  cin&gt;&gt;q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">			<span class="type">int</span> op, l, r;  cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			<span class="keyword">if</span>(op==<span class="number">1</span>)cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)<span class="built_in">update1</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">update2</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>[x]保存以为根的子树中叶节点值的和</p>
<p>t[x]节点的长度等于lowbit(x)</p>
<p>t[x]节点的父节点为t[x+lowbit(x)]</p>
<p>整棵树的深度为log2n +1</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201228180041139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rfemh0,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>]; <span class="comment">//原始数组</span></span><br><span class="line"><span class="type">int</span> t[<span class="number">1010</span>]; <span class="comment">//树状数组 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//单点修改 在x位置上加k </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">		t[x] += k;</span><br><span class="line">		x += x&amp;-x;</span><br><span class="line">	&#125; 	</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//区间查询 x位置的前缀和 a[0....i]的和 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		ans += t[x];</span><br><span class="line">		x -= x&amp;-x;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">add</span>(i, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> left, right;</span><br><span class="line">	cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">ask</span>(right) - <span class="built_in">ask</span>(left<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/31/problem/HDU-1754">I Hate It - CDUTETCOJ</a></p>
<p><img data-src="https://www.programminghunter.com/images/247/61/6188ce464768a9e0111ecf25ca6cf5c7.png" alt="img"></p>
<p><strong>由于加入了一个新值，所以直接改变c[]是没有问题的。看这个for。举个例子：id&#x3D;8，i&#x3D;1，2，4。c[8]分别和c[4],c[6]c[7]进行了max更新，所以这个 id-i，是把所有id以内的区间进行了更新，覆盖了所有i&lt;&#x3D;id的数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[maxn],a[maxn],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(id&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[id]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">lowbit</span>(id);i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            c[id]=<span class="built_in">max</span>(c[id],c[id-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        id+=<span class="built_in">lowbit</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> md=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        md=<span class="built_in">max</span>(md,a[r]);</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">for</span>(;r-l&gt;=<span class="built_in">lowbit</span>(r);r-=<span class="built_in">lowbit</span>(r))</span><br><span class="line">        &#123;</span><br><span class="line">            md=<span class="built_in">max</span>(md,c[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> md;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            <span class="built_in">update</span>(i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> ch[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ch);</span><br><span class="line">            <span class="keyword">if</span>(ch[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> l,r;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(l,r)&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> id,x;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;id,&amp;x);</span><br><span class="line">                a[id]=x;</span><br><span class="line">                <span class="built_in">update</span>(id,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><a href="https://blog.csdn.net/qq_49688477/article/details/118879270?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118879270-blog-80862805.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-118879270-blog-80862805.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=2"> 【数据结构】字典树TrieTree图文详解_Avalon Demerzel的博客-CSDN博客_字典树</a></p>
<p>首先字典树是一种<strong>数据结构</strong>,用于处理大量<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>.,优点在于利用字符串的公共前缀,在存储时节约存储空间,并在查询时最大限度的减少无谓的字符串比较.</p>
<p><img data-src="https://img-blog.csdn.net/20180717203719720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTY0NzI3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>颜色为黑色的表示只是字符串中间的字符,为蓝色的表示是字符串末尾的那个字符,空白那个是树根节点.每个节点的意义实际上就是根节点到这个结点所经过的每个字符组成的字符串.故而图中这个树实际上意味着已存在字符串””,”to”,”tea”,”ted”,”ten”,”a”,”i”,”in”,”inn”</p>
<h3 id="1-以数组模拟动态分配的只带增查的字典树模版"><a href="#1-以数组模拟动态分配的只带增查的字典树模版" class="headerlink" title="(1).以数组模拟动态分配的只带增查的字典树模版"></a>(1).以数组模拟动态分配的只带增查的字典树模版</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个只带添加字符串与查找字符串的字典树（为了效率以数组实现） </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> charmapping[<span class="number">256</span>]; <span class="comment">//字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_charmapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123; <span class="comment">//我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span></span><br><span class="line">		charmapping[i]=i-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">26</span>; <span class="comment">//这里假设字符串中只出现26个小写字母 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">	<span class="type">bool</span> end; <span class="comment">//标志此节点是否是某字符串的结尾 </span></span><br><span class="line">	treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line">treenode memory[maxm]; <span class="comment">//字典树所用到的数组空间</span></span><br><span class="line"><span class="type">int</span> mallocp=<span class="number">0</span>;  <span class="comment">//模拟内存分配</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	head.end=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) head.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">treenode* <span class="title">createnew</span><span class="params">()</span></span>&#123;</span><br><span class="line">	treenode* newnode;</span><br><span class="line">	newnode=&amp;memory[mallocp++];</span><br><span class="line">	newnode-&gt;end=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) newnode-&gt;next[i]=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,temp;</span><br><span class="line">	treenode* t=&amp;head;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123;</span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		<span class="keyword">if</span>(!t-&gt;next[temp]) t-&gt;next[temp]=<span class="built_in">createnew</span>(); </span><br><span class="line">		t=t-&gt;next[temp];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;end=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span>* s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,temp;</span><br><span class="line">	treenode* t=&amp;head;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123;</span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		<span class="keyword">if</span>(!t-&gt;next[temp]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		t=t-&gt;next[temp];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t-&gt;end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init_charmapping</span>();</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">char</span> x[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">char</span> t;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">fflush</span>(stdin);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;x);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">search</span>(x)) <span class="built_in">printf</span>(<span class="string">&quot;匹配成功！\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;匹配失败！\n&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&#x27;u&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;x);</span><br><span class="line">			<span class="built_in">update</span>(x);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;更新完毕！\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出ing....\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无效命令！,请重新输入！\n&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-以动态分配为实现的带增删改查的字典树模版"><a href="#2-以动态分配为实现的带增删改查的字典树模版" class="headerlink" title="(2).以动态分配为实现的带增删改查的字典树模版."></a>(2).以动态分配为实现的带增删改查的字典树模版.</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个以链表实现带删除功能允许重复字符串的字典树</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> charmapping[<span class="number">256</span>]; <span class="comment">//字符映射数组,charmapping[i]=x表示ascii码为i的字符对应于treenode中的next[x] </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_charmapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123; <span class="comment">//我的这个字典树现在只允许输入小写字符组成的字符串,然而由于有charmapping的存在,增加新字符添加映射并且增大maxn就好,很方便. </span></span><br><span class="line">		charmapping[i]=i-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">26</span>; <span class="comment">//这里假设字符串中只出现26个小写字母 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treenode</span>&#123;</span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//标志此节点所表示字符串在所有字符串中以前缀形式出现的总次数 </span></span><br><span class="line">	treenode* next[maxn]; </span><br><span class="line">&#125;head;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">	head.count=<span class="number">1</span>; <span class="comment">//初始化为1包括空串并且避免树头被删 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) head.next[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">treenode* <span class="title">createnew</span><span class="params">()</span></span>&#123; <span class="comment">//申请一个新结点并初始化它</span></span><br><span class="line">	treenode* newnode;</span><br><span class="line">	newnode=(treenode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(treenode));</span><br><span class="line">	newnode-&gt;count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) newnode-&gt;next[i]=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> num)</span></span>&#123; <span class="comment">//向字典树添加num个字符串s </span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,temp;</span><br><span class="line">	treenode* t=&amp;head;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123;</span><br><span class="line">		t-&gt;count+=num;</span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		<span class="keyword">if</span>(!t-&gt;next[temp]) t-&gt;next[temp]=<span class="built_in">createnew</span>(); </span><br><span class="line">		t=t-&gt;next[temp];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;count+=num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> num)</span></span>&#123;  <span class="comment">//查找字典树中是否已经存在num个字符串s</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,temp;</span><br><span class="line">	treenode* t=&amp;head;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123;</span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		<span class="keyword">if</span>(!t-&gt;next[temp]||t-&gt;next[temp]-&gt;count&lt;num) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//根本不存在字符串s或者存在的数目小于num直接失败 </span></span><br><span class="line">		t=t-&gt;next[temp];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> snum=t-&gt;count;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) <span class="keyword">if</span>(t-&gt;next[i]) snum-=t-&gt;next[i]-&gt;count; <span class="comment">//这里是核心!!!结点t代表的字符串出现的次数就是总次数减去所有子节点次数和 </span></span><br><span class="line">	<span class="keyword">if</span>(snum&gt;=num) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果字符串s的数目snum大于等于num </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">char</span>* s,<span class="type">int</span> num)</span></span>&#123;  <span class="comment">//删除字典树中的num个字符串s并释放无用结点,删除前一定要先search是否存在 </span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,temp;</span><br><span class="line">	treenode* t=&amp;head;</span><br><span class="line">	treenode* t1; <span class="comment">//t1后面的结点都是删除后需要被释放的 </span></span><br><span class="line">	head.count-=num;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123;</span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		t-&gt;next[temp]-&gt;count-=num;</span><br><span class="line">		<span class="keyword">if</span>(t-&gt;next[temp]-&gt;count==<span class="number">0</span>)&#123;</span><br><span class="line">			t1=t-&gt;next[temp];</span><br><span class="line">			t-&gt;next[temp]=<span class="literal">NULL</span>;</span><br><span class="line">			k++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t=t-&gt;next[temp];</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(s[k])&#123; <span class="comment">//释放无用结点 </span></span><br><span class="line">		temp=charmapping[s[k]];</span><br><span class="line">		t=t1-&gt;next[temp];</span><br><span class="line">		<span class="built_in">free</span>(t1);</span><br><span class="line">		t1=t;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(t1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> temp[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printall</span><span class="params">(treenode* tnode,<span class="type">int</span> pos)</span></span>&#123; <span class="comment">//递归打印字典树咯,打出了就是字典序升序的 </span></span><br><span class="line">	<span class="type">int</span> count=tnode-&gt;count;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) <span class="keyword">if</span>(tnode-&gt;next[i]) count-=tnode-&gt;next[i]-&gt;count;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++) <span class="built_in">printf</span>(<span class="string">&quot;\&quot;%s\&quot;\n&quot;</span>,temp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tnode-&gt;next[charmapping[i]])&#123;</span><br><span class="line">			temp[pos]=i;</span><br><span class="line">			temp[++pos]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printall</span>(tnode-&gt;next[charmapping[i]],pos);</span><br><span class="line">			temp[--pos]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init_charmapping</span>(); <span class="comment">//初始化映射 </span></span><br><span class="line">	<span class="built_in">init_trie</span>();		<span class="comment">//初始化字典树 </span></span><br><span class="line">	<span class="type">char</span> x[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">char</span> order; <span class="comment">//命令 </span></span><br><span class="line">	<span class="type">int</span> num;    <span class="comment">//数目 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;q：查询\nu：插入\nd：删除\np：打印字典树\ne：退出\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入命令：&quot;</span>);</span><br><span class="line">		<span class="built_in">fflush</span>(stdin);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;order);</span><br><span class="line">		<span class="keyword">if</span>(order==<span class="string">&#x27;q&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的字符串与数目：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,&amp;x,&amp;num);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">search</span>(x,num)) <span class="built_in">printf</span>(<span class="string">&quot;匹配成功。\n\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;匹配失败，不存在%d个\&quot;%s\&quot;\n\n&quot;</span>,num,x); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="string">&#x27;u&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的字符串与数目：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,&amp;x,&amp;num);</span><br><span class="line">			<span class="built_in">update</span>(x,num);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d个\&quot;%s\&quot;已加入字典树。\n\n&quot;</span>,num,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除的字符串与数目：&quot;</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,&amp;x,&amp;num);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">search</span>(x,num))&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;树中无%d个字符串\&quot;%s\&quot;请重新键入命令！\n\n&quot;</span>,num,x);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">erase</span>(x,num);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d个\&quot;%s\&quot;已从字典树中删除。\n\n&quot;</span>,num,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="string">&#x27;p&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;当前字典树内有如下字符串：\n&quot;</span>);</span><br><span class="line">			temp[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printall</span>(&amp;head,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(order==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;退出ing....\n&quot;</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无效命令,请重新输入！\n命令q：查询是否存在字符串\n命令u：往字典树加入字符串\n命令d：删除某个字符串\n命令p：按字典序升序输出字典树\n命令e：退出程序\n\n&quot;</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一般模板"><a href="#一般模板" class="headerlink" title="一般模板"></a>一般模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000050</span>;</span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>) trie[p][x] = ++id;</span><br><span class="line">		p = trie[p][x];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">find</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (trie[p][x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p = trie[p][x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们用到了几个变量，这里分别一一解释<br>1.变量id： id代表字典树中每一个节点的编号，id的大小只与插入字典树的先后顺序有关，它的作用在下面会讲到。</p>
<p>2.trie[N][26]： 每个trie代表一条边，字典树其中1<del>N为边上方节点的编号，0代表root节点，1</del>26为连在i节点下方的26个字母。如果trie[i][x]&#x3D;0,则代表字典树中目前没有这个点，而trie[i][x]的值代表这个点下方连有的点的编号，例如：trie[i][3]&#x3D;9代表第i号点和的下方连有一个点‘c’，并且那个点的编号是9，为什么是c呢？因为 ‘c’-‘a’&#x3D;2</p>
<p>3.cnt[N]: cnt[i]&#x3D;&#x3D;0代表编号为i的点不是一个单词的结束点，在上面的图中代表这个点不是空点，但是没有标红，cnt[i]！&#x3D;0代表编号为i的点是一个单词的结束点，即红点。cnt[i]不一定只为0或1，因为有可能多次输入了同一个单词。</p>
<p>4.（难点）两个函数中的变量p:<br>p代表查询与插入时的不断变化的当前节点编号，初始化为0，代表初始节点，在函数的循环中，我们首先用x确定接下来要找的字母，再通过变量x确定了接下来我们需要查找当前节点下是否有连接着目标字母的节点。通过每次确定的x，我们通过trie[p][x] 查找连着目标字母的节点的编号，如果目标节点存在，就把p更新成目标节点的编号（p &#x3D; trie[p][x]）。而如果trie[p][x] &#x3D;&#x3D; 0，代表字典树中没有这个点，如果是查找就代表没有这个单词，查找失败。而如果是插入函数，我们就用 ++id 来把这个点存进字典树。我们在两个函数的最后用cnt[p]来涂红节点或返回节点值。</p>
<p>我们先后插入单词”abc”,“abb”,“bca”,“bc”，那编号就是这样<br><img data-src="https://img-blog.csdnimg.cn/20210718175653572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5Njg4NDc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>trie[上节点编号][下方连接的字母]&#x3D;下方连接的字母的节点编号<br>trie[0][0]&#x3D;1;trie[0][1]&#x3D;5;<br>trie[1][1]&#x3D;2;<br>trie[2][1]&#x3D;4;trie[2][2]&#x3D;3;<br>trie[5][2]&#x3D;6;<br>trie[6][0]&#x3D;7;<br>其余trie[i][j]都为0，即空节点；<br>cnt[4]&#x3D;cnt[3]&#x3D;cnt[6]&#x3D;cnt[7]&#x3D;1;</p>
<p>如果我再往字典树中插入”bcd”,字典树就更新为<br><img data-src="https://img-blog.csdnimg.cn/20210718180442206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5Njg4NDc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>新增<br>trie[6][3]&#x3D;8；cnt[8]&#x3D;1</p>
<p>让我们试着查询看看”abc”与”bb”</p>
<p><img data-src="https://img-blog.csdnimg.cn/20210718182200548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ5Njg4NDc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最后，我们查到了”abc”,但没查到”bb”</p>
<p><a href="https://cdutetcoj.xyz/training/30/problem/HDU-1251">统计难题 - CDUTETCOJ</a></p>
<p>输入数据的第一部分是一张单词表,每行一个单词,单词的长度不超过10,它们代表的是老师交给Ignatius统计的单词,一个空行代表单词表的结束.第二部分是一连串的提问,每行一个提问,每个提问都是一个字符串.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[maxn][<span class="number">26</span>];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="type">int</span> flag[maxn];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!tree[p][j]) tree[p][j]=cnt++;</span><br><span class="line">		p=tree[p][j];</span><br><span class="line">		flag[p]++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chaxun</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">		<span class="type">int</span> j=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!tree[p][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p=tree[p][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">	<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">gets</span>(s))&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">insert</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">gets</span>(s))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">chaxun</span>(s));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/30/problem/HDU-4825">Xor Sum - CDUTETCOJ</a></p>
<p>思路：</p>
<p>题目要求异或最大值：异或（简单说就是没有进位的求和位运算）</p>
<p>例如：                           3      ⊕     5</p>
<p>分别用二进制表示：   1 1          1 0 1 </p>
<p>将他们相加：        结果为（110）2&#x3D;（6）10</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190303110532734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM1MDA1MQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在输入的时候会给出一个值n让去找一个异或结果最大的值</p>
<p>根据上面介绍异或也可以看出来 要想使异或结果最大那就应该尽力去寻找与n的二进制 相反的值</p>
<p>例如5的二进制是101 那就应该寻找010即2这个数与其异或 </p>
<p>但是2未必一定是之前输入过的 所以尽可能寻找与2的二进制相似的值 比如 101 或 001 …<br>用字典树将之前输入的值的二进制存入 然后根据2中的方法寻找异或结果最大的数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">2e6</span>;</span><br><span class="line">LL n,m;</span><br><span class="line">LL a[MAX+<span class="number">5</span>],b[MAX+<span class="number">5</span>];</span><br><span class="line">LL top;</span><br><span class="line">LL tir[MAX+<span class="number">5</span>][<span class="number">2</span>],num[MAX+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(LL *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       <span class="comment">// printf(&quot;*%d &quot;,b[i]);</span></span><br><span class="line">        LL id=b[i]<span class="number">-0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tir[root][id]==<span class="number">0</span>)&#123;</span><br><span class="line">            tir[root][id]=++top;</span><br><span class="line">        &#125;</span><br><span class="line">        root=tir[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">find</span><span class="params">(LL *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL root=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="comment">//  printf(&quot;*%d &quot;,b[i]);</span></span><br><span class="line">        LL id=b[i]<span class="number">-0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tir[root][id]==<span class="number">0</span>)&#123;</span><br><span class="line">            id==<span class="number">0</span>?id=<span class="number">1</span>:id=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tir[root][id]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[i]=id;</span><br><span class="line">        root=tir[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    LL sum2=<span class="number">0</span>;</span><br><span class="line">    LL sum1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;=<span class="number">31</span>;i++)&#123;</span><br><span class="line">      <span class="comment">//  printf(&quot;*%d &quot;,num[i]);</span></span><br><span class="line">        sum2+=num[i]*sum1;</span><br><span class="line">        sum1*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> sum2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allbegin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=top+<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">            tir[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(tir,0,sizeof(tir));</span></span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(LL k=<span class="number">1</span>;k&lt;=T;k++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">allbegin</span>();</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            <span class="keyword">for</span>(LL j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                b[j]=((<span class="number">1</span>&lt;&lt;j)&amp;a[i])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insert</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%lld:\n&quot;</span>,k);</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(LL j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                LL u=((<span class="number">1</span>&lt;&lt;j)&amp;a[i])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">                    b[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    b[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            LL sum=<span class="built_in">find</span>(b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="前缀和及差分"><a href="#前缀和及差分" class="headerlink" title="前缀和及差分"></a>前缀和及差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240?ops_request_misc=%7B%22request_id%22:%22165785413716782390584371%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165785413716782390584371&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-111146240-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86&spm=1018.2226.3001.4187"> 前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_林小鹿@的博客-CSDN博客_前缀和差分</a></p>
<h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前 n 项的和”(一般从1开始)。s[i] &#x3D; s[i-1] + a[i]; sum[l, r] &#x3D; s[r] – s[l-1];</p>
<p><strong>先来了解这样一个问题：</strong></p>
<p><strong>输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。</strong></p>
<p><strong>我们很容易想出暴力解法，遍历区间求和。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">    &#123; </span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这样的时间复杂度为<code>O(n*m)</code>，如果<code>n</code>和<code>m</code>的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到<code>O(n+m)</code>,大大提高了运算效率。</strong></p>
<p>首先做一个预处理，定义一个<code>sum[]</code>数组，<code>sum[i]</code>代表<code>a</code>数组中前<code>i</code>个数的和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> sum[N],a[N]; <span class="comment">//sum[i]=a[1]+a[2]+a[3].....a[i];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123; </span><br><span class="line">    sum[i]=sum[i<span class="number">-1</span>]+a[i];   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[r]-sum[l<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>

<p>对于每次查询，只需执行<code>sum[r]-sum[l-1]</code> ，时间复杂度为<code>O(1)</code></p>
<p><strong>原理</strong></p>
<p><code>sum[r] =a[1]+a[2]+a[3]+a[l-1]+a[l]+a[l+1]......a[r]</code>;<br><code>sum[l-1]=a[1]+a[2]+a[3]+a[l-1]</code>;<br><code>sum[r]-sum[l-1]=a[l]+a[l+1]+......+a[r]</code>;</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201217171740805.png" alt="img"></p>
<p><a href="https://cdutetcoj.xyz/training/33/problem/HDU-5480">Conturbatio - CDUTETCOJ</a></p>
<p>在一个n \times mn×m的国际象棋棋盘上有很多车(Rook)，其中车可以攻击他所属的一行或一列，包括它自己所在的位置。<br>现在还有很多询问，每次询问给定一个棋盘内部的矩形，问矩形内部的所有格子是否都被车攻击到？<br>输入描述<br>输入文件包含多组数据，第一行为数据组数TT。<br>每组数据有4个正整数n , m , K , Qn,m,K,Q。<br>KK为车的数量，QQ为询问的个数。<br>接下来有KK行，每行两个整数x , yx,y ， 表示车所在的坐标。<br>再接下来有QQ行，每行4个整数x1 , y1 , x2 , y2x1,y1,x2,y2，表示询问的矩形的左下角与右上角的坐标。<br><strong>思路：记录下行攻击的前缀和及列攻击的前缀和，每个矩阵只要满足行攻击和列攻击全部攻击到就是yes.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],c[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t,x,y,x1,y1,x2,y2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;q);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			a[y]=<span class="number">1</span>;</span><br><span class="line">			c[x]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]) a[i]+=a[i<span class="number">-1</span>]; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(c[i]) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">			<span class="keyword">if</span>((x2-x1+<span class="number">1</span>)&lt;=c[x2]||(y2-y1+<span class="number">1</span>)&lt;=a[y2]) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p>先给出问题：</p>
<p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p>
<p>同一维前缀和一样，我们先来定义一个二维数组s[][], s[i][j]表示二维数组中，左上角(1,1)到右下角( i,j )所包围的矩阵元素的和。接下来推导二维前缀和的公式。</p>
<p>先看一张图：<br><img data-src="https://img-blog.csdnimg.cn/20201214201734653.png" alt="img"></p>
<p><strong>紫色面积</strong>是指<code>(1,1)</code>左上角到<code>(i,j-1)</code>右下角的矩形面积, <strong>绿色面积</strong>是指<code>(1,1)</code>左上角到<code>(i-1, j )</code>右下角的矩形面积。<strong>每一个颜色的矩形面积都代表了它所包围元素的和。</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20201216215336857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] &#x3D; 绿色面积s[i-1][j] + 紫色面积s[i][j-1] - 重复加的红色的面积s[i-1][j-1]+小方块的面积a[i][j];</p>
<p>因此得出二维前缀和预处理公式</p>
<p>s[i] [j] &#x3D; s[i-1][j] + s[i][j-1 ] + a[i] [j] - s[i-1][ j-1]</p>
<p>接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</p>
<p>如图：<br><img data-src="https://img-blog.csdnimg.cn/20201214204543274.png" alt="img"></p>
<p><strong>紫色面积</strong>是指 <code>( 1,1 )</code>左上角到<code>(x1-1,y2)</code>右下角的矩形面积 ，<strong>黄色面积</strong>是指<code>(1,1)</code>左上角到<code>(x2,y1-1)</code>右下角的矩形面积；</p>
<p><strong>不难推出：</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20201217170800381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>绿色矩形的面积 &#x3D; 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</p>
<p>因此二维前缀和的结论为：</p>
<p><strong>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</strong><br><strong>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/2020121717185394.png" alt="img"></p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p><img data-src="https://img-blog.csdnimg.cn/20201214210831512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><p>类似于数学中的求导和积分，差分可以看成前缀和的逆运算。</p>
<p>差分数组：</p>
<p>首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];</p>
<p>然后我们构造一个数组b ： b[1] ,b[2] , b[3],,,,,, b[i];</p>
<p>使得 a[i] &#x3D; b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</p>
<p>也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。</p>
<p>考虑如何构造差分b数组？</p>
<p>最为直接的方法</p>
<p>如下：</p>
<p>a[0 ]&#x3D; 0;</p>
<p>b[1] &#x3D; a[1] - a[0];</p>
<p>b[2] &#x3D; a[2] - a[1];</p>
<p>b[3] &#x3D;a [3] - a[2];</p>
<p>……..</p>
<p>b[n] &#x3D; a[n] - a[n-1];<br><img data-src="https://img-blog.csdnimg.cn/20201215214337143.png" alt="img"></p>
<p>我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到a数组 。</p>
<p><strong>知道了差分数组有什么用呢？</strong> 别着急，慢慢往下看。</p>
<p><strong>话说有这么一个问题：</strong></p>
<p>给定区间[l ,r ]，让我们把a数组中的[ l, r]区间中的每一个数都加上c,即 a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c;</p>
<p>暴力做法是for循环l到r区间，时间复杂度O(n)，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成O(n*m)。有没有更高效的做法吗? 考虑差分做法，(差分数组派上用场了)。</p>
<p><strong>始终要记得，a数组是b数组的前缀和数组</strong>，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。</p>
<p>首先让差分b数组中的 b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c;</p>
<p>然后我们打个补丁，b[r+1] - c, 通过前缀和运算，a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;</p>
<p><strong>为啥还要打个补丁？</strong></p>
<p><strong>我们画个图理解一下这个公式的由来:</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20201215163431253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>b[l] + c，效果使得a数组中 a[l]及以后的数都加上了c(红色部分)，但我们只要求l到r区间加上c, 因此还需要执行 b[r+1] - c,让a数组中a[r+1]及往后的区间再减去c(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。</p>
<p>因此我们得出一维差分结论：给a数组中的[ l, r]区间中的每一个数都加上c,只需对差分数组b做 b[l] + &#x3D; c, b[r+1] - &#x3D; c。时间复杂度为O(1), 大大提高了效率。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201217172005485.png" alt="在这里插入图片描述"></p>
<p><strong>题目练习：</strong></p>
<p><strong>输入一个长度为n的整数序列。</strong><br><strong>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。</strong><br><strong>请你输出进行完所有操作后的序列。</strong><br><strong>输入格式</strong><br><strong>第一行包含两个整数n和m。</strong><br><strong>第二行包含n个整数，表示整数序列。</strong><br><strong>接下来m行，每行包含三个整数l，r，c，表示一个操作。</strong><br><strong>输出格式</strong><br><strong>共一行，包含n个整数，表示最终序列。</strong><br><strong>数据范围</strong><br><strong>1≤n,m≤100000,</strong><br><strong>1≤l≤r≤n,</strong><br><strong>−1000≤c≤1000,</strong><br><strong>−1000≤整数序列中元素的值≤1000</strong><br><strong>输入样例：</strong><br><strong>6 3</strong><br><strong>1 2 2 1 2 1</strong><br><strong>1 3 1</strong><br><strong>3 5 1</strong><br><strong>1 6 1</strong><br><strong>输出样例：</strong><br><strong>3 4 5 3 4 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分 时间复杂度 o(m)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=a[i]-a[i<span class="number">-1</span>];      <span class="comment">//构建差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l,r,c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        b[l]+=c;     <span class="comment">//表示将序列中[l, r]之间的每个数加上c</span></span><br><span class="line">        b[r+<span class="number">1</span>]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        b[i]+=b[i<span class="number">-1</span>];  <span class="comment">//求前缀和运算</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>———————————————</p>
<h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p>如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。</p>
<p>a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组</p>
<p>原数组： a[i][j]</p>
<p>我们去构造差分数组： b[i][j]</p>
<p>使得a数组中a[i][j]是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。</p>
<p>如何构造b数组呢？</p>
<p>其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。</p>
<p>同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由O(n*n)的时间复杂度优化成O(1)</p>
<p>已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;</p>
<p>始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。</p>
<p>假定我们已经构造好了b数组，类比一维差分，我们执行以下操作<br>来使被选中的子矩阵中的每个元素的值加上c</p>
<p><strong>b[x1][y1] + &#x3D; c;</strong></p>
<p><strong>b[x1,][y2+1] - &#x3D; c;</strong></p>
<p><strong>b[x2+1][y1] - &#x3D; c;</strong></p>
<p><strong>b[x2+1][y2+1] + &#x3D; c;</strong></p>
<p>每次对b数组执行以上操作，等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x1;i&lt;=x2;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=y1;j&lt;=y2;j++)</span><br><span class="line">    a[i][j]+=c;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20201217171134926.png" alt="img"></p>
<p><strong>b[x1][ y1 ] +&#x3D;c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。</strong><br><strong>b[x1,][y2+1]-&#x3D;c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。</strong><br><strong>b[x2+1][y1]- &#x3D;c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。</strong><br><strong>b[x2+1][y2+1]+&#x3D;c; 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。</strong><br><img data-src="https://img-blog.csdnimg.cn/20201217170336254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>我们将上述操作封装成一个插入函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">//对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c</span></span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c&#x3D;a[i][j]，等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行n*m次插入操作，就成功构建了差分b数组.<br><strong>这叫做曲线救国。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(i,j,i,j,a[i][j]);    <span class="comment">//构建差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然关于二维差分操作也有直接的构造方法，<strong>公式如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b[i][j]=a[i][j]−a[i−<span class="number">1</span>][j]−a[i][j−<span class="number">1</span>]+a[i−<span class="number">1</span>][j−<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/20201217172035975.png" alt="在这里插入图片描述"></p>
<p><strong>题目练习： AcWing 798. 差分矩阵</strong><br><strong>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。</strong><br><strong>每个操作都要将选中的子矩阵中的每个元素的值加上c。</strong><br><strong>请你将进行完所有操作后的矩阵输出。</strong><br><strong>输入格式</strong><br><strong>第一行包含整数n,m,q。</strong><br><strong>接下来n行，每行包含m个整数，表示整数矩阵。</strong><br><strong>接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。</strong><br><strong>输出格式</strong><br><strong>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</strong><br><strong>数据范围</strong><br><strong>1≤n,m≤1000,</strong><br><strong>1≤q≤100000,</strong><br><strong>1≤x1≤x2≤n,</strong><br><strong>1≤y1≤y2≤m,</strong><br><strong>−1000≤c≤1000,</strong><br><strong>−1000≤矩阵内元素的值≤1000</strong><br><strong>输入样例：</strong><br><strong>3 4 3</strong><br><strong>1 2 2 1</strong><br><strong>3 2 2 1</strong><br><strong>1 1 1 1</strong><br><strong>1 1 2 2 1</strong><br><strong>1 3 2 3 2</strong><br><strong>3 1 3 4 1</strong><br><strong>输出样例：</strong><br><strong>2 3 4 1</strong><br><strong>4 3 4 1</strong><br><strong>2 2 2 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,q;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    cin&gt;&gt;a[i][j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">insert</span>(i,j,i,j,a[i][j]);    <span class="comment">//构建差分数组</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(q--)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">      cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">      <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/33/problem/CF-296C">Greg and Array - CDUTETCOJ</a></p>
<p>题意<br>Greg有一个数组a &#x3D; a1, a2, …, an和m个操作。每个操作看起来像：li，ri，di，（1≤li≤ri≤n）。对数组应用操<br>作i意味着用数值di增加所有数组元素li、li+1、…、ri。<br>Greg在一张纸上写下了k个查询。每个查询有以下形式：xi, yi, (1 ≤ xi ≤ yi ≤ m)。这意味着应该对数组应用数字<br>xi, xi + 1, …, yi的操作。<br>现在格雷格想知道，在所有的查询执行完毕后，数组a会是什么样子。请帮助Greg。<br>输入描述<br>第一行包含整数n，m，k（1≤n，m，k≤105）。第二行包含n个整数：a1, a2, …, an (0 ≤ ai ≤ 105) -初始数<br>组。<br>接下来的m行包含操作，操作数i写成三个整数：li，ri，di，（1≤li≤ri≤n），（0≤di≤105）。<br>接下来的k行包含查询，查询编号i被写成两个整数：xi, yi, (1 ≤ xi ≤ yi ≤ m)。<br>各行中的数字用单个空格隔开。<br>输出描述<br>在一行中打印n个整数a1, a2, …, an - 执行所有查询后的数组。用空格隔开打印的数字。<br>请不要在C++中使用%lld指定符读取或写入64位整数。最好使用%lld指定器的cin, cout流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> L, R;</span><br><span class="line">  LL d;</span><br><span class="line">&#125; opt[N];</span><br><span class="line">LL t[N]; <span class="comment">// t[i]:表示[i,n]操作都做一遍</span></span><br><span class="line">LL t2[N];  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]); <span class="comment">//初始数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;opt[i].L, &amp;opt[i].R, &amp;opt[i].d); <span class="comment">// m个操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y); <span class="comment">//从x做到y</span></span><br><span class="line">    t[x]++; <span class="comment">//用差分存放操作的次数</span></span><br><span class="line">    t[y + <span class="number">1</span>]--;</span><br><span class="line"> &#125;</span><br><span class="line">  LL sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    sum += t[i]; <span class="comment">//求前缀和，累计每个操作的次数</span></span><br><span class="line">    opt[i].d *= sum; <span class="comment">//修改的值乘以操作次数</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    t2[opt[i].L] += opt[i].d; <span class="comment">//累计从当前位置到末尾加的值</span></span><br><span class="line">    t2[opt[i].R + <span class="number">1</span>] -= opt[i].d; <span class="comment">//差分存值</span></span><br><span class="line"> &#125;</span><br><span class="line">  LL cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">    cnt += t2[i]; <span class="comment">//求前缀和将差分还原回去</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i] + cnt);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="邻接表存图"><a href="#邻接表存图" class="headerlink" title="邻接表存图"></a>邻接表存图</h3><p>邻接矩阵里面,e[a] [b]就表示从点A到点B有一条距离为一的边（两点确定一条边），那么邻接表也是大同小异，我们需要一个结构体数组作为边表，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,next;</span><br><span class="line">&#125;e[maxm];</span><br></pre></td></tr></table></figure>

<p>其中，u表示从点u出发，v表示点u到达的点。读入的时候可以直接存储e[i].u，e[i].v，就代表在表e的第i个位置存了可以从点u到点v的边，当然你如果想表示距离的话，不介意再加入一个<a href="https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020">结构体</a>成员dis，到时候多存一个e[i].dis就好了。</p>
<p>创建一个一维数组叫head，建立一个指针js，js初始化为0。</p>
<p>首先，每一个点都有自己的出边，那么我们的邻接表就是拿来统计每一个点的出边的。但是一个点有很多出边对吧，所以我们使用链表来储存每一个点的所有出边。这个时候，你之前创建的结构体成员next就派上了用场，next的用途就是指向这个点的上一条出边。额…会有点点难理解，我在第一次学习的时候就是这样。要不我通过它存一条边的流程来解释吧：<br>一开始存边的时候，假设我们存点6的第一条出边（什么叫第一条呢？我们在读取你输入的数据的时候会有先后，第一个读入的边习惯称作第一条），那么我们就命令head[6]的内容指向e中的一个位置，我们假设是在e[8]里面，在这个e[8]里面自然就存在三个成员：u,v,next吧。那么出发点——显然是u这个成员，也就是点6，那就赋值为6，到那个点呢？假设我们输入的是7，那v就是7了吧。但是next有什么用？大家想想，倘若点6还有出边，怎么办？我们要把next指向点6的上一条出边在e中存储的位置，这样就可以根据这一条找回上一条了嘛，假设是e[9]，还是像刚刚一样把出发点（点6），终点，都填进去。倘若点6没有出边了呢？那就让最后一个点的next为零就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	e[++js].u=u;</span><br><span class="line">	e[js].v=v;</span><br><span class="line">	e[js].next=head[u];</span><br><span class="line">	head[u]=js;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们输入数据如下：</p>
<ul>
<li>5 7</li>
<li>1 2</li>
<li>1 4</li>
<li>1 5</li>
<li>2 3</li>
<li>3 5</li>
<li>4 1</li>
<li>5 2<br>其实就是这幅图：</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20190712142947681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcnRpc3Vt,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后我们初始化都是0。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190712143229236.png" alt="在这里插入图片描述"></p>
<p>第一行5和7不是点，表示总点数和边数。接下来才是点。<br>按照输入的数据，第一条边是1,2。所以我们执行 e[++js].u&#x3D;u; 语句和 e[js].v&#x3D;v; 语句。接着执行e[js].next&#x3D;head[u];语句，就是把点1的第一条出边的位置指向e[js]的next，此时next成员等于0，就是head[1]&#x3D;e[1].next。然后执行head[u]&#x3D;js;即head[1]&#x3D;1得到如下结果：<br><img data-src="https://img-blog.csdnimg.cn/20190712144100258.png" alt="在这里插入图片描述"></p>
<p>按照输入的数据，第二条边是1,4。所以我们执行 e[++js].u&#x3D;u; 语句和 e[js].v&#x3D;v; 语句。接着执行e[js].next&#x3D;head[u];语句，就是把点1的第二条出边的位置指向e[2]的next，此时next成员等于1，然后执行head[u]&#x3D;js;这你可以把它想象成一个纠正的过程，原本的e[1].next我们不动，我们反而把head的指向内容给改了，改成了2。因为js一直在变，而我们则是把head[u]&#x3D;js;所以我们的head[u]一直都紧紧跟着最后一条出边。而最后一条出边可以根据next一步一步找到第一条！我们之所以先不用js更新head[u]是因为我们要让新加入的边的next指向上一条边，然后再用js更新head[u]，使head[u]指向当前的边。存入第二条边<br><img data-src="C:\Users\QQQ\Desktop\21计科王聪\20190712145307781.png" alt="在这里插入图片描述"></p>
<p>按照这个路子，我们把点一的所有出边都统计完</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190712145549636.png" alt="在这里插入图片描述"></p>
<p>接下来开始存点二的，js++照例，e[++js].u&#x3D;u; 语句和 e[js].v&#x3D;v; 语句也是一如既往地执行，然而head[u]的u就不是1了（废话），当执行e[js].next&#x3D;head[u];的时候，其实就是把e[4].next&#x3D;head[2]，而head[2]等于0。这样，我们等于又建立了一个新的链表关系，再点2上面添加边，而与点1的没有任何关系了<br><img data-src="https://img-blog.csdnimg.cn/20190712150506163.png" alt="在这里插入图片描述"></p>
<p>仔细观察，你会发现需要寻找一个点的所有出边的时候，只要根据head就可以回溯到该点的所有出边，而这就是邻接表了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="built_in">addedge</span>(a,b);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>数组模拟链表：开三个一维数组和一个初始值为0的变量 e[i] ne[j] h[k] idx&#x3D;0;<br>具体关系：若顶点为 k 则与其相连的另一顶点为 e[h[k]],那么想要以e[h[k]]为顶点继续向下找相邻的顶点，需判断ne[h[k]]是否为-1 若为-1 则不存在相邻点，若存在则继续向下遍历,结合代码可以更加直观理解存储方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;u&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=e[i];</span><br><span class="line">        <span class="keyword">if</span>(j!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a> 存储图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;u&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[u][i]!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(h[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        h[a].<span class="built_in">push_back</span>(&#123;b&#125;);</span><br><span class="line">        h[b].<span class="built_in">push_back</span>(&#123;a&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/34/problem/HDU-4857">逃生 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">30005</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> indegree[maxx];</span><br><span class="line"><span class="type">int</span> a[maxx];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans[maxx];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="built_in">sizeof</span>(indegree));</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			ans[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			ans[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">			indegree[x]++;</span><br><span class="line">		&#125;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> u=Q.<span class="built_in">top</span>();</span><br><span class="line">			Q.<span class="built_in">pop</span>();</span><br><span class="line">			a[++k]=u;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">				<span class="type">int</span> t=ans[u][i];</span><br><span class="line">					indegree[t]--;</span><br><span class="line">					<span class="keyword">if</span>(indegree[t]==<span class="number">0</span>)&#123;</span><br><span class="line">						Q.<span class="built_in">push</span>(t);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">			cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;a[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="邻接矩阵存图"><a href="#邻接矩阵存图" class="headerlink" title="邻接矩阵存图"></a>邻接矩阵存图</h3><p>通过二维数组下标以及二维数组</p>
<p>完成了对图的存储，对于图的第i条边，我们输入这条边的起点（s)，这条边</p>
<p>的终点(e)，这条边的权值(d)。通过二位数组可以存储。</p>
<p>如果是有向图： g[s][e]&#x3D;d;</p>
<p>如果是无向图： g[s][e]&#x3D;g[e][s]&#x3D;d;</p>
<p>在存储后如果二维数组的某个下标代表的数等于0，那么证明从i到j没有边，反之</p>
<p>则证明从i到j有边，边的长度就是二维数组的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[<span class="number">2333</span>][<span class="number">2333</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s,e,d;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;e&gt;&gt;d;</span><br><span class="line">        g[s][e]=g[e][s]=d;<span class="comment">//无向图 </span></span><br><span class="line">        <span class="comment">//g[s][e]=d;//有向图 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其邻接矩阵如下：无向图的邻接矩阵关于主对角线对称</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190323002015393.png" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> edgeNum;		<span class="comment">//边数</span></span><br><span class="line">	<span class="type">int</span> vetexNum;		<span class="comment">//顶点数</span></span><br><span class="line">	<span class="type">int</span> G[maxn][maxn]; 	<span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;*pGraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> end;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line">&#125;*pEdge;</span><br><span class="line"></span><br><span class="line"><span class="function">pGraph <span class="title">InitGraph</span><span class="params">(<span class="type">int</span> vetexNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pGraph Graph;</span><br><span class="line">	Graph = (pGraph)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(GNode));</span><br><span class="line">	Graph-&gt;vetexNum = vetexNum;</span><br><span class="line">	Graph-&gt;edgeNum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//编号是从0到vetexNum-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Graph-&gt;vetexNum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; Graph-&gt;vetexNum; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Graph-&gt;G[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertEdge</span><span class="params">(pGraph Graph,pEdge E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Graph-&gt;G[E-&gt;start][E-&gt;end] = E-&gt;weight;</span><br><span class="line">	<span class="comment">//无向图需要加一条反向边</span></span><br><span class="line">	Graph-&gt;G[E-&gt;end][E-&gt;start] = E-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pGraph <span class="title">CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pGraph Graph;</span><br><span class="line">	pEdge	E;</span><br><span class="line">	<span class="type">int</span> 	nv; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input VetexNum:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nv);</span><br><span class="line">	Graph = <span class="built_in">InitGraph</span>(nv);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input EdgeNum:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(Graph-&gt;edgeNum));</span><br><span class="line">	<span class="keyword">if</span>(Graph-&gt;edgeNum != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		E  = (pEdge)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ENode));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please input start,end,weight:\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Graph-&gt;edgeNum; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;start,&amp;E-&gt;end,&amp;E-&gt;weight);	<span class="comment">//无向图默认是1</span></span><br><span class="line">			<span class="built_in">InsertEdge</span>(Graph,E);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(pGraph Graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;matrix:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Graph-&gt;edgeNum; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; Graph-&gt;edgeNum; ++j)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Graph-&gt;G[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pGraph Graph;</span><br><span class="line">	Graph = <span class="built_in">CreateGraph</span>();</span><br><span class="line">	<span class="built_in">Print</span>(Graph);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">0 1 1</span></span><br><span class="line"><span class="comment">0 2 1</span></span><br><span class="line"><span class="comment">0 3 1</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">1 4 1</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	//简易版</span></span><br><span class="line"><span class="comment">	void Build()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		scanf(&quot;%d&quot;,&amp;vetexnum);</span></span><br><span class="line"><span class="comment">		for(int i = 0; i &lt; vertexnum; ++i)</span></span><br><span class="line"><span class="comment">			for(int j = 0; j &lt; vertexnum; ++j)</span></span><br><span class="line"><span class="comment">				Graph[i][j] = 0;</span></span><br><span class="line"><span class="comment">		scanf(&quot;%d&quot;,&amp;edgenum);</span></span><br><span class="line"><span class="comment">		for(int i = 0; i &lt; edgenum; ++i)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			scanf(&quot;%d%d%d&quot;,&amp;start, &amp;end, &amp;weight);</span></span><br><span class="line"><span class="comment">			Graph[start][end] = weight;</span></span><br><span class="line"><span class="comment">			Graph[end][start] = weight;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/34/problem/HDU-1285">确定比赛名次 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> g[maxn][maxn],res[maxn],in[maxn];<span class="comment">//g为邻接矩阵，res记录最后结果，in记录入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;<span class="comment">//从小到大</span></span><br><span class="line">			<span class="keyword">if</span>(in[j]==<span class="number">0</span>)&#123;</span><br><span class="line">				res[i]=j;<span class="comment">//记录已经处理的点</span></span><br><span class="line">				in[j]--;<span class="comment">//删除结点，将入度为0的点的入度置为-1</span></span><br><span class="line">				k=j;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[k][j]==<span class="number">1</span>)&#123;</span><br><span class="line">				g[k][j]=<span class="number">0</span>;<span class="comment">//删除相关的边</span></span><br><span class="line">				in[j]--;<span class="comment">//入度-1；</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">		<span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="built_in">sizeof</span>(in));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			<span class="keyword">if</span>(g[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">				g[x][y]=<span class="number">1</span>;</span><br><span class="line">				in[y]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">topsort</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;n) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout&lt;&lt;res[n]&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a><strong>链式前向星</strong></h3><p><strong>链式前向星其实就是静态建立的邻接表，时间效率为O（m），空间效率也为O（m）。遍历效率也为O（m）。</strong></p>
<p><strong>对于下面的数据，第一行5个顶点，7条边。接下来是****边的起点，终点和权值。也就是边1 -&gt; 2 权值为</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p> <strong>链式前向星存的是以【1，n】为起点的边的集合，对于上面的数据输出就是：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//以1为起点的边的集合</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span> <span class="comment">//以2为起点的边的集合</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span> <span class="comment">//以3为起点的边的集合</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>  <span class="comment">//以4为起点的边的集合</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span> <span class="comment">//以5为起点的边不存在</span></span><br></pre></td></tr></table></figure>

<p>我们先对上面的7条边进行编号第一条边是0以此类推编号【0~6】，然后我们要知道两个变量的含义：</p>
<p>Next，表示与这个边起点相同的上一条边的编号。<br>head[ i ]数组，表示以 i 为起点的最后一条边的编号。<br> head数组一般初始化为-1，为什么是 -1后面会讲到。加边函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只要知道next，head数组表示的含义，根据上面的数据就可以写出下面的过程：</p>
<p>对于1 2 1这条边：edge[0].to &#x3D; 2;     edge[0].next &#x3D; -1;      head[1] &#x3D; 0;</p>
<p>对于2 3 2这条边：edge[1].to &#x3D; 3;     edge[1].next &#x3D; -1;      head[2] &#x3D; 1;</p>
<p>对于3 4 3这条边：edge[2].to &#x3D; 4;     edge[2],next &#x3D; -1;      head[3] &#x3D; 2;</p>
<p>对于1 3 4这条边：edge[3].to &#x3D; 3;     edge[3].next &#x3D; 0;       head[1] &#x3D; 3;</p>
<p>对于4 1 5这条边：edge[4].to &#x3D; 1;     edge[4].next &#x3D; -1;      head[4] &#x3D; 4;</p>
<p>对于1 5 6这条边：edge[5].to &#x3D; 5;     edge[5].next &#x3D; 3;       head[1] &#x3D; 5;</p>
<p>对于4 5 7这条边：edge[6].to &#x3D; 5;     edge[6].next &#x3D; 4;       head[4] &#x3D; 6;</p>
<p>遍历函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一层for循环是找每一个点，依次遍历以【1，n】为起点的边的集合。第二层for循环是遍历以 i 为起点的所有边，k首先等于head[ i ]，注意head[ i ]中存的是以 i 为起点的最后一条边的编号。然后通过edge[ j ].next来找下一条边的编号。我们初始化head为-1，所以找到你最后一个边（也就是以 i 为起点的第一条边）时，你的edge[ j ].next为 -1做为终止条件。</p>
<p>具体代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1005</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="type">int</span> n, m, cnt;<span class="comment">//n个点，m条边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, w, next;<span class="comment">//终点，边权，同起点的上一条边的编号</span></span><br><span class="line">&#125;edge[maxn];<span class="comment">//边集</span></span><br><span class="line"><span class="type">int</span> head[maxn];<span class="comment">//head[i],表示以i为起点的第一条边在边集数组的位置（编号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) head[i] = <span class="number">-1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//输入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w);<span class="comment">//加边</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        加双向边</span></span><br><span class="line"><span class="comment">        add_edge(u, v, w);</span></span><br><span class="line"><span class="comment">        add_edge(v, u, w);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 3 2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">4 1 5</span></span><br><span class="line"><span class="comment">1 5 6</span></span><br><span class="line"><span class="comment">4 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/34/problem/HDU-2647">Reward - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10002 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,next,val;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> degree[MAXN],vis[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> edgeNum,n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	edgeNum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(degree,<span class="number">0</span>,<span class="built_in">sizeof</span>(degree));</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	Edge e = &#123;v,head[u],w&#125;;</span><br><span class="line">	edge[edgeNum]=e;</span><br><span class="line">	head[u]=edgeNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="type">int</span> a,b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">			<span class="built_in">addEdge</span>(b,a,i);<span class="comment">//反向边 </span></span><br><span class="line">			degree[a]++;<span class="comment">//入度为0 </span></span><br><span class="line">		&#125;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">		<span class="type">int</span> ans[MAXN];</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(degree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(i);</span><br><span class="line">				ans[i]=<span class="number">888</span>;	</span><br><span class="line">				sum++;</span><br><span class="line">				vis[i]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">				<span class="type">int</span> v=edge[i].to;</span><br><span class="line">				degree[v]--;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(degree[v]==<span class="number">0</span>&amp;&amp;!vis[v])&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>;</span><br><span class="line">					sum++;</span><br><span class="line">					ans[v]=ans[u]+<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">			<span class="type">int</span> tol=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			tol+=ans[i];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tol);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Tarjan缩点"><a href="#Tarjan缩点" class="headerlink" title="Tarjan缩点"></a>Tarjan缩点</h2><p><a href="https://zhuanlan.zhihu.com/p/101923309">60 分钟搞定图论中的 Tarjan 算法（一） - 知乎 (zhihu.com)</a></p>
<h3 id="一、Tarjan-算法"><a href="#一、Tarjan-算法" class="headerlink" title="一、Tarjan 算法"></a><strong>一、Tarjan 算法</strong></h3><p>Tarjan 算法是基于**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Depth-first_search">深度优先搜索</a>**的算法，用于求解图的连通性问题。Tarjan 算法可以在线性时间内求出无向图的割点与桥，进一步地可以求解无向图的双连通分量；同时，也可以求解有向图的强连通分量、必经点与必经边。</p>
<p>如果你对上面的一些术语不是很了解，没关系，我们只要知道 <strong>Tarjan 算法是基于深度优先搜索的，用于求解图的连通性问题的算法</strong> 就好了。</p>
<p>提到 Tarjan，不得不提的就是算法的作者 ——**<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BE%85%E4%BC%AF%E7%89%B9%C2%B7%E5%A1%94%E6%8F%9A">Robert Tarjan</a><strong>。他是一名著名的计算机科学家，我们耳熟能详的 <strong>最近公共祖先（LCA）</strong>问题、</strong>强连通分量** 问题、<strong>双连通分量</strong> 问题的高效算法都是由他发现并解决的，同时他还参与了开发<strong>斐波那契堆</strong>、<strong>伸展树</strong> 的工作。</p>
<h3 id="二、无向图的割点与桥"><a href="#二、无向图的割点与桥" class="headerlink" title="二、无向图的割点与桥"></a><strong>二、无向图的割点与桥</strong></h3><p>什么是无向图？简单来说，若一个图中每条边都是无方向的，则称为无向图。</p>
<p><strong>割点</strong></p>
<p>若从图中删除节点 x 以及所有与 x 关联的边之后，图将被分成两个或两个以上的不相连的子图，那么称 x 为图的<strong>割点</strong>。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-b06934dc0dccf224a8575007535ba72c_720w.jpg" alt="img"></p>
<p><strong>桥</strong></p>
<p>若从图中删除边 e 之后，图将分裂成两个不相连的子图，那么称 e 为图的<strong>桥</strong>或<strong>割边</strong>。</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-69d14f7ee63e2eb2f913331fcb639206_720w.jpg" alt="img"></p>
<p>在了解了 Tarjan 算法的背景以及图的割点与桥的基本概念之后，我们下面所面临的问题就是 —— 如何求解图的割点与桥？</p>
<p>开门见山，我们直接引出 Tarjan 算法在求解无向图的割点与桥的工作原理。</p>
<p><strong>时间戳</strong></p>
<p>时间戳是用来标记图中每个节点在进行深度优先搜索时被访问的时间顺序，当然，你可以理解成一个序号（这个序号由小到大），用 dfn[x] 来表示。</p>
<p><strong>搜索树</strong></p>
<p>在无向图中，我们以某一个节点 x 出发进行深度优先搜索，每一个节点只访问一次，所有被访问过的节点与边构成一棵树，我们可以称之为“无向连通图的搜索树”。</p>
<p><strong>追溯值</strong></p>
<p>追溯值用来表示从当前节点 x 作为搜索树的根节点出发，能够访问到的所有节点中，时间戳最小的值 —— low[x]。那么，我们要限定下什么是“能够访问到的所有节点”？，其需要满足下面的条件之一即可：</p>
<ul>
<li>以 x 为根的搜索树的所有节点</li>
<li>通过一条非搜索树上的边，能够到达搜索树的所有节点</li>
</ul>
<p>为了方便理解，让我们通过动画的方式来模拟追溯值真实计算过程。</p>
<p>在了解了 Tarjan 算法的背景以及图的割点与桥的基本概念之后，我们下面所面临的问题就是 —— 如何求解图的割点与桥？</p>
<p>开门见山，我们直接引出 Tarjan 算法在求解无向图的割点与桥的工作原理。</p>
<p><strong>时间戳</strong></p>
<p>时间戳是用来标记图中每个节点在进行深度优先搜索时被访问的时间顺序，当然，你可以理解成一个序号（这个序号由小到大），用 dfn[x] 来表示。</p>
<p><strong>搜索树</strong></p>
<p>在无向图中，我们以某一个节点 x 出发进行深度优先搜索，每一个节点只访问一次，所有被访问过的节点与边构成一棵树，我们可以称之为“无向连通图的搜索树”。</p>
<p><strong>追溯值</strong></p>
<p>追溯值用来表示从当前节点 x 作为搜索树的根节点出发，能够访问到的所有节点中，时间戳最小的值 —— low[x]。那么，我们要限定下什么是“能够访问到的所有节点”？，其需要满足下面的条件之一即可：</p>
<ul>
<li>以 x 为根的搜索树的所有节点</li>
<li>通过一条非搜索树上的边，能够到达搜索树的所有节点</li>
</ul>
<h3 id="三、如何求解图的割点与桥？"><a href="#三、如何求解图的割点与桥？" class="headerlink" title="三、如何求解图的割点与桥？"></a><strong>三、如何求解图的割点与桥？</strong></h3><p>在了解了 Tarjan 算法的背景以及图的割点与桥的基本概念之后，我们下面所面临的问题就是 —— 如何求解图的割点与桥？</p>
<p>开门见山，我们直接引出 Tarjan 算法在求解无向图的割点与桥的工作原理。</p>
<p><strong>时间戳</strong></p>
<p>时间戳是用来标记图中每个节点在进行深度优先搜索时被访问的时间顺序，当然，你可以理解成一个序号（这个序号由小到大），用 dfn[x] 来表示。</p>
<p><strong>搜索树</strong></p>
<p>在无向图中，我们以某一个节点 x 出发进行深度优先搜索，每一个节点只访问一次，所有被访问过的节点与边构成一棵树，我们可以称之为“无向连通图的搜索树”。</p>
<p><strong>追溯值</strong></p>
<p>追溯值用来表示从当前节点 x 作为搜索树的根节点出发，能够访问到的所有节点中，时间戳最小的值 —— low[x]。那么，我们要限定下什么是“能够访问到的所有节点”？，其需要满足下面的条件之一即可：</p>
<ul>
<li>以 x 为根的搜索树的所有节点</li>
<li>通过一条非搜索树上的边，能够到达搜索树的所有节点</li>
</ul>
<p>为了方便理解，让我们通过动画的方式来模拟追溯值真实计算过程。</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-ce4d0ca6dc69f214eeac3027f4a0d034_720w.jpg" alt="img"></p>
<h3 id="四、代码详解"><a href="#四、代码详解" class="headerlink" title="四、代码详解"></a><strong>四、代码详解</strong></h3><p>在了解了 Tarjan 算法的基本概念与操作流程之后，我们来看看具体的代码。这里推荐大家学习一篇 GitHub 上介绍 <strong><a href="https://link.zhihu.com/?target=https://github.com/lydrainbowcat/tedukuri/blob/master/%E9%85%8D%E5%A5%97%E5%85%89%E7%9B%98/%E6%AD%A3%E6%96%87%E5%8C%85%E5%90%AB%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5/0x66%20tarjan_dcc_euler.cpp">Tarjan 算法</a></strong> 的文章（来自<a href="https://link.zhihu.com/?target=https://github.com/lydrainbowcat/tedukuri/blob/master/%E9%85%8D%E5%A5%97%E5%85%89%E7%9B%98/%E6%AD%A3%E6%96%87%E5%8C%85%E5%90%AB%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5/0x66%20tarjan_dcc_euler.cpp">李煜东</a>的《算法竞赛进阶指南》）。</p>
<p><strong>无向图的桥判定法则</strong></p>
<p>在一张无向图中，判断边 e （其对应的两个节点分别为 u 与 v）是否为桥，需要其满足如下条件即可：dfn[u] &lt; low[v]</p>
<p>它代表的是节点 u 被访问的时间，要优先于（小于）以下这些节点被访问的时间 —— low[v] 。</p>
<ul>
<li>以节点 v 为根的搜索树中的所有节点</li>
<li>通过一条非搜索树上的边，能够到达搜索树的所有节点（在追溯值内容中有所解释）</li>
</ul>
<p>是不是上面的两个条件很眼熟？对，其实就是前文提到的追溯值 —— low[v]。</p>
<p><strong>C++ 实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tarjan 算法求无向图的桥</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">​</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head[SIZE], ver[SIZE * <span class="number">2</span>], Next[SIZE * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dfn[SIZE], low[SIZE];</span><br><span class="line"><span class="type">int</span> n, m, tot, num;</span><br><span class="line"><span class="type">bool</span> bridge[SIZE * <span class="number">2</span>];</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, Next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y, i);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt; dfn[x])</span><br><span class="line">                bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>))</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [[0,1],[1,2],[2,0],[1,3]]</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; tot; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (bridge[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ver[i ^ <span class="number">1</span>], ver[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先，我们来看看变量的含义。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head[SIZE], ver[SIZE * <span class="number">2</span>], Next[SIZE * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dfn[SIZE], low[SIZE];</span><br><span class="line"><span class="type">int</span> n, m, tot, num;</span><br><span class="line"><span class="type">bool</span> bridge[SIZE * <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>SIZE —— 节点的个数，可以基于实际的节点个数增加一些冗余度</li>
<li>关于 head &#x2F; Next &#x2F; ver 变量的介绍，可以参阅下面的动画配合理解</li>
<li>假设场景，有一个节点 u，以及其直接相连的若干节点 v1，v2，v3</li>
<li>head[u] 代表节点 u 直接相邻的第一个节点 v1 的序号（tot1）</li>
<li>Next[tot1] 代表节点 u 直接相邻的下一个节点的序号（tot2）</li>
<li>ver[tot1] 代表序号为 tot1 的节点的值（v1）</li>
<li>dfn[x] 代表节点 x 对应的时间戳，low[x] 代表节点 x 的追溯值</li>
<li>n 与 m 代表程序的标准输入的参数，n 代表节点的个数，m 代表边的个数</li>
<li>tot 代表每一个节点的序号</li>
<li>num 代表每一个节点的时间戳</li>
<li>bridge[tot] 代表序号为 tot 的边是否为桥</li>
</ul>
<p>针对于 head、Next、ver 变量的关系还是比较难懂。那么，我们用图像的方式，把节点 u、v1、v2 与 v3 画出来看看。</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-39df4ef2be0b2a3442d1f93fc3efa97f_720w.jpg" alt="img"></p>
<p>通过上图我们可以形象地理解这三个变量之间的关系。那么，针对于 add 方法，想必也可以很顺利地想明白 —— 建立并维护节点 x、y 形成的边。</p>
<p>接着，我们看看 Tarjan 算法的主体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 代表当前搜索树的根节点，in_edge 代表其对应的序号（tot）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> in_edge)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在搜索之前，先初始化节点 x 的时间戳与追溯值</span></span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    <span class="comment">// 通过 head 变量获取节点 x 的直接连接的第一个相邻节点的序号</span></span><br><span class="line">    <span class="comment">// 通过 Next 变量，迭代获取剩下的与节点 x 直接连接的节点的序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = Next[i]) &#123;</span><br><span class="line">        <span class="comment">// 此时，i 代表节点 y 的序号</span></span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        <span class="comment">// 如果当前节点 y 没有被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="comment">// 递归搜索以 y 为跟的子树</span></span><br><span class="line">            <span class="built_in">tarjan</span>(y, i);</span><br><span class="line">            <span class="comment">// 计算 x 的追溯值</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="comment">// 桥的判定法则</span></span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt; dfn[x])</span><br><span class="line">                bridge[i] = bridge[i ^ <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 标记当前节点是否为桥（具体见下文）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != (in_edge ^ <span class="number">1</span>)) <span class="comment">// 当前节点被访问过，且 y 不是 x 的“父节点”（具体见下文）</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、语句详解"><a href="#五、语句详解" class="headerlink" title="五、语句详解"></a><strong>五、语句详解</strong></h3><p><strong>语句一：i !&#x3D; (in_edge ^ 1)</strong></p>
<p>首先，我们先明确下“y 不是 x 的父节点”的情况是什么？</p>
<p>以 x’ 节点出发进行深度优先搜索，紧接着搜索到节点 x。此时，以 x 为根进行递归搜索，计算出其下一个节点为 y。如果此时 y 与 x’ 是一个节点的话 —— y 是 x 的“父节点”，需要忽略这种情况对于追溯值的计算。</p>
<p>我们知道，在建立边的关系时（add），我们为每一条边的两个节点创建了两个相邻的序号值。又因我们 tot 是从 2 开始计数的，故每一条边的两个节点的序号肯定是<strong>一奇一偶</strong>，<strong>偶数为小</strong>。比如，2 与 3，4 与 5，而不会出现 5 与 6 这样的情况。</p>
<p>在明确了上面的情况之后，我们看看一个数 x 与 1 进行异或的结果是什么？</p>
<ul>
<li>如果 x 为偶数（2），那么 x ^ 1 &#x3D; 2 ^ 1 &#x3D; 3</li>
<li>如果 x 为奇数（3），那么 x ^ 1 &#x3D; 3 ^ 1 &#x3D; 2</li>
</ul>
<p>最后，我们来想想如何判定两个点是否属于一条边的两个端点？是不是只要满足 a ^ 1 &#x3D;&#x3D; b 条件，那么 a 与 b 就是一条边的两个端点了？对，就是这样！</p>
<p><strong>语句二：bridge[i] &#x3D; bridge[i ^ 1] &#x3D; true</strong></p>
<p>这句话是为了标记某个节点对应的边是桥。而又因为我们在建立边时是成对地，那么相邻的两个节点都应该被标记。</p>
<p><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>可以看出此题有两种情况:</p>
<p>一是有的罪犯既不能贿赂他也没有罪犯能揭发他，那么此题无解，我们在遍历时打上标记，然后从小到大枚举，只要遇见没有标记的就输出然后退出即可</p>
<p>二是所有的罪犯都能直接或间接地被能贿赂的罪犯揭发。很明显，也有两种情况，一是没有环，那么资金就是贿赂那个没有入度的罪犯，二是有环，那么资金就是那个环里罪犯所需资金最小的。我们想，如果我们把环里的罪犯缩成一个点，那么全都是前者的情况了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ss</span>&#123;</span><br><span class="line">	<span class="type">int</span> next,to;</span><br><span class="line">&#125;;ss data[<span class="number">200010</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,q,timeclock,p,top,cnt,ans,r;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">200010</span>],low[<span class="number">200010</span>],stack[<span class="number">200010</span>],instack[<span class="number">200010</span>],next[<span class="number">200010</span>],head[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> belong[<span class="number">200010</span>],money[<span class="number">200010</span>],sum[<span class="number">200010</span>],size[<span class="number">200010</span>],rd[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	data[++p].next=head[a];</span><br><span class="line">	data[p].to=b;</span><br><span class="line">	head[a]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> a)</span>           <span class="comment">//标准的tarjan代码 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[a]=low[a]=++timeclock;</span><br><span class="line">	instack[a]=<span class="number">1</span>;</span><br><span class="line">	stack[++top]=a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[a];i;i=data[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=data[i].to;</span><br><span class="line">	    <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">	    &#123;</span><br><span class="line">	 	    <span class="built_in">tarjan</span>(v);</span><br><span class="line">		    low[a]=<span class="built_in">min</span>(low[a],low[v]);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">if</span>(instack[v])</span><br><span class="line">	    low[a]=<span class="built_in">min</span>(low[a],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[a]==low[a])</span><br><span class="line">	&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">while</span>(stack[top+<span class="number">1</span>]!=a)</span><br><span class="line">		&#123;</span><br><span class="line">			belong[stack[top]]=cnt;</span><br><span class="line">			instack[stack[top]]=<span class="number">0</span>;</span><br><span class="line">			size[cnt]++;</span><br><span class="line">			sum[cnt]=<span class="built_in">min</span>(sum[cnt],money[stack[top]]);</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	money[i]=<span class="number">1e9</span>+<span class="number">7</span>;        <span class="comment">//记得赋初值哦 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	sum[i]=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,mo;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;mo);</span><br><span class="line">		money[u]=mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">if</span>(!dfn[i]&amp;&amp;money[i]!=inf)  <span class="comment">//如果他能够被贿赂就以他为起点找环 </span></span><br><span class="line">	<span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)      <span class="comment">//在这里我们用dfn数组来判断它是否被遍历过 </span></span><br><span class="line">	<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=data[j].next)</span><br><span class="line">	<span class="keyword">if</span>(belong[i]!=belong[data[j].to])</span><br><span class="line">	&#123;</span><br><span class="line">	    rd[belong[data[j].to]]++;   <span class="comment">//记录入度 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	   <span class="keyword">if</span>(!rd[i])</span><br><span class="line">	   &#123; </span><br><span class="line">	       ans+=sum[i];</span><br><span class="line">	   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://zhuanlan.zhihu.com/p/74789463">最小生成树（Kruskal算法和Prim算法） - 知乎 (zhihu.com)</a></p>
<p>在给定一张无向图，如果在它的子图中，任意两个顶点都是互相连通，并且是一个树结构，那么这棵树叫做生成树。当连接顶点之间的图有权重时，权重之和最小的树结构为最小生成树！</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-2f15b6f1ccd26f034ff640ba10e5ddd6_720w.jpg" alt="img"></p>
<h3 id="Kruskal算法（克鲁斯卡算法）"><a href="#Kruskal算法（克鲁斯卡算法）" class="headerlink" title="Kruskal算法（克鲁斯卡算法）"></a><strong>Kruskal算法（克鲁斯卡算法）</strong></h3><p>Kruskal算法是一种<strong>贪心算法</strong>，我们将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树中！<strong>注意：如果这两个顶点都在同一集合内，说明已经通过其他边相连，因此如果将这个边添加到生成树中，那么就会形成环！</strong>这样反复做，直到所有的节点都连接成功！</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-584bc7761471fd9835cde91b303935ac_720w.jpg" alt="img"></p>
<p>在这个算法中，最重要的一环就是判断两个节点在不在同一个集合内，很多人想，那你直接用一个set来保存不就好了？这是思路显然不行，因为假设A和其他三个节点相连，同属一个集合，而B和另外三个节点相连，同属一个集合，那么<strong>我们将A和B取并集时，是将这两组数据合并一起的，如果使用set，那么当数据量大时还需要遍历，复杂度就会很高，因此使用并查集就会效率快很多了</strong>！</p>
<p><a href="https://mp.weixin.qq.com/s/gGCQ9uqlNQYbBHtw83xgOw">并查集详解和STL中的自定义哈希 (qq.com)</a></p>
<ol>
<li>对所有节点遍历建立并查集，按照边的权重建立最小堆</li>
<li>取出最小堆堆顶数据，并判断两端节点是否在同一集合</li>
<li>如不在，则将这两个节点添加到同一集合，接着将边加入生成边，如在，则不进行操作，为无效边</li>
<li>重复上面的操作，直到所有的边都检查完</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;Edge, EdgeHash, EdgeEqual&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;    <span class="comment">// 最小堆</span></span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Node*&gt; list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite: graph.nodes)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(ite.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">UnionFindSet <span class="title">unionFind</span><span class="params">(list)</span></span>;   <span class="comment">// 建立并查集</span></span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">smallQueue</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge: graph.edges)&#123;</span><br><span class="line">        smallQueue.<span class="built_in">push</span>(*edge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造选中的输出边集</span></span><br><span class="line">    unordered_set&lt;Edge, EdgeHash, EdgeEqual&gt; result;</span><br><span class="line">    <span class="keyword">while</span>(!smallQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Edge edge = smallQueue.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        smallQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!unionFind.<span class="built_in">isSameSet</span>(edge.from, edge.to))&#123;  </span><br><span class="line"><span class="comment">// 判断是否为一个环，如果一个边的两端节点为一个集合，那么必为一个闭合环</span></span><br><span class="line">            result.<span class="built_in">insert</span>(edge);</span><br><span class="line">            unionFind.<span class="built_in">Union</span>(edge.from, edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/36/problem/POJ-2485">Highways - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* POJ2485 Highways */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> f[N + <span class="number">1</span>], fcnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UFInit</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    fcnt = n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == f[a] ? a : f[a] = <span class="built_in">Find</span>(f[a]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="built_in">Find</span>(a);</span><br><span class="line">    b = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        f[a] = b;</span><br><span class="line">        fcnt--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> src, dest, cost;</span><br><span class="line">&#125; edges[N * (N - <span class="number">1</span>)];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, cost, cnt2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">UFInit</span>(n);</span><br><span class="line"> </span><br><span class="line">        cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cost);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i) &#123;</span><br><span class="line">                    edges[cnt2].src = i;</span><br><span class="line">                    edges[cnt2].dest = j;</span><br><span class="line">                    edges[cnt2++].cost = cost;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sort</span>(edges, edges + cnt2, cmp);</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Union</span>(edges[i].src, edges[i].dest)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, edges[i].cost);</span><br><span class="line">                <span class="keyword">if</span>(fcnt == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="Prim算法（普里姆算法）"><a href="#Prim算法（普里姆算法）" class="headerlink" title="Prim算法（普里姆算法）"></a><strong>Prim算法（普里姆算法）</strong></h3><p>Prim算法是另一种贪心算法，和Kuskral算法的贪心策略不同，Kuskral算法主要对边进行操作，而Prim算法则是对节点进行操作，每次遍历添加一个点，这时候我们就不需要使用并查集了。具体步骤为：</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-a5bb266f04bb7368d08fbe7c950b3924_720w.jpg" alt="img"></p>
<ol>
<li>建立边set用来存放结果，建立节点set用来存放节点同时用于标记是否被访问过，建立边的最小堆</li>
<li>开始遍历所有节点，如果没有访问，则添加到节点set，然后将其相连的边入堆。</li>
<li>从堆中取最小的边，然后判断to节点是否被访问过，如果没有，将这个边加入生成树（我们想要的边），并标记该节点访问。</li>
<li>然后将to节点所相连的边添加到最小堆中，不然这个网络就不会向外扩展了（这个步骤是必须的）。</li>
<li>循环上面的操作，直到所有的节点遍历完。</li>
</ol>
<p><strong>注意：对于单连通，从一个节点出发就可以直接找到完整的最小生成树，因此最外的for循环也可以为一个顺序结构，但多连通，就需要从不同的节点出发了！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;Edge, EdgeHash, EdgeEqual&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 装边的最小堆</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="type">const</span> Edge&amp; e1, <span class="type">const</span> Edge&amp; e2)&#123;</span><br><span class="line">        <span class="keyword">return</span> e1.weight &gt; e2.weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">smallQueue</span>(cmp);</span><br><span class="line">    <span class="comment">// 判断节点是否访问过</span></span><br><span class="line">    unordered_set&lt;Node, NodeHash, NodeEqual&gt; node_set;</span><br><span class="line">    unordered_set&lt;Edge, EdgeHash, EdgeEqual&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite: graph.nodes)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node_set.<span class="built_in">find</span>(*ite.second) == node_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// 如果没有访问,将其标记为访问过，并把它对应的边放入最小堆</span></span><br><span class="line">            node_set.<span class="built_in">insert</span>(*ite.second);</span><br><span class="line">            <span class="keyword">for</span>(Edge* edge: ite.second-&gt;edges)&#123;</span><br><span class="line">                smallQueue.<span class="built_in">push</span>(*edge);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在当前这个图中寻找最小生成树</span></span><br><span class="line">            <span class="keyword">while</span>(!smallQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="comment">// 从堆中取出一个最小权重边，并取出对应节点</span></span><br><span class="line">                Edge help_edge = smallQueue.<span class="built_in">top</span>();</span><br><span class="line">                smallQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                Node edge_to = *(help_edge.to);</span><br><span class="line">                <span class="comment">// 然后判断这个节点是否被访问过，如果没有则将这个边加入边集</span></span><br><span class="line">                <span class="keyword">if</span>(node_set.<span class="built_in">find</span>(edge_to) == node_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    result.<span class="built_in">insert</span>(help_edge);</span><br><span class="line">                    node_set.<span class="built_in">insert</span>(edge_to);   <span class="comment">// 标记edge_to也已经访问过了</span></span><br><span class="line">                    <span class="keyword">for</span>(Edge *newEdge: edge_to.edges)&#123;</span><br><span class="line">                        smallQueue.<span class="built_in">push</span>(*newEdge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Kruksal算法是对边进行操作，先取出边，然后判断边的两个节点，这样的话，如果一个图结构非常的稠密，那么Kruksal算法就比较慢了，而Prim算法只是对节点进行遍历，并使用set进行标记，因此会相对于Kruksal算法，在稠密图方面好很多，因此<strong>Kruksal算法常用于稀疏图，而Prim算法常用于稠密图！</strong></p>
<p><a href="https://cdutetcoj.xyz/training/36/problem/POJ-1287">Networking - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">105</span>];<span class="comment">//是否已经在子树中 </span></span><br><span class="line"><span class="type">int</span> graph[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> p,r;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">10e7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;<span class="comment">//用来在优先队列中存放数据 </span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> val,<span class="type">int</span> id):<span class="built_in">val</span>(val),<span class="built_in">id</span>(id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp; a,<span class="type">const</span> Node&amp; b)&#123;<span class="comment">//使用优先队列要重载小于运算符 </span></span><br><span class="line">	<span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;<span class="comment">//从cur开始进行连接结点 </span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;Node&gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>;u &lt; p;u++)&#123;</span><br><span class="line">		vis[cur] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p;i++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i] &amp;&amp; graph[cur][i] != inf)</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">Node</span>(graph[cur][i],i));	</span><br><span class="line">		Node h = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">while</span>(vis[h.id])&#123;<span class="comment">//如果当前最小距离的点已经全连接在子树里了，故删除 </span></span><br><span class="line">			h = q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		cur = h.id;</span><br><span class="line">		ans += h.val; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">		<span class="type">int</span> a,b,val;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= p;j++)	graph[i][j] = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; r;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;val);</span><br><span class="line">			graph[b][a] = graph[a][b] = <span class="built_in">min</span>(val,graph[a][b]);</span><br><span class="line">			<span class="comment">//俩个点直接最短距离 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Prim</span>(<span class="number">1</span>));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a><strong>Dijkstra算法</strong></h3><p><a href="https://zhuanlan.zhihu.com/p/357580063">最短路算法（Dijkstra + SPFA + Floyd） - 知乎 (zhihu.com)</a></p>
<p><strong>1.算法基本介绍</strong></p>
<p>Dijkstra算法通常是求解单源最短路中最快的算法，但它无法处理存在负权边的情况（原因在正确性证明中）。Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果，其实后面要讲到的几种算法也大都是采用这种步步逼近的手段。这种不断调整的过程，维基百科上面称为“relax”。以上可能有点抽象，下面是算法的流程。</p>
<p><strong>2.算法流程</strong></p>
<p>假设现在要求出从某一点s到其他所有点的最短距离，对于每个点v均维护一个“当前距离”（dist[v]）和“是否访问过”(visited[v])。首先将dist[s]初始化为0，将其他点的距离初始化为无穷，并将所有点初始化为未访问的。记u-&gt;v的边权为weight[u-&gt;v]。然后进行以下步骤：</p>
<ol>
<li>从所有未访问的点中，找出当前距离最小的，设为u，并将其标记为已访问的。</li>
<li>调整u的所有边（若是有向图则为出边）连接的并且<strong>未被访问过的</strong>点：若weight[u-&gt;v] + dist[u] &lt; dist[v], 则将dist[v]更新为dist[u]+weight[u-&gt;v]。</li>
<li>重复1和2步骤，直到所有点都被标记为已访问的，则dist[i]即s到i的最短距离。如果只想求从s到某一点的最短距离，那么当该点被标记为访问过之后可直接退出。</li>
<li>补充：如果除了最短距离之外还想求出具体的路径，只需建立一个pre数组，在步骤2后添加操作：pre[v] &#x3D; u（前提是dist[v]被更新）。</li>
</ol>
<p><strong>3.正确性证明</strong></p>
<p>我们证明，当某个点v被标记为已访问后，s到其的最短距离即为dist[v]，即在步骤1中选出的每个点的当前距离即为最短距离。</p>
<p>首先容易理解，如果从s到v的路径只允许经过已访问过的点，那么dist[v]是这些路径中最短的。倘若存在一条包含未访问过点（除v之外）的更短的路径，设这条路径上第一个未被访问过的点为m，则显然有dist[m] &lt; dist[v]（注意因为m是这条路径上第一个未被访问的点，所以沿着这条路径走到m的距离一定为dist[m]）。而这与v的选取方式——从所有未访问过点中选取当前距离最小的相矛盾。</p>
<p><strong>4.复杂度分析</strong></p>
<p>设图的点数为V，边数为E。则算法花费的时间近似为 <img data-src="https://www.zhihu.com/equation?tex=V%5Ccdot+T_%7B1%7D+++E%5Ccdot+T_%7B2%7D" alt="[公式]"> ,其中，为 <img data-src="https://www.zhihu.com/equation?tex=T_1" alt="[公式]"> 每次找到当前距离最小的点花费的时间， <img data-src="https://www.zhihu.com/equation?tex=T_%7B2%7D" alt="[公式]"> 为用每条边调整某个点当前距离所用的时间。</p>
<p>当我们用数组来储存每个节点时，每次找到当前距离最小的点都要遍历整个数组，而根据边权来修改当前距离不需要额外操作，因此复杂度为 <img data-src="https://www.zhihu.com/equation?tex=O(V%5E%7B2%7D+E)+=+O(V%5E%7B2%7D)" alt="[公式]"></p>
<p>当我们用一个普通优先级队列来储存节点时（键值为每个点的当前距离），每次找到当前距离最小的点并将其出队的时间为 <img data-src="https://www.zhihu.com/equation?tex=O(%5Clg+V)" alt="[公式]"> ，每次根据边权修改当前距离后还要在优先级队列中调整点的层次 ，时间也为 <img data-src="https://www.zhihu.com/equation?tex=O(%5Clg+V)" alt="[公式]"> ，故时间复杂度为 <img data-src="https://www.zhihu.com/equation?tex=O(V%5Clg+V+++E%5Clg+V)+=+O((V+E)%5Clg+V)" alt="[公式]"> 。如果图是稠密图的话，时间复杂度可表示为 <img data-src="https://www.zhihu.com/equation?tex=O(V%5E2%5Clg+V)" alt="[公式]"> 。</p>
<p>当然，最适合的储存节点的数据结构为用斐波那契堆实现的优先级队列，它可以做到出队时间为 <img data-src="https://www.zhihu.com/equation?tex=O(%5Clg+V)" alt="[公式]"> ，调整时间为 <img data-src="https://www.zhihu.com/equation?tex=O(1)" alt="[公式]"> ，这样就可以获得最优的时间复杂度 <img data-src="https://www.zhihu.com/equation?tex=O(V%5Clg+V+++E)" alt="[公式]"> 。</p>
<ul>
<li><p><em>d<strong>i</strong>j<strong>k</strong>s<strong>t</strong>r**a</em>本质上的思想是贪心,它只适用于不含负权边的图.</p>
</li>
<li><p>我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点”</p>
</li>
<li><p>dijkstra<em>d<strong>i</strong>j<strong>k</strong>s<strong>t</strong>r**a</em>的流程如下::</p>
</li>
<li><p>1.1. 初始化dis[start] &#x3D; 0,<em>d<strong>i</strong>s</em>[<em>s<strong>t</strong>a<strong>r</strong>t</em>]&#x3D;0,其余节点的dis<em>d<strong>i</strong>s</em>值为无穷大.</p>
</li>
<li><p>2.2. 找一个dis<em>d<strong>i</strong>s</em>值最小的蓝点x,<em>x</em>,把节点x<em>x</em>变成白点.</p>
</li>
<li><p>3.3. 遍历x<em>x</em>的所有出边(x,y,z),(<em>x</em>,<em>y</em>,<em>z</em>),若dis[y] &gt; dis[x] + z,<em>d<strong>i</strong>s</em>[<em>y</em>]&gt;<em>d<strong>i</strong>s</em>[<em>x</em>]+<em>z</em>,则令dis[y] &#x3D; dis[x] + z<em>d<strong>i</strong>s</em>[<em>y</em>]&#x3D;<em>d<strong>i</strong>s</em>[<em>x</em>]+<em>z</em></p>
</li>
<li><p>4.4. 重复2,32,3两步,直到所有点都成为白点..</p>
</li>
<li><p>当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第22步中找出的蓝点x<em>x</em>必然满足:dis[x]:<em>d<strong>i</strong>s</em>[<em>x</em>]已经是起点到x<em>x</em>的最短路径..我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度</p>
</li>
</ul>
<p>图解</p>
<ul>
<li>(令start &#x3D; 1<em>s<strong>t</strong>a<strong>r</strong>t</em>&#x3D;1)</li>
<li>开始时我们把dis[start]<em>d<strong>i</strong>s</em>[<em>s<strong>t</strong>a<strong>r</strong>t</em>]初始化为00,其余点初始化为inf<em>i<strong>n</strong>f</em></li>
</ul>
<p><img data-src="https://i.loli.net/2018/07/25/5b583277e47e9.png" alt="初始化"></p>
<p>第一轮循环找到dis<em>d<strong>i</strong>s</em>值最小的点11,将11变成白点,对所有与11相连的蓝点的dis<em>d<strong>i</strong>s</em>值进行修改,使得dis[2]&#x3D;2,dis[3]&#x3D;4,dis[4]&#x3D;7<em>d<strong>i</strong>s</em>[2]&#x3D;2,<em>d<strong>i</strong>s</em>[3]&#x3D;4,<em>d<strong>i</strong>s</em>[4]&#x3D;7</p>
<p><img data-src="https://i.loli.net/2018/07/25/5b58347b9a37b.png" alt="1"></p>
<p>第二轮循环找到dis<em>d<strong>i</strong>s</em>值最小的点22,将22变成白点,对所有与22相连的蓝点的dis<em>d<strong>i</strong>s</em>值进行修改,使得dis[3]&#x3D;3,dis[5]&#x3D;4<em>d<strong>i</strong>s</em>[3]&#x3D;3,<em>d<strong>i</strong>s</em>[5]&#x3D;4</p>
<p><img data-src="https://i.loli.net/2018/07/25/5b586fa8de335.png" alt="2"></p>
<p>第三轮循环找到dis<em>d<strong>i</strong>s</em>值最小的点33,将33变成白点,对所有与22相连的蓝点的dis<em>d<strong>i</strong>s</em>值进行修改,使得dis[4]&#x3D;4<em>d<strong>i</strong>s</em>[4]&#x3D;4</p>
<p><img data-src="https://i.loli.net/2018/07/25/5b58703e8d0d6.png" alt="3"></p>
<ul>
<li>接下来两轮循环分别将4,54,5设为白点,算法结束,求出所有点的最短路径</li>
</ul>
<p>为什么dijkstra<em>d<strong>i</strong>j<strong>k</strong>s<strong>t</strong>r**a</em>不能处理有负权边的情况?</p>
<p><img data-src="https://i.loli.net/2018/07/25/5b58724845b8d.png" alt="4"></p>
<ul>
<li>2到33的边权为-4−4,显然从11到33的最短路径为-2−2 (1-&gt;2-&gt;3).(1−&gt;2−&gt;3).但在循环开始时程序会找到当前dis<em>d<strong>i</strong>s</em>值最小的点33,并标记它为白点.</li>
<li>这时的dis[3]&#x3D;1,<em>d<strong>i</strong>s</em>[3]&#x3D;1,然而11并不是起点到33的最短路径.因为33已经被标为白点,所以dis[3]<em>d<strong>i</strong>s</em>[3]不会再被修改了.我们在边权存在负数的情况下得到了错误的答案.</li>
</ul>
<p><strong>5.代码</strong></p>
<p>以下为模板代码，存图用前向星,存储节点用数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; dist[i++] = inf);</span><br><span class="line">    dist[s] = <span class="number">0</span>;                  <span class="comment">// s为源点， t为目标点。</span></span><br><span class="line">    <span class="keyword">while</span>(!visited[t])&#123;</span><br><span class="line">        <span class="type">int</span> node, lowest = inf;   <span class="comment">//inf 为预设最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dist[j] &lt; lowest)&#123;</span><br><span class="line">                lowest = dist[j];</span><br><span class="line">                node = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                          <span class="comment">//找到当前距离最小的节点</span></span><br><span class="line">        visited[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = head[node]; e != <span class="number">0</span>; e = edges[e].next)&#123;</span><br><span class="line">            <span class="type">int</span> v = edges[e].to, w = edges[e].weight;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dist[node] + w &lt; dist[v])&#123;</span><br><span class="line">                dist[v] = dist[node] + w;</span><br><span class="line">                pre[v] = e;           <span class="comment">//修改当前距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxN = <span class="number">100010</span>, MaxM = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, dis, next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edge e[MaxM];</span><br><span class="line"><span class="type">int</span> head[MaxN], dis[MaxN], cnt;</span><br><span class="line"><span class="type">bool</span> vis[MaxN];</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">( <span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> d )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].dis = d;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dis;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;( <span class="type">const</span> node &amp;x )<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>( ( node )&#123;<span class="number">0</span>, s&#125; );</span><br><span class="line">    <span class="keyword">while</span>( !q.<span class="built_in">empty</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> x = tmp.pos, d = tmp.dis;</span><br><span class="line">        <span class="keyword">if</span>( vis[x] )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = head[x]; i; i = e[i].next )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>( dis[y] &gt; dis[x] + e[i].dis )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + e[i].dis;</span><br><span class="line">                <span class="keyword">if</span>( !vis[y] )</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>( ( node )&#123;dis[y], y&#125; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>( <span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)dis[i] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> u, v, d;</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;d );</span><br><span class="line">        <span class="built_in">add_edge</span>( u, v, d );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, dis[i] );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法又称为Floyd-Warshell算法，其实Warshell算法是离散数学中求传递闭包的算法，两者的思想是一致的。Floyd算法是求解多源最短路时通常选用的算法，经过一次算法即可求出任意两点之间的最短距离，并且可以处理有负权边的情况（但无法处理负权环），算法的时间复杂度是 <img data-src="https://www.zhihu.com/equation?tex=O(V%5E3)" alt="[公式]"> ，空间复杂度是 <img data-src="https://www.zhihu.com/equation?tex=O(V%5E2)" alt="[公式]"> 。</p>
<p>算法的实现非常简单，是一个三重循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dist[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="comment">//初始化dist数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; v; ++k)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v; ++j)&#123;</span><br><span class="line">            dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dist[i][j]为i与j间的当前最短距离，初始化dist数组时，每个点到自己的距离设为0，如果点i到点j之间有边，则dist[i][j]设为weight[i-&gt;j]，否则将其设为infinity。</p>
<p><strong>原理：</strong></p>
<p>Floyd本质上是动态规划的思想。倘若现在我们想求i到j的最短路径长度，我们限制这条路径上除i和j之外只准经过<strong>前</strong>k个点（这样的路径称为k允许路径），我们在算法的最外层循环每次将k加1，那么当k等于点数时求得的结果便是最优的。下面用数学归纳法证明算法的正确性：</p>
<p>即证明在第n次循环后dist[i][j]为i到j的最短n允许路径，当n&#x3D;0时，i到j不准经过任何点，dist[i][j]即为weight[i-&gt;j]或者无穷大，显然成立。</p>
<p>假设n&#x3D;k时成立，那么当n&#x3D;k+1时，倘若i到j的最短k+1允许路径不经过第k+1个点，则dist[i][j]不发生改变。若i到j的最短k+1允许路径经过第k+1个点，由归纳假设，此时dist[i][k+1]为i到k+1的最短k允许路径，dist[k+1][j]为k+1到j的最短k允许路径，故i到j的最短k+1允许路径长为dist[i][k+1] + dist[k+1][j]。这正是算法中的状态转移方程。</p>
<p><a href="https://cdutetcoj.xyz/training/35/problem/T1379">热浪 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> n, m, s, u, v, w, s1;</span><br><span class="line"><span class="type">int</span> to[N], val[N], pre[N], zd[N];</span><br><span class="line"><span class="type">int</span> node = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[node] = b;      <span class="comment">//到达的点</span></span><br><span class="line">    val[node] = c;     <span class="comment">//权值</span></span><br><span class="line">    pre[node] = zd[a]; <span class="comment">//更新</span></span><br><span class="line">    zd[a] = node++;    <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= m; i++)</span></span><br><span class="line">    <span class="comment">//     dis[i] = INF;</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(s);</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;dis[s], s&#125;); </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())      <span class="comment">//队列的长度不为零,当堆中还有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">top</span>().second; <span class="comment">// q.top()取出堆顶，也就是当前距离起点最近的点。</span></span><br><span class="line">        q.<span class="built_in">pop</span>();                <span class="comment">//取完就删</span></span><br><span class="line">        <span class="keyword">if</span> (vis[x])</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">//如果这个点标记过了，跳过</span></span><br><span class="line">        vis[x] = <span class="number">1</span>;   <span class="comment">//标记一下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = zd[x]; i != <span class="number">-1</span>; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[to[i]] &gt; dis[x] + val[i]) <span class="comment">// dijkstra算法核心语句</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[to[i]] = dis[x] + val[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[to[i]], to[i]&#125;); <span class="comment">//每次松弛成功，把关于当前点的信息压入堆。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//使用后不能与scanf,printf 混用</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; s1;</span><br><span class="line">    <span class="built_in">memset</span>(zd, <span class="number">-1</span>, <span class="keyword">sizeof</span> zd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>();</span><br><span class="line">    cout &lt;&lt; dis[s1];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Bellmon-Ford-算法和-SPFA"><a href="#Bellmon-Ford-算法和-SPFA" class="headerlink" title="Bellmon-Ford 算法和 SPFA"></a>Bellmon-Ford 算法和 SPFA</h3><p>首先介绍bellmon-ford算法，spfa（shortest path faster algorithm)是对它的一个改进。</p>
<p>bellmon-ford是一种单源最短路算法，时间复杂度是 <img data-src="https://www.zhihu.com/equation?tex=O(VE)" alt="[公式]"> ,显然不如dijkstra快，但它可以处理负权边和负权环的情况。它基于一个很基本的事实：<strong>对于一个不包含负权环的V个点的图，任意两点之间的最短路径至多包含V-1条边。</strong>如果存在负权环，每次在负权环上走一圈都会使环上的每一个点的距离减少，因此不存在最短路径。bellmon-ford算法可以检测出这种情况。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inf 9999999</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s, v, e; <span class="comment">// s为源点,v为顶点数,e为边数；</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from, to, weight;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edges[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[<span class="number">1000</span>], pre[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellmon</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v; ++i) dist[i] = inf;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; e; ++j)&#123;</span><br><span class="line">            <span class="type">int</span> u = edges[j].from, v = edges[j].to, w = edges[j].weight;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法中，dist[i]为源点到i的当前最短距离，pre数组用来记录具体的最短路径。算法最外层是一个V-1次的循环，在每次循环中，算法遍历所有的边并执行操作。用数学归纳法不难证明，第k次循环后，dist[i]即为从源点到i的长度不超过k的路径的最短长度。</p>
<p>bellmon-ford算法不断对每条边进行所谓的松弛（relax）操作，如果u到v有一条边，那么dist[u]减小意味着dist[v]可能也可以进行更新，然而由于不知道到底哪些点的当前距离需要更新，bellmon-ford算法选择暴力地去遍历每条边来检查哪些点的当前距离可以更新。</p>
<p>如果在某次外层循环中发现所有点的当前距离都没有被更新，那么可以直接停止算法，因为接下来无论再进行多少次循环点的距离也不会被继续更新了。</p>
<p>bellmon-ford算法可以判断负权环的存在：只需在算法的最后对每条边再松弛一次，如果发现有点的距离得到更新，说明存在负权环——因为没有负权环时最短路径的长度至多为V-1。</p>
<p><strong>SPFA：</strong></p>
<p>从上面的介绍我们知道bellmon-ford算法是带着一定的盲目性的，作为对它的优化，spfa采用类似bfs的思想，使用一个队列，只松弛那些可能更新点的距离的边。算法的流程为：</p>
<ol>
<li>将除源点之外的所有的点当前距离初始化为无穷，并标记为未入队。源点的当前距离为0，将源点入队。</li>
<li>取出队首u，遍历u的所有出边，检查是否能更新所连接的点v的当前距离。如果v的当前距离被更新并且v不在队中，则将v入队。重复该操作直到队列为空。</li>
<li>检查是否存在负权环的方法为：记录一个点的入队次数，如果超过V-1次说明存在负权环，因为最短路径上除自身外至多V-1个点，故一个点不可能被更新超过V-1次。</li>
</ol>
<p><a href="https://cdutetcoj.xyz/training/35/problem/POJ-1860">Currency Exchange - CDUTETCOJ</a></p>
<p><strong>题意是给我们n种货币,m个货币兑换点,然后有转换规则.问你最后经过一连串转换后，回到起点，你手上的这种货币数量有没有增多</strong></p>
<p><strong>把n种货币看成n个点，把m个货币兑换点看成m条边，但是注意这条边上存的是转换规则，因为边的权值应该是转换后的货币量，我们一开始不可能知道。</strong><br><strong>那么，我们再看一下这个提问，问你回到起点后的数量，首先，我们边可以将它看成有向边,点A转换为点B的兑换规则看成一条A-B的有向边，那么B-A的兑换规则就是一条B-A的有向边。根据提问,我们最后能要回到起点，说明图中肯定存在环，而且我们回到起点后，数量要增长，那么就肯定存在一条正环。我们只需要一直判断dis[s]，也就是到原点的权值是不是大于开始的v了，如果大于了，那么就说明存在正环。</strong></p>
<p><strong>注意点:我们一开始的dis[s]应该等于我们原来的数量v，这样才能通过边上的转换规则转换得到边上的权值.</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e7+5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INM INT_MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(a)  push_back(a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dbg(x) cout &lt;&lt; <span class="string">&quot;now this num is &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd(a) scanf(<span class="string">&quot;%d&quot;</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sld(a) scanf(<span class="string">&quot;%lld&quot;</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sdd(a,b) scanf(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sddd(a,b,c) scanf(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr(a) printf(<span class="string">&quot;%d\n&quot;</span>,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> plr(a) printf(<span class="string">&quot;%lld\n&quot;</span>,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_(a) printf(<span class="string">&quot;%d &quot;</span>,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _pr(a) printf(<span class="string">&quot; %d&quot;</span>,a)</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">105</span>],n,m,s;</span><br><span class="line"><span class="type">double</span> dis[<span class="number">105</span>],v;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">double</span> a1,b1;<span class="comment">//存转换规则，只存A-B的，因为看成有向边</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; G[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) dis[i] = <span class="number">0</span>;<span class="comment">//这里应该是找最大路</span></span><br><span class="line">    dis[x] = v;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;<span class="comment">//消除标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Node e = G[u][i];</span><br><span class="line">            <span class="keyword">if</span>(dis[e.to] &lt; (dis[u]-e.b1)*e.a1)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e.to] = (dis[u]-e.b1)*e.a1;</span><br><span class="line">                <span class="keyword">if</span>(!vis[e.to])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;<span class="comment">//添加标记</span></span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[x] &gt; v) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否存在正环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sddd</span>(n,m,s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;v);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="type">double</span> a1,b1,a2,b2;</span><br><span class="line">        <span class="built_in">sdd</span>(a,b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf %lf&quot;</span>,&amp;a1,&amp;b1,&amp;a2,&amp;b2);</span><br><span class="line">        Node p,q;</span><br><span class="line">        p.to = b;p.a1 = a1;p.b1 = b1;</span><br><span class="line">        q.to = a;q.a1 = a2;q.b1 = b2;</span><br><span class="line">        G[a].<span class="built_in">pb</span>(p);</span><br><span class="line">        G[b].<span class="built_in">pb</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>(s)) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LCA（最近公共祖先）"><a href="#LCA（最近公共祖先）" class="headerlink" title="LCA（最近公共祖先）"></a>LCA（最近公共祖先）</h2><p><a href="https://blog.csdn.net/Diogenes_/article/details/81456507?ops_request_misc=%7B%22request_id%22:%22165864686216782388049488%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165864686216782388049488&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81456507-null-null.142%5Ev33%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=LCA&spm=1018.2226.3001.4187"> 浅析LCA_Nekroz_的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_37957064/article/details/111560301?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-111560301-blog-101912136.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-111560301-blog-101912136.pc_relevant_aa&utm_relevant_index=6"> LCA算法以及原理详解_风流学霸段公子的博客-CSDN博客_lca算法</a></p>
<p>LCA-最近公共祖先<br>  LCA(Least Common Ancestors)，即最近公共祖先，这种描述是基于树结构的，也即我们通通常只在树结构中考虑祖先问题。树实际上就是图论中的<strong>有向无环图</strong>，而要研究LCA问题，首先我们要指定树中的一个顶点为根节点，并以该节点遍历有向无环图，生成一颗DFS序下的树，假设我们要查询的两个节点为u,v，DFS序下根节点到两点的最短路径分别是(r,u),和(r,v)，LCA就是(r,u)与(r,v)公共路径的最后一个节点，如下图所示，w即为LCA。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2020122216180877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTU3MDY0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>换句话说，u,v的LCA就是以r为根的树中，u到v的<a href="https://so.csdn.net/so/search?q=%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&spm=1001.2101.3001.7020">最短路径</a>中深度最小的点（假设根节点的深度为1，而深度是往下递增的）。</p>
<h3 id="暴力（DFS）"><a href="#暴力（DFS）" class="headerlink" title="暴力（DFS）"></a>暴力（DFS）</h3><p>  暴力法求解一对节点的LCA时时间复杂度是O(n)的，所以当查询多对节点的LCA时，暴力算法的时间复杂度往往不满足要求。<br>  暴力法就是通过不断地将深度向下求父节点，直到两个点的父节点重合时，即可得到LCA。下面给出一种实现方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> pre;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[maxn],father[maxn],deep[maxn];</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	node=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[node].pre=head[u];</span><br><span class="line">	edge[node].to=v;</span><br><span class="line">	head[u]=node++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">	father[u]=fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=edge[i].pre)&#123;</span><br><span class="line">		<span class="type">int</span> v=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果u结点的深度小于v节点的深度，那么交换两节点的值（防止两深度相减出现负值） </span></span><br><span class="line">	<span class="keyword">if</span>(deep[u]&lt;deep[v])&#123;</span><br><span class="line">		<span class="built_in">swap</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不断地向上寻找父节点，直到两节点高度相等 </span></span><br><span class="line">	<span class="keyword">while</span>(deep[u]&gt;deep[v])&#123;</span><br><span class="line">		u=father[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果u与v的父节点不相同，那么继续向上遍历直到到达最近公共点 </span></span><br><span class="line">	<span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">		u=father[u];</span><br><span class="line">		v=father[v];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><p>  倍增法其实就是每一步尽可能跳的多一点，他的思想与二分的想法其实是一致的，假设我们要求解LCA(u,v)，暴力的想法是我们始终将深度较深的往上跳跃一步，直到u,v的深度第一次相等时，此时该节点就是LCA(u,v)，但是这样做的话，在一个接近线性的树中，时间复杂度是O(n）的，当有多组查询时，这种开销就无法承受了。<br>  倍增的原理是每一次尽可能地多跳一些步数，而不是一步一步往上跳，当时如何快速找到应该跳的步数呢？考虑到depth[LCA(u,v)]-depth[u]是一个深度差值，而一开始我们是不知道LCA（u，v）到底是哪一个节点，并且u和v也可能不在同一深度，那么为了便于计算，我们应该首先间u和v调整到同一深度。<br>  当u和v的深度相同时，此时depth[LCA(u,v)]-depth[u]&#x3D;depth[LCA(u,v)]-depth[v]，也即u和v跳相同的步数即可到达最近公共祖先。由于此时不知道LCA（u,v）到底是哪一个，所以此时跳跃的步数只能使尝试性的，否则我们可能会直接跳过头，那么什么样的尝试序列是比较好的呢？考虑到搜索算法的时间复杂度上限，我们可以选择跳跃2^j步进行尝试。<br>  但是这里面存在一个问题就是，当u和v跳跃2^j步后，两者的祖先相等，此时该节点就是u和v的一个公共祖先，但是却不一定是最近公共祖先，所以为了避免这种情况的出现，我们选择u和v跳跃2 ^j步后，两者的祖先不是公共祖先的最大j，进行跳跃；跳跃2 ^j步后，此时u,v依然在同一深度，与之前的子问题是等价的，我们可以继续该操作，直到j&#x3D;&#x3D;0跳出循环；由于我们每一步都不会直接跳到最近公共祖先，所以最后得到的结果中，u和v都跳跃到了最近公共祖先的下一层，此时我们直接返回u或者v的父节点即可。<br>  上述跳跃2 ^j的操作是通过一个dp数组来实现的，我们用dp[i][j]表示节点i的第2 ^j个祖先，那么dp[i][j]可以由更小的子问题推导出，显然我们可以得到dp[i][j]&#x3D;dp[dp[i][j-1]][j-1];这样我们在遍历到每一个节点是预处理出以该节点的所有可能的dp值即可。初始化时dp[i][0]其实就是i的父节点，我们可以直接在遍历的时候赋值。<br>  下图是该算法每一次尝试跳跃时所做的选择。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20201226105816665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTU3MDY0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> pre;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[maxn],father[maxn],deep[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"><span class="type">int</span> n,m,u,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	node=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[node].pre=head[u];</span><br><span class="line">	edge[node].to=v;</span><br><span class="line">	head[u]=node++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>]=fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=deep[u];i++)&#123;</span><br><span class="line">		dp[u][i]=dp[dp[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=edge[i].pre)&#123;</span><br><span class="line">		<span class="type">int</span> v=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u]&lt;deep[v])<span class="comment">//确保u的深度大于v的深度</span></span><br><span class="line">        <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="type">int</span> h=deep[u]-deep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=h;i++)<span class="comment">//若不能确保u的深度大于v，这一步中就无法确定往上跳的是u还是v</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;h)</span><br><span class="line">            u=dp[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="comment">//若二者处于同一深度后，正好相遇，则这个点就是LCA</span></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log</span>(deep[u])/<span class="built_in">log</span>(<span class="number">2</span>);i&gt;=<span class="number">0</span>;i--)<span class="comment">//u和v同时往上跳，从大到小遍历步长，遇到合适的就跳上去，不合适就减少步长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[u][i]!=dp[v][i]) <span class="comment">//若二者没相遇则跳上去</span></span><br><span class="line">        &#123;</span><br><span class="line">            u=dp[u][i];</span><br><span class="line">            v=dp[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u][<span class="number">0</span>];<span class="comment">//最后u和v跳到了LCA的下一层，LCA就是u和v的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    	<span class="type">int</span> u,v;</span><br><span class="line">    	cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    	<span class="built_in">add_edge</span>(u,v);</span><br><span class="line">    	<span class="built_in">add_edge</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">LCA</span>(u,v) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/38/problem/5761">点的距离 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> pre;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[maxn],father[maxn],deep[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> node;</span><br><span class="line"><span class="type">int</span> n,m,u,v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	node=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[node].pre=head[u];</span><br><span class="line">	edge[node].to=v;</span><br><span class="line">	head[u]=node++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	deep[u]=deep[fa]+<span class="number">1</span>;</span><br><span class="line">	father[u]=fa;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];~i;i=edge[i].pre)&#123;</span><br><span class="line">		<span class="type">int</span> v=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u]&lt;deep[v])<span class="comment">//确保u的深度大于v的深度</span></span><br><span class="line">        <span class="built_in">swap</span>(u,v);</span><br><span class="line">        <span class="type">int</span> h=deep[u]-deep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=h;i++)<span class="comment">//若不能确保u的深度大于v，这一步中就无法确定往上跳的是u还是v</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;h)</span><br><span class="line">            u=dp[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="comment">//若二者处于同一深度后，正好相遇，则这个点就是LCA</span></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">log</span>(deep[u])/<span class="built_in">log</span>(<span class="number">2</span>);i&gt;=<span class="number">0</span>;i--)<span class="comment">//u和v同时往上跳，从大到小遍历步长，遇到合适的就跳上去，不合适就减少步长</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[u][i]!=dp[v][i]) <span class="comment">//若二者没相遇则跳上去</span></span><br><span class="line">        &#123;</span><br><span class="line">            u=dp[u][i];</span><br><span class="line">            v=dp[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u][<span class="number">0</span>];<span class="comment">//最后u和v跳到了LCA的下一层，LCA就是u和v的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v);<span class="comment">//双向建边</span></span><br><span class="line">        <span class="built_in">add_edge</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        deep[i]=deep[father[i]]+<span class="number">1</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>]=father[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="built_in">log2</span>(n); j++)</span><br><span class="line">            dp[i][j]=dp[dp[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];<span class="comment">//求出dp数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="type">int</span> L=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">        <span class="type">int</span> sum=(deep[u]+deep[v])<span class="number">-2</span>*deep[L];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上述算法的预处理时间复杂度是O(nlogn)，每次查询时间是O(logn)的。总的时间复杂度是O(nlon+mlogn)的；其中m为查询次数。<br>  注：上述算法主要有三个核心部分①中序前序遍历建立兄弟链表法的二叉树结构；②<a href="https://so.csdn.net/so/search?q=DFS&spm=1001.2101.3001.7020">DFS</a>获得预处理数据；③倍增法查询LCA。</p>
<h3 id="ST算法"><a href="#ST算法" class="headerlink" title="ST算法"></a>ST算法</h3><p>  看了一下网上的博客，解释的也不是很清楚，只是给出了一个DFS序，然后给出了实现代码，但是并没有实质上的原理阐述，而我根据我的理解对该算法进行解读吧。<br>  要想理解一般树的LCA算法，我觉得首先要理解二叉树的LCA算法，二叉树中由于每个节点只有两个孩子，假设我们要求解LCA的两个节点为u和v，考虑到在二叉树的中序遍历中有这样一个特性，也即u和v的LCA，一定在u和v之间遍历，而u和v的其他非LCA祖先，一定在u和v遍历次序之外，也即假设由中序遍历次序…u…v…，那么LCA(u,v)一定在u,v中间，也即有…u…LCA(u,v)…v…，而LCA(u,v)的祖先节点则一定在v之后遍历。<br>  这样，如果我们可以发现一个区间[u,v]中LCA(u,v)具有的特性，即可快速找到该点，考虑到区间[u,v]中（我们考虑的是中序遍历中的遍历区间）；LCA(u,v)的深度是最小的，那么如果我们可以快速得到区间[u,v]中的最小值即可求解出LCA(u,v)了；<br>  显然对于数组区间最值查询问题我们可以借用ST算法或者线段树实现，这里不再介绍这两种算法的时间过程，感兴趣可以看我的另一篇博客；<br>  上述思想实际上是在二叉树里面实现的，由于二叉树每个节点最多只有两个子节点，所以我们有中序遍历的说法，但是实际上一般树中是不存在中序遍历的， 我们通常只有DFS的遍历方式，那么如何在一般树中达到上述结构描述的性质呢？我们上述算法中要查询LCA(u,v)时，默认了LCA(u,v)一定在区间[u,v]中，而通常的DFS却不能保证这个性质，为了达到上述效果，我们需要保证我们在一般树中得到的遍历序列中，父节点的任意两个孩子之间都有父节点存在；<br>  为了达到上述效果，我们可以冗余存储，也即每当我们遍历到当前节点的一个分支时，我们就将当前节点也添加进去，这样我们就可以保证任意两个孩子节点都有一个父节点存在了，那么我们就可以按照二叉树中的思想求解LCA算法了。<br><a href="https://www.luogu.com.cn/problem/P3379#submit">P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5000005</span>;</span><br><span class="line"><span class="comment">//兄弟链表法存储所有边 </span></span><br><span class="line"><span class="type">int</span> edge[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> nest[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	nest[cnt]=last[u];</span><br><span class="line">	edge[cnt]=v;</span><br><span class="line">	last[u]=cnt;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sq[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> vise[N];</span><br><span class="line"><span class="type">int</span> has[N]; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=last[k];i;i=nest[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(vise[edge[i]])<span class="keyword">continue</span>;</span><br><span class="line">		vise[edge[i]]=<span class="literal">true</span>;</span><br><span class="line">		d[edge[i]]=d[k]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(edge[i]);</span><br><span class="line">		sq[++cnt]=edge[i];</span><br><span class="line">		has[edge[i]]=cnt;</span><br><span class="line">		sq[++cnt]=k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2</span>*N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="built_in">swap</span>(l,r);</span><br><span class="line">	<span class="type">int</span> k=<span class="built_in">log2</span>(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(d[dp[l][k]]&lt;d[dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]])&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[l][k];</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	vise[s]=<span class="literal">true</span>;</span><br><span class="line">	d[s]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cnt;i++)dp[i][<span class="number">0</span>]=sq[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+(<span class="number">1</span>&lt;&lt;j)&lt;=cnt+<span class="number">1</span>;i++)&#123;<span class="comment">//这里一定要考虑区间的边界，要满足超出区间右侧一位 </span></span><br><span class="line">			<span class="keyword">if</span>(d[dp[i][j<span class="number">-1</span>]]&lt;d[dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]])&#123;</span><br><span class="line">				dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j]=dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	has[s]=cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		cout&lt;&lt;<span class="built_in">lca</span>(has[u],has[v])&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述是LCA的ST算法实现方式，主要原理便是我上面所描述的，但是实际上针对本题可以简化DFS生成序列的过程，因为二叉树本身的中序遍历已经有了，我们只需要求出每个节点的深度即可运用ST算法。</p>
<h3 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h3><p>  终于到了最后的tarjan算法，断断续续也写了好几天了，现在来讲一讲tarjan的原理，刚开始看这个算法时，我觉得相比于倍增和ST算法来说是更难理解的，因为没有那种迸发的灵感，上面两个想法其实一开我就有一些想法的，只是有一些细节上有所缺失，但是当了解关键点以后，还是可以很轻易理解的，而tarjan算法一开始给我的感觉就是很乱，就像是做数学题要分类讨论，而我脑子里却一团糟的感觉。<br>  但是仔细梳理以后还是发现了该算法的神奇之处，实际上好的讲解也可以比较轻松的理解该算法的，好了，废话不多说了，直接上干货。<br>  首先还是要分析一下我们图算法里面最核心的知识——遍历，我们考虑DFS后序遍历时的特点（也即先遍历孩子节点，再遍历当前节点），对于两个节点u，v来说，他们要么在最近公共祖先的两个子树中，要么就是其中一个是祖先节点，一个是子孙节点。而DFS遍历时，我们遍历到u以及v时具有什么特殊的性质呢？<br>  如果u是先遍历到的，此时由于不知道v的信息，所以我们也无法对最近公共祖先做出判断。但是如果u是后遍历到的， 而v是先遍历到的，那么u遍历结束后，在DFS递归的返回过程中，u一定会不断向上返回，只到某一刻返回到u和v的LCA节点，那么我们如何快速知晓这个节点到底是哪一个呢？考虑到LCA(u,v)一定在u，v的上层，而如果我们将LCA(u,v)的v所在的子树内部的LCA问题都处理结束后，我们其实可以将这个子树中点集视为一个点，因为该子树中所有节点与子树之外节点的LCA只能是LCA(u,v)本身或者LCA(u,v)的父节点了。那么当我们将这个集合中每个点的父节点都设置为LCA(u,v)，在探查到u时，我们就可以通过v的父节点快速获得LCA(u,v)的值。<br>  对于将集合中每一个点的父节点都设置为LCA(u,v)的过程，我们可以使用并查集来实现，因为这是一个一个的子问题；当某一个节点s的所有分支的节点的可处理LCA问题都处理结束后，此时s的子树和s已经是一个并查集了，并且并查集的根节点是s，当s也处理结束后，我们可以直接将s并在其父节点的并查集中，并且将其父节点设置为根节点。这样后续节点与s以及s子树中节点的LCA问题的父节点只可能是s的祖先节点，而不可能是s或者s的子孙节点。而后续节点要想快速查询到与已经遍历过某个顶点的LCA时，直接查询已经遍历过顶点所在并查集的根节点即可。而查到的根节点一定是LCA，因为根节点总是后于要查询节点处理结束的。<br><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan离线算法实现LCA</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5000005</span>;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==arr[x]?x:arr[x]=<span class="built_in">find</span>(arr[x]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这里的merge不能用秩平衡定理 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	x=<span class="built_in">find</span>(x);</span><br><span class="line">	y=<span class="built_in">find</span>(y);</span><br><span class="line">	arr[x]=y;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//兄弟链表法存储所有边 </span></span><br><span class="line"><span class="type">int</span> edge[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> nest[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	nest[cnt]=last[u];</span><br><span class="line">	edge[cnt]=v;</span><br><span class="line">	last[u]=cnt;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来存储所有的查询以及查询的序号 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; qi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	q[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">	q[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	qi[u].<span class="built_in">push_back</span>(id);</span><br><span class="line">	qi[v].<span class="built_in">push_back</span>(id);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vise[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//初次访问 </span></span><br><span class="line">	vise[k]=<span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=last[k];i;i=nest[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(vise[edge[i]])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">DFS</span>(edge[i]);</span><br><span class="line">		<span class="comment">//注意这里只能单向合并，可以直接设置父节点 </span></span><br><span class="line">		<span class="built_in">merge</span>(edge[i],k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里一定要注意遍历顺序是后根序。 </span></span><br><span class="line">	<span class="comment">//查看是否已经有可以求解的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vise[q[k][i]]==<span class="number">2</span>)&#123;</span><br><span class="line">			ans[qi[k][i]]=<span class="built_in">find</span>(q[k][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历结束 </span></span><br><span class="line">	vise[k]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="type">int</span> n,m,s;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="comment">//初始化并查集</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)arr[i]=i; </span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="built_in">add_query</span>(u,v,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p><a href="https://blog.csdn.net/pi9nc/article/details/11848327?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-11848327-blog-102516637.pc_relevant_sortByAnswer&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-11848327-blog-102516637.pc_relevant_sortByAnswer&utm_relevant_index=1"> 二分图的最大匹配、完美匹配和匈牙利算法_pi9nc的博客-CSDN博客_匈牙利匹配算法</a></p>
<p><strong>二分图</strong>：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集  和 ，使得每一条边都分别连接 、  中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p>
<p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p>
<p><img data-src="http://img.renfei.org/2013/08/1.png" alt="Bipartite Graph(1)"></p>
<p><img data-src="http://img.renfei.org/2013/08/2.png" alt="Bipartite Graph(2)"></p>
<p><img data-src="http://img.renfei.org/2013/08/3.png" alt="Matching"></p>
<p><img data-src="http://img.renfei.org/2013/08/4.png" alt="Maximum Matching"></p>
<p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p>
<p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p>
<p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p>
<p>举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是<strong>完美匹配</strong>问题。如果换一个说法：最多有多少互相喜欢的男孩&#x2F;女孩可以配对儿？这就是<strong>最大匹配</strong>问题。</p>
<p><img data-src="http://img.renfei.org/2013/08/0.png" alt="0"></p>
<p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p><img data-src="http://img.renfei.org/2013/08/5.png" alt="5"></p>
<p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p>
<p><img data-src="http://img.renfei.org/2013/08/6.png" alt="6"></p>
<p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是<strong>改进匹配</strong>。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p>
<p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p>
<p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：</p>
<p><img data-src="http://img.renfei.org/2013/08/7.png" alt="7"></p>
<p><img data-src="http://img.renfei.org/2013/08/8.png" alt="8"></p>
<p><img data-src="http://img.renfei.org/2013/08/9.png" alt="9"></p>
<p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。</p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p><strong>匈牙利算法的要点如下</strong></p>
<ol>
<li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。<ol>
<li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li>
<li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li>
</ol>
</li>
<li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li>
</ol>
<p><strong>性能比较</strong></p>
<p>两个版本的时间复杂度均为  。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。</p>
<p>补充定义和定理：</p>
<p><strong>最大匹配数</strong>：最大匹配的匹配边的数目<br><strong>最小点覆盖数</strong>：选取最少的点，使任意一条边至少有一个端点被选择<br><strong>最大独立数</strong>：选取最多的点，使任意所选两点均不相连<br><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p>
<p>定理1：最大匹配数 &#x3D; 最小点覆盖数（这是 Konig 定理）<br>定理2：最大匹配数 &#x3D; 最大独立数<br>定理3：最小路径覆盖数 &#x3D; 顶点数 - 最大匹配数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> pre; </span><br><span class="line">&#125;edge[maxn*<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> node =<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> st[maxn];</span><br><span class="line"><span class="type">int</span> match[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">	node =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	edge[node].to=b;</span><br><span class="line">	edge[node].pre=head[a];</span><br><span class="line">	head[a]=node++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i!=<span class="number">-1</span>;i=edge[i].pre)&#123;</span><br><span class="line">		<span class="type">int</span> j=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">			st[j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">DFS</span>(match[j]))&#123;</span><br><span class="line">				match[j]=x;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">	cin&gt;&gt;number;</span><br><span class="line">	<span class="keyword">while</span>(number--)&#123;</span><br><span class="line">		<span class="type">int</span> n,m;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> num;</span><br><span class="line">			cin&gt;&gt;num;</span><br><span class="line">			<span class="keyword">while</span>(num--)&#123;</span><br><span class="line">				<span class="type">int</span> v;</span><br><span class="line">				cin&gt;&gt;v;</span><br><span class="line">				<span class="built_in">add</span>(i,v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">DFS</span>(i)) res++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res==n)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/40/problem/HDU-1083">Courses - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> pre; </span><br><span class="line">&#125;edge[maxn*<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> node =<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> st[maxn];</span><br><span class="line"><span class="type">int</span> match[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">	node =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	edge[node].to=b;</span><br><span class="line">	edge[node].pre=head[a];</span><br><span class="line">	head[a]=node++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i!=<span class="number">-1</span>;i=edge[i].pre)&#123;</span><br><span class="line">		<span class="type">int</span> j=edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">			st[j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">DFS</span>(match[j]))&#123;</span><br><span class="line">				match[j]=x;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">	cin&gt;&gt;number;</span><br><span class="line">	<span class="keyword">while</span>(number--)&#123;</span><br><span class="line">		<span class="type">int</span> n,m;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="type">int</span> num;</span><br><span class="line">			cin&gt;&gt;num;</span><br><span class="line">			<span class="keyword">while</span>(num--)&#123;</span><br><span class="line">				<span class="type">int</span> v;</span><br><span class="line">				cin&gt;&gt;v;</span><br><span class="line">				<span class="built_in">add</span>(i,v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">DFS</span>(i)) res++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res==n)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KM"><a href="#KM" class="headerlink" title="KM"></a>KM</h3><p>KM算法解决的是带权二分图的最优匹配问题。</p>
<p>匈牙利算法得到的最大匹配并不是唯一的，预设匹配边、或者匹配顺序不同等，都可能会导致有多种最大匹配情况，所以有一种替代KM算法的想法是，我们只需要用匈牙利算法找到所有的最大匹配，比较每个最大匹配的权重，再选出最大权重的最优匹配即可得到更贴近真实情况的匹配结果。但这种方法时间复杂度较高，会随着目标数越来越多，消耗的时间大大增加，实际使用中并不推荐。</p>
<p><strong>第一步</strong></p>
<p>首先对每个顶点赋值，称为<strong>顶标</strong>，将左边的顶点赋值为与其相连的边的<strong>最大权重</strong>，右边的顶点赋值为<strong>0</strong>。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190702192912846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaWVzb24uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>第二步，开始匹配</strong></p>
<p>匹配的原则是只和权重与左边分数（顶标）相同的边进行匹配，若找不到边匹配，对此条路径的所有左边顶点的顶标减d，所有右边顶点的顶标加d。参数d我们在这里取值为0.1。</p>
<p>对于左1，与顶标分值相同的边先标蓝。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190702192926736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaWVzb24uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>然后是左2，与顶标分值相同的边标蓝。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190702192938307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaWVzb24uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>然后是左3，发现与右1已经与左1配对。首先想到让左3更换匹配对象，然而根据匹配原则，只有权值大于等于0.9+0&#x3D;0.9（左顶标加右顶标）的边能满足要求。于是左3无法换边。那左1能不能换边呢？对于左1来说，只有权值大于等于0.8+0&#x3D;0.8的边能满足要求，无法换边。此时根据KM算法，应对所有冲突的边的顶点做加减操作，令左边顶点值减0.1，右边顶点值加0.1。结果如下图所示。<br><img data-src="https://img-blog.csdnimg.cn/201907021929510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaWVzb24uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>再进行匹配操作，发现左3多了一条可匹配的边，因为此时左3对右2的匹配要求只需权重大于等于0.8+0即可，所以左3与右2匹配！</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190702193004508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaWVzb24uYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>最后进行左4的匹配，由于左4唯一的匹配对象右3已被左2匹配，发生冲突。进行一轮加减d操作，再匹配，左四还是匹配失败。两轮以后左4期望值降为0，放弃匹配左4。</p>
<p>至此KM算法流程结束，三对目标成功匹配，甚至在左三目标预测不够准确的情况下也进行了正确匹配。可见在引入了权重之后，匹配成功率大大提高。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，O(n^4)的KM算法表现不俗，使用O(n^3)并不会很大的提高KM的运行效率</span></span><br><span class="line"><span class="comment">需要在O(1)的时间找到任意一条边，使用邻接矩阵存储更为方便</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">305</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> match[maxn],lx[maxn],ly[maxn],slack[maxn];</span><br><span class="line"><span class="type">int</span> G[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> visx[maxn],visy[maxn];</span><br><span class="line"><span class="type">int</span> n,nx,ny,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findpath</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tempDelta;</span><br><span class="line"></span><br><span class="line">    visx[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span> ; y &lt; ny ; ++y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visy[y]) <span class="keyword">continue</span>;</span><br><span class="line">        tempDelta = lx[x] + ly[y] - G[x][y];</span><br><span class="line">        <span class="keyword">if</span>(tempDelta ==  <span class="number">0</span>)&#123;<span class="comment">//(x,y)在相等子图中</span></span><br><span class="line">            visy[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[y] == <span class="number">-1</span> || <span class="built_in">findpath</span>(match[y]))&#123;</span><br><span class="line">                match[y] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(slack[y] &gt; tempDelta)</span><br><span class="line">            slack[y] = tempDelta;<span class="comment">//(x,y)不在相等子图中且y不在交错树中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span> ; x &lt; nx ; ++x)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; ny ; ++j) slack[j] = INF;<span class="comment">//这里不要忘了，每次换新的x结点都要初始化slack</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(visx,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visx));</span><br><span class="line">            <span class="built_in">memset</span>(visy,<span class="literal">false</span>,<span class="built_in">sizeof</span>(visy));<span class="comment">//这两个初始化必须放在这里,因此每次findpath()都要更新</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findpath</span>(x)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> delta = INF;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; ny ; ++j)<span class="comment">//因为dfs(x)失败了所以x一定在交错树中，y不在交错树中，第二类边</span></span><br><span class="line">                    <span class="keyword">if</span>(!visy[j] &amp;&amp; delta &gt; slack[j])</span><br><span class="line">                        delta = slack[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nx ; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(visx[i]) lx[i] -= delta;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; ny ; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visy[j])</span><br><span class="line">                        ly[j] += delta;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        slack[j] -= delta;</span><br><span class="line">                    <span class="comment">//修改顶标后，要把所有的slack值都减去delta</span></span><br><span class="line">                    <span class="comment">//这是因为lx[i] 减小了delta</span></span><br><span class="line">                    <span class="comment">//slack[j] = min(lx[i] + ly[j] -w[i][j]) --j不属于交错树--也需要减少delta，第二类边</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="built_in">sizeof</span>(match));</span><br><span class="line">   <span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="built_in">sizeof</span>(ly));</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nx ; ++i)&#123;</span><br><span class="line">        lx[i] = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; ny ; ++j)</span><br><span class="line">            <span class="keyword">if</span>(lx[i] &lt; G[i][j])</span><br><span class="line">                lx[i] = G[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">KM</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) != EOF)&#123;</span><br><span class="line">        nx = ny = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nx ; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; ny ; ++j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;G[i][j]);</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; ny ; ++i)</span><br><span class="line">            <span class="keyword">if</span>(match[i] != <span class="number">-1</span>)</span><br><span class="line">                ans += G[match[i]][i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/40/problem/HDU-4751">Divide Groups - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> color[maxn];</span><br><span class="line"><span class="type">int</span> R[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	  color[v]=c;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;edge[v].<span class="built_in">size</span>();i++)&#123;<span class="comment">//遍历v点所能到达的点</span></span><br><span class="line">	  	   <span class="keyword">if</span>(color[edge[v][i]]==c)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果被染为一样的就false</span></span><br><span class="line">	  	   <span class="keyword">if</span>(color[edge[v][i]]==<span class="number">0</span>&amp;&amp;!<span class="built_in">dfs</span>(edge[v][i],-c))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果没有颜色，那么看一下一点是否满足条件</span></span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果都OK，就返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="built_in">sizeof</span>(color));<span class="comment">//注意每次更新</span></span><br><span class="line">		<span class="built_in">memset</span>(R,<span class="number">0</span>,<span class="built_in">sizeof</span>(R));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)edge[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			 <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)&amp;&amp;a)&#123;</span><br><span class="line">			 	R[i][a]=<span class="number">1</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			  	<span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">			  	  <span class="keyword">if</span>(R[i][j]==<span class="number">0</span>)&#123;<span class="comment">//建立无向图,因为i不认识j所以根据图应该是建立双向的</span></span><br><span class="line">			  	  	    edge[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">			  	  	    edge[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">					&#125;</span><br><span class="line">			  &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//遍历所有连通块</span></span><br><span class="line">			<span class="keyword">if</span>(color[i]==<span class="number">0</span>)&#123;</span><br><span class="line">		     	<span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))&#123;</span><br><span class="line">				<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);f=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		   &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	   <span class="keyword">if</span>(!f)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>​    举个例子，你要去一个水果摊拿水果，每种水果都有对应的两种属性：占用的体积V和蕴含的价值W。而你的背包体积为N。老板说：每种水果只能拿一个！因此对于咱们肯定得想一种搭配方式使得拿的水果总体积不超过背包容积，但是价值总和达到最大！</p>
<p><img data-src="https://img-blog.csdnimg.cn/cb8d227add3a45a985ee6441e76ce38c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYW5pZW9v,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p> f[i][j]:表示所有选法集合中,只从前i个物品中选,并且总体积不大于j的选法的集合,它的值是这个集合中每一个选法的最大值。</p>
<pre><code>    对于01背包问题选择方法的集合可以分成2种：
</code></pre>
<p>①不选第i个物品，并且总体积不大于j的集合所达到的最大值:f[i-1][j]<br>②选择1~i个物品，并且总体积不大于j的集合所达到的最大值f[i][j]</p>
<pre><code>    对于第二种情况我们很难计算，因此需要思考从另一个角度解决问题。当选择1~i个物品，总体积不大于j的集合的最大值可以转化成选择1~i-1个物品，总体积不大于j-V[i]的集合+最后一个物品的价值：f[i-1][j-V[i]]+w[i]
</code></pre>
<p>因此总结：f[i][j]&#x3D; Max{f[i-1][j],f[i-1][j-v[i]]+w[i]}!!!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">35000</span>]; <span class="comment">//dp</span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">35000</span>];</span><br><span class="line"><span class="type">int</span> value[<span class="number">35000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n;<span class="comment">//物品个数</span></span><br><span class="line">    cin &gt;&gt; m;<span class="comment">//背包容量 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m; j&gt;=weight[i]; j--)&#123;</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么一维情况下枚举背包容量需要逆序？<br>        在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p>
<pre><code>    例如，一维状态第i轮对体积为 3 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。
</code></pre>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><a href="https://blog.csdn.net/weixin_46503238/article/details/115096267?ops_request_misc=%7B%22request_id%22:%22165928337316782395376522%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165928337316782395376522&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-115096267-null-null.nonecase&utm_term=%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85&spm=1018.2226.3001.4450">(完全背包问题(详细解答)_曼切斯特的流氓的博客-CSDN博客_完全背包</a></p>
<p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是v[i]，价值是val[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>从定义中可以看出,与01背包的区别01背包最多只能拿一件物品,完全背包则不然,只要空间够多,一种物品我可以拿n件!</p>
<p>01背包的状态转移方程为:dp(i,j)&#x3D;max(dp(i-1,j),dp(i-1,j-v[i])+val[i])<br>完全背包的状态转移方程:dp(i,j)&#x3D;max(dp(i-1,j),dp(i,j-v)+val[i])</p>
<p>我们可以看出,完全背包的动态转移方程max中第二项为i,而不是i-1。</p>
<p>为什么呢?</p>
<p>我们用01背包的思想去推导,完全背包的动态转移方程<br>首先完全背包问题的动态转移方程可写为<br>(w为val[i]简写)(v&#x3D;v[i]简写)</p>
<p>dp(i,j)&#x3D;max(dp(i-1,j) , dp(i-1,j-v)+w , dp(i-1,j-2v)+2w , dp(i-1,j-3v)+3w,<br>~~(以此类推到k) ,dp(i-1,j-k*v+kw))</p>
<p>我简单解释一下上面的方程,其实就是利用01背包思想,要求无限个物品,实际上我最多能装V&#x2F;v[i]个 (总体积除以的单个个体积),所以我从装0个,到装一个,2个,3个,k个这里面一定有其中一个,是能产生最大的价值!</p>
<p>然后我们利用上述公式推导出”完全背包的状态转移方程”</p>
<p>开始推导<br>(时刻注意与这个方程的联系)</p>
<p>dp(i,j)&#x3D;max(dp(i-1,j) , dp(i-1,j-v)+w , dp(i-1,j-2v)+2w , dp(i-1,j-3v)+3w,<br>~~(以此类推到k) ,dp(i-1,j-k*v+kw))</p>
<p>推导开始</p>
<p>还是利用01背包思想<br>dp(i,j-v)&#x3D;max( dp(i-1,j-v) , dp(i-1,j-2v)+w,dp(i-1,j-3v)+2w , dp(i-1,j-4v)+3w,~~<br>~依次类推到k , dp(i-1,j-kv)+(k-1)w) )</p>
<p>我们在这个方程两侧同时加上w,即可得到</p>
<p>dp(i,j-v)+w&#x3D;max( dp(i-1,j-v)+w , dp(i-1,j-2v)+2w,dp(i-1,j-3v)+3w , dp(i-1,j-4v)+4w,~~dp(i-1,j-kv)+kw)</p>
<p>我们在回顾一下这个方程</p>
<p>dp(i,j)&#x3D;max(dp(i-1,j) , dp(i-1,j-v)+w , dp(i-1,j-2v)+2w , dp(i-1,j-3v)+3w,<br>~~(以此类推到k) dp(i-1,j-k*v)+kw))</p>
<p>可以发现dp(i,j-v)+w可以替代</p>
<p>dp(i-1,j-v)+w , dp(i-1,j-2v)+2w , dp(i-1,j-3v)+3w,~~, dp(i-1,j-k*v)+kw</p>
<p>所以我们得出<br>完全背包的状态转移方程:dp(i,j)&#x3D;max(dp(i-1,j),dp(i,j-v)+w)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">35000</span>]; <span class="comment">//dp </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">35000</span>];</span><br><span class="line"><span class="type">int</span> value[<span class="number">35000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">    	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    		cin &gt;&gt; value[i] &gt;&gt; weight[i] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=weight[i]; j&lt;=m; j++)&#123;</span><br><span class="line">                f[j]=<span class="built_in">max</span>(f[j],f[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img-blog.csdnimg.cn/b63fa4e67e9a4c1ea947614fa24e707a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pu85YiH5pav54m555qE5rWB5rCT,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我从代码的角度阐释一下这个问题!<br>注意我们现在并没有对dp数组进行降维!<br>我们的j是从0开始的,依次递增这个是完全背包的关键,也是与01背包本质的区别<br>dp[i][j]&#x3D;max(dp[i-1][j],dp[i][j-v[i]]+val[i]);<br>首先要满足完全背包的动态转移方程,就要先知道dp(i,j-v)的大小<br>正好我们是从0开始的,并不是从后往前,也就是当求到dp(i,j)时<br>dp(i,j-v),在前面已经求过!!!<br>所以我们可以应当理顺的求出dp(i,j)而不再是向01背包要考虑前i-1时候的状态!</p>
<p>完全背包的优化<br>然后我们根据01背包的优化原则对,完全背包进行优化!<br>优化后的动态方程<br>dp[j]&#x3D;max(dp[j],dp[j-v]+w)</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://blog.csdn.net/windfriendc/article/details/123892024?ops_request_misc=%7B%22request_id%22:%22165928349916781683917641%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165928349916781683917641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_click~default-2-123892024-null-null.nonecase&utm_term=%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85&spm=1018.2226.3001.4450"> 多重背包问题—超详细讲解+优化（不懂你揍我）_与风做友的博客-CSDN博客_多重背包问题</a></p>
<p><img data-src="https://img-blog.csdnimg.cn/90c0aab825ad450e90bd6760b67783bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO6aOO5YGa5Y-L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>多重背包我们其实可以看成为01背包和完全背包的组合。也可以把多重背包问题只转换成01背包问题，我们一起来看看解题思路。</p>
<p>1.状态表示<br>DP问题我们先来看状态表示,</p>
<p>二维数组的表示，F[i][j]代表到 i 个物品时，当前背包容量为 j 时所能拿到的最大价值。非常容易理解，我们主要考虑一下优化，用一维数组来表示，则用 F [j] 代表当前背包容量为 j时所能拿到的最大价值。第i个物体的体积为v[i]，价值为 w [i]。</p>
<p>然后我们就看如何把多重背包转换成01背包与完全背包。</p>
<p>当然，01背包和完全背包转移方程都是</p>
<p>F [j]&#x3D;max(F [j], F [ j- v [i] ]+ w [i])</p>
<p>2.转换<br>（1）转换为01背包</p>
<p>我们知道，01背包问题指的是各个物品只有一件，但在多重背包问题中，我们每种物品有 Si 件。</p>
<p>我们可以考虑将多个同种物品合成一件物品。比如，我们有10件t恤，一件占空间2，每件价值20元，我们将8件t恤合在一起，就变成了一件1占空间为16的价值160元的t恤。如此一来，多重背包问题就被我们转换为01背包问题啦。</p>
<p>换一种更为简单的说法，我们本身的问题就是不知道一种占用空间 Vi ，价值为 Wi，数量为 Si 的物品该拿多少件，我们就把该拿多少件枚举一下，假设为 k件（1&lt;&#x3D;k&lt;&#x3D;Si） ，然后我们就把问题看成仅有一件的占用空间k<em>Vi ，价值为k</em>Wi的物品该不该拿。这么说就应该很容易理解了，然后我们要做的就是，在判断这个k件物品合成的 大物件该不该拿之前，先枚举 k 的大小就可以了。</p>
<p>（2）小优化，转化为01+完全背包</p>
<p>前面我们是把所有物品全部转化成01背包来做，但是我们想一想，是不是有的物品可以转化成完全背包呢？</p>
<p>完全背包问题是每件物品全部是无限件。我们这里有无限拿的物品吗？我们可以想想，总的背包体积就是 V ，是已经确定了的，如果我们有一种物品占用体积为 v，共有 s 件，但s*v &gt;&#x3D;V，不就代表着我们连 s 件物品都不可能拿完背包就已经塞不下了吗？所以这种情况我们可以转换成完全背包来做，只需要加一个判断就可以了。</p>
<p>为什么要转换成完全背包？我们看上面转化成01背包是需要枚举一下拿多少件的，而转化为完全背包是不需要枚举多少件的，可以拿我们就拿，所以在时间上会有一些优化。</p>
<p>3.优化<br>（1）二进制优化</p>
<p>我们想如果我想要拿512件物品，按照转化成01背包的方法做，我们是需要从拿1件枚举到拿512件的，而二进制优化也就带了那么点倍增思想，我们把拿多少件物品分为拿1   2   4   8  16  …  256  512 … 2^n 件，我们枚举的时候就枚举9次 就到了512件了。还有无论是多少件，我们总能用一些数的组合来表示，比如7 就可以用 1 + 2 + 4来表示，只需要枚举3次。这就是我们二进制优化的思想。</p>
<p>举一个简单的例子，一看你们肯定就明白了</p>
<p>第 i 种物品  我们有 10 个 ，占用空间 v，价值为 w</p>
<p>那么我们用二进制怎么表示这个10呢  10 &#x3D; 1 + 2 + 4 + 3。为什么这么表示？而不是 8 + 2 ？看一眼代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k&lt;=s)<span class="comment">//实现1  2  4  8件原物品  合成为新物品 </span></span><br><span class="line">&#123;</span><br><span class="line">	v[++cnt]=k*a;</span><br><span class="line">	w[cnt]=k*b;</span><br><span class="line">	s-=k;</span><br><span class="line">	k*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s)</span><br><span class="line">&#123;</span><br><span class="line">	v[++cnt]=s*a;</span><br><span class="line">	w[cnt]=s*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为如果是8+2件的话，我们如果仅仅想拿5件，就无法表示了</p>
<p>我们把这10个单独的物品，经过处理  就分成了</p>
<p>1件 价值w体积v的物品    1件 价值2w体积2v的物品   一件 价值3w体积3v的物品和一件 价值4w体积4v的物品</p>
<p>共四个新物品，每个物品仅有一件，这样就可以表示1-10内所有的数啦</p>
<p>剩下的 聪明的你看代码肯定秒懂~~~~</p>
<p>（2）单调队列优化</p>
<p>单调队列的优化是比较难想的，我们的思想是对拿多少件物品分类。那么怎么分类呢？设 V 为背包体积，v 为第 i 种物品占用空间体积，无论拿多少件这种物品，最后的最后，枚举完所有物品后背包剩余体积是一定小于每种物品体积的，如果大于等于，那么一定还可以再装，这与最高价值矛盾。所以我们就根据剩余体积来给分类。</p>
<p>假设第 i 种物品占用体积为 v ，价值为 w，我们枚举装完物体后剩余体积为0,1,2,3,4,5…，v-1；不可能剩余v 那么就可以再装一个本种物品了。怎么枚举呢？下面有代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,w,s;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;v;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=V;k+=v)</span><br></pre></td></tr></table></figure>


<p>最外面一层循环用 i 枚举第 i 个物品，j 枚举哪一组，k枚举组别里面的不同个体。</p>
<p>f [0]     f [v]       f [2<em>v]        … f [k</em>v]</p>
<p>f [1]    f [1+v]   f [1+2<em>v]    … f [1+k</em>v]</p>
<p>f [2]    f [2+v]   f [2+2<em>v]    … f [2+k</em>v]</p>
<p>……</p>
<p>f [j]      f [j+v]    f [j+2<em>v]    … f [j+k</em>v]</p>
<p>通过这种表示，我们可以看出已经可以把背包容量的各个状态表示出来。</p>
<p>所以我们的最优解是{   f [j], f [j+v], f [j+2<em>v], f [j+3</em>v], … , f [j+k*v]   } 中的最大值。</p>
<p>我们就可以把这个问题分成 j 类，每一类通过一个单调队列维护，就成为了 j 个单调队列的问题。</p>
<p>拿第 j 个单调队列来看：</p>
<p>f [j] &#x3D; f [j]</p>
<p>f [j+v] &#x3D; max(f [j] + w ,f [j+v] )</p>
<p>f [j+2<em>v] &#x3D; max(f [j]+ 2</em>w, f [j+v] + w, f [j+2*v])</p>
<p>f [j+3<em>v] &#x3D; max(f [j]+ 3</em>w, f [j+v] +2<em>w, f [j+2</em>v] + w , f[j+3*v] )</p>
<p>……</p>
<p>f [j+k<em>v] &#x3D; max( f [j]+k</em>w, f[j+v] + (k-1)<em>w,…, f [j+k</em>v] )</p>
<p>这样并不利于我们表示，我们稍微转化一下</p>
<p>f [j] &#x3D; f [j]</p>
<p>f [j+v] &#x3D; max(f [j] ,f [j+v] - w) + w</p>
<p>f [j+2<em>v] &#x3D; max(f [j], f [j+v] - w, f [j+2</em>v] - 2<em>w) + 2</em>w</p>
<p>f [j+3<em>v] &#x3D; max(f [j], f [j+v] - w, f [j+2</em>v] - 2w , f [j+3<em>v] - 3</em>w) +3*w</p>
<p>……</p>
<p>f [j+k<em>v] &#x3D; max( f [j], f[j+v] - w,…, f [j+k</em>v] - k<em>w) + k</em>w</p>
<p>如此看来，我们每次入队列 f [j+k<em>v] - k</em>w ，维护其中的最大值就可以了。</p>
<p>看一下入队操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=j;t&lt;=V;t+=v)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(hh&lt;=tt&amp;&amp;t-s*v&gt;q[hh]) hh++;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt&amp;&amp;pre[q[tt]]-(q[tt]-j)/v*w &lt;= pre[t]-(t-j)/v*w) tt--;</span><br><span class="line">    <span class="keyword">if</span>(hh&lt;=tt) f[t]=<span class="built_in">max</span>(f[t],pre[q[hh]]+(t-q[hh])/v*w);</span><br><span class="line">	q[++tt] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>q数组中保存了上述写的 当 f [j+k<em>v] - k</em>w 最大时的下标，入队前如果队首不在滑动窗口内，队首出队，每次入队元素如果比队列中元素大，就弹出队尾。</p>
<p>pre数组记录前一类 f 数组的状态，代码中我们直接用 t 表示了上述过程的 j+k*v。</p>
<p>所以知道到底k是多少，需要用  ( t - j )&#x2F;v 得出。</p>
<p>最后呢  我们知道  f [t] &#x3D;max(f [t], pre[(maxt)] -(maxt-j)*w + (t-j)*w)</p>
<p>即 f [t] &#x3D;max(f [t], pre[(maxt)] +(t-maxt)*w)，这就是我们每次的比较值。</p>
<p>接下来是代码环节：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转化为01和完全背包</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,V;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],s[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]*v[i]&gt;=V)<span class="comment">//转化为完全背包 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=V;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				f[j]=<span class="built_in">max</span>(f[j-v[i]]+w[i],f[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//转化为 01背包 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=s[i];k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">					<span class="keyword">if</span>(j&gt;=k*v[i])</span><br><span class="line">						f[j]=<span class="built_in">max</span>(f[j-k*v[i]]+k*w[i],f[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[V];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//二进制优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n,V;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//记录新的物体数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,s;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k&lt;=s)<span class="comment">//实现1  2  4  8件原物品  合成为新物品 </span></span><br><span class="line">		&#123;</span><br><span class="line">			v[++cnt]=k*a;</span><br><span class="line">			w[cnt]=k*b;</span><br><span class="line">			s-=k;</span><br><span class="line">			k*=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s)</span><br><span class="line">		&#123;</span><br><span class="line">			v[++cnt]=s*a;</span><br><span class="line">			w[cnt]=s*b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)<span class="comment">//01背包 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">		&#123;</span><br><span class="line">			f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[V];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//单调队列优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,f[MAXN],q[MAXN],pre[MAXN]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,V;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,v,w,s;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">		<span class="built_in">memcpy</span>(pre,f,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;v;j++)<span class="comment">//j个单调队列 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=j;t&lt;=V;t+=v)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(hh&lt;=tt&amp;&amp;t-s*v&gt;q[hh]) hh++;</span><br><span class="line">				<span class="keyword">while</span>(hh&lt;=tt&amp;&amp;pre[q[tt]]-(q[tt]-j)/v*w &lt;= pre[t]-(t-j)/v*w) tt--;</span><br><span class="line">				<span class="keyword">if</span>(hh&lt;=tt) f[t]=<span class="built_in">max</span>(f[t],pre[q[hh]]+(t-q[hh])/v*w);</span><br><span class="line">				q[++tt] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[V];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性动规——LIS-LCS"><a href="#线性动规——LIS-LCS" class="headerlink" title="线性动规——LIS &amp;&amp; LCS"></a>线性动规——LIS &amp;&amp; LCS</h2><p>[<a href="https://blog.csdn.net/weixin_44735997/article/details/105791139?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-105791139-blog-114671129.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4">week10]LIS&amp;LCS —— 动态规划（线性型&#x2F;坐标型）_天翊藉君的博客-CSDN博客</a></p>
<p>题意<br>东东有两个序列A和B。</p>
<p>他想要知道序列A的LIS和序列AB的LCS的长度。</p>
<p>注意，LIS为严格递增的，即a1&lt;a2&lt;…&lt;ak(ai&lt;&#x3D;1,000,000,000)。</p>
<p>Input<br>第一行两个数n，m（1&lt;&#x3D;n&lt;&#x3D;5,000,1&lt;&#x3D;m&lt;&#x3D;5,000）<br>第二行n个数，表示序列A<br>第三行m个数，表示序列B</p>
<p>Output<br>输出一行数据ans1和ans2，分别代表序列A的LIS和序列AB的LCS的长度</p>
<p>输入样例<br>5 5<br>1 3 2 5 4<br>2 4 3 1 5</p>
<p>输出样例<br>3 2<br>该算法和贪心算法、分而治之之间具有相似性，相似之处在于将一个问题分解为子问题，但是这三个算法并不完全相同。</p>
<p>动态规划就是将待解决的问题分解成多个子问题，通过多个子问题的解之间的联系进行组合，进而得到问题的解。因此，动态规划中分解出来的每个子问题之间并不是独立的，而是相互关联，含有公共子问题。</p>
<h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><p>LIS是指最长上升子序列，意思是在一个无序序列中符合严格递增的子序列中最大的长度。此处子序列并不要求是一段在原序列中的连续序列。</p>
<p>由于序列是无序的，因此我们在求解过程中无法保证当前扫描到的数字之前的子序列中任意数字与其的大小关系。但是显然，如果当前扫描数字就是我们所求子序列中的最后一个数字，那么在此之前的序列中一定包含着比它小的数字。</p>
<p>也就是说以当前这个数字为最大数的最大序列长度一定是在它之前所有比它小且升序排列的子序列长度+1。</p>
<p>因此，我们可以用一个数组来记录序列中以当前扫描位置处数字为最大数的最大序列长度。对整个序列进行一次从左至右的扫描。当前扫描数字所对应的序列长度一定是在它之前所有比它小的数字中记录序列长度最大的一个+1。</p>
<p>复杂度：O（n^2）</p>
<ol>
<li>LIS的优化问题</li>
</ol>
<p>这次的题目主要问题在于理解动态规划算法的基本解题思路。因此代码并没有太大量和太大难度。</p>
<p>但是在我试图优化LIS的解题方法时遇到了问题。我的思路是：</p>
<p>将当前已经得到的所有答案有序存储，因为当前得到的所有答案所对应的数字一定是在序列中位于当前待求数字之前的，因此可以直接对这些答案进行遍历。从最大的答案进行遍历，若当前答案对应序列中的数字小于当前待求数字即为合法。将第一个遍历到的合法答案+1即为当前待求数字的答案。</p>
<p>由于如果只用一个stl实现的最大堆来实现，每次在将不合法答案弹出后，都需要将其在之后重新压入，降低性能，因此我选择用一个数组来进行存储，每次压入答案后重新进行排序。</p>
<p>由于答案与其对应的数字没有直接的关联，因此仅仅存储答案是无法在遍历过程中进行判断的，所以我用了一个pair数组来存储答案和其对应数字在序列中的位置标号，排序时仅根据答案进行排序。</p>
<p>我到后面并没有调试出来问题，所以目前还不太清楚为什么会wa。</p>
<p>不过这个优化的思想是为了优化对每个数字依次遍历在其之前的所有数字这一步骤。因为在这一过程中，可能有多个符合要求的数字，而我们只需要其中记录答案最大的一个，所以如果利用数据结构进行优化，就能将复杂度优化到logn。从而将整个算法的复杂度优化的O(nlogn）。</p>
<ol start="2">
<li>LCS答案数组的初始化</li>
</ol>
<p>通过之前的分析就知道，在求解过程中，需要知道每个数组位置的左上方、右方和上方位置存储的答案。因此如果不首先将所有数组空间初始化为0，在求解过程中一定会出现问题，比如第一行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  lab2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5010</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">5010</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>,m = <span class="number">0</span>,x = <span class="number">0</span>,y = <span class="number">0</span>,ans1 = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> lis[<span class="number">5010</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        a[i] = x;</span><br><span class="line">        lis[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;y;</span><br><span class="line">        b[i] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )      <span class="comment">//遍历所有数字，找到以当前数字为最大数的序列长度</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; i ; j++ )  <span class="comment">//遍历之前的所有数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( a[j] &lt; a[i] )  <span class="comment">//若符合要求，进行更新，当且仅当新答案更大时更新</span></span><br><span class="line">                lis[i] = <span class="built_in">max</span>(lis[i],lis[j]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( lis[i] &gt; ans1 )             <span class="comment">//记录最大值</span></span><br><span class="line">            ans1 = lis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="type">int</span> lcs[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(lcs, <span class="number">0</span>, <span class="built_in">sizeof</span>(lcs));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++ )      <span class="comment">//对a中每个数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span> ; j &lt; m ; j++ )      <span class="comment">//遍历整个b</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若当前两个数字相等，序列长度比矩阵中记录的斜上方+1</span></span><br><span class="line">            <span class="comment">//因为左上方代表的序列正好是没有当前相等的两个数字的ab序列的lcs长度</span></span><br><span class="line">            <span class="comment">//b中一个数字在a序列中最多只会出现一次</span></span><br><span class="line">            <span class="keyword">if</span>( b[j] == a[i] )</span><br><span class="line">                lcs[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">max</span>(lcs[i][j] + <span class="number">1</span>,lcs[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>                                      <span class="comment">//否则就是其左边或上边存储的最大值</span></span><br><span class="line">                lcs[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">max</span>(lcs[i][j + <span class="number">1</span>],lcs[i + <span class="number">1</span>][j]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;lcs[n][m]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/42/problem/5818">导弹拦截 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[maxn];</span><br><span class="line"><span class="type">int</span> hh[maxn];<span class="comment">//反向 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis_h</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">upper_bound</span>(low.<span class="built_in">begin</span>(), low.<span class="built_in">end</span>(), h[i]);</span><br><span class="line">        <span class="keyword">if</span> (pos == low.<span class="built_in">end</span>())</span><br><span class="line">            low.<span class="built_in">push_back</span>(h[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *pos = h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; low.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis_n</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">lower_bound</span>(low.<span class="built_in">begin</span>(), low.<span class="built_in">end</span>(), hh[i]);</span><br><span class="line">        <span class="keyword">if</span> (pos == low.<span class="built_in">end</span>())</span><br><span class="line">            low.<span class="built_in">push_back</span>(hh[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *pos = hh[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; low.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> high;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; high)&#123;</span><br><span class="line">		hh[++n]=high;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		h[i]=hh[n-i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lis_h</span>(n);</span><br><span class="line">	<span class="built_in">lis_n</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。<br>基本思想与策略编辑:<br>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。首先我们很容易想到暴力：需要遍历出所有的可能，时间复杂度是O(n³)，你交一个信不信T飞到天上<br>所以我们要用动态规划去做</p>
<p>①最优子结构<br>设 X&#x3D;(x1,x2,…xn) 和 Y&#x3D;{y1,y2,…ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)<br>找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p>
<p>(1) 如果 xn&#x3D;ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)<br>LCS(Xn-1，Ym-1)就是原问题的一个子问题。同时也是最优子问题</p>
<p>(2) 如果xn!&#x3D;ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)<br>因为序列X 和 序列Y 的最后一个元素不相等，就说明最后一个元素不可能是最长公共子序列中的元素。</p>
<p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,…x(n-1)) 和 (y1,y2,…yn)中找。<br>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,…xn) 和 (y1,y2,…y(n-1))中找。</p>
<p>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：<br>LCS&#x3D;max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p>
<p>由于条件（1）和 (2) 考虑到了所有可能的情况。因此，我们成功地把原问题转化成了三个规模更小的子问题。</p>
<p>②重叠子问题<br>重叠子问题就是说原问题转化成子问题后， 子问题中有相同的问题。<br>我们来看看<br>原问题是：LCS(X,Y)。子问题有 LCS(Xn-1，Ym-1) ，LCS(Xn-1，Ym) ，LCS(Xn，Ym-1)</p>
<p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p>
<p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题LCS(Xn-1，Ym-1)<br>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解成：<br>LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p>
<p>也就是说：在子问题的继续分解中，有些问题是重叠的。</p>
<p>由于像LCS这样的问题，它具有重叠子问题的性质，因此：用递归来求解就太不划算了。</p>
<p>那么问题来了，该怎么将时间复杂度降下来呢？</p>
<p>动态规划！因为我们用动态规划解决时并不需要去一一计算那些重叠了的子问题。或者说：用了动态规划之后，有些子问题是通过 “查表“ 直接得到的，而不是重新又计算一遍得到的。<br>说了这么多，还是要写下最长公共子序列的递归式才完整。<br><img data-src="https://img-blog.csdnimg.cn/img_convert/3b2c47c9dc6d8412823c7198e0bd114e.png#pic_center" alt="在这里插入图片描述"></p>
<p>c[i,j]表示：(x1,x2…xi) 和 (y1,y2…yj) 的最长公共子序列的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">9900</span>][<span class="number">9900</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">110000</span>],b[<span class="number">110000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="type">int</span> n2=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)f[i][j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(f[n][n2])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[n][n2]==f[n<span class="number">-1</span>][n2])n--;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(f[n][n2]==f[n][n2<span class="number">-1</span>])n2--;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			k++;</span><br><span class="line">			n--,n2--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间dp-树形dp"><a href="#区间dp-树形dp" class="headerlink" title="区间dp&amp;&amp;树形dp"></a>区间dp&amp;&amp;树形dp</h2><p>定义1 对于图G&#x3D;(V,E)来说， 最小支配集 指的是从V中取尽量少的点组成一个集合，使得对于V中剩余的点都与取出来的点有边相连。也就是说，设V‘是图G的一个支配集，则对于图中的任意一个顶点u，要么属于集合V’，要么与V‘中的顶点相邻。在V’中出去任何元素后V‘不再是支配集，则支配集是极小支配集。称G的所有支配集中顶点个数最少的支配集为最小支配集，最小支配集中顶点的个数称为支配数。</p>
<p>定义2 对于图G&#x3D;(V,E)来说， 最小点覆盖 指的是从V中取尽量少的点组成一个集合，使得E中所有的边都与取出来的点相连。也就是说，设V‘是图G的一个顶点覆盖，则对于图中的任意一条边(u,v)，要么u属于集合V’，要么v属于集合V‘。在V‘中除去任何元素后V’不在是顶点覆盖，则V‘是极小顶点覆盖。称G的所有顶点覆盖中顶点个数最少的覆盖为最小点覆盖。</p>
<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><p><a href="https://www.bilibili.com/video/BV1AA411e7c2?spm_id_from=333.337.search-card.all.click&vd_source=55a817e1cd12db431b996e11d76cacfd">区间DP-石子合并问题_哔哩哔哩_bilibili</a></p>
<p>例题:石子归并。</p>
<p>　　描述 有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，并将新的一堆石子数记为该次合并的得分。</p>
<p>　　给组测试数据 </p>
<p>　　　　　输入　　　4　　　　表示有4堆石子</p>
<p>　　　　　  4 4 5 9　　表示每堆石子的个数</p>
<p>　　　　　输出  54         表示最大的得分　　　</p>
<p>　　分析:主要思想就是一个一个累加：4 4 5 9 先看下去是我想知道dp[i][j]的最大值，i表示起始位置，j表示终止位置，所以我肯定是想求出dp[1][4]间的最大值但是我从1到4可是如图这三种截取方法，所以我先从小的开始记录。</p>
<p>dp[1][1]&#x3D;4;dp[2][2]&#x3D;4;dp[3][3]&#x3D;5;dp[4][4]&#x3D;9。然后我在长度为2的时候记录，dp[1][2]&#x3D;4+4&#x3D;8,dp[2][3]&#x3D;8+5&#x3D;14;dp[3][4]&#x3D;14+9&#x3D;23;这样加起来的值就是8+14+23&#x3D;45；但是如果我反过来呢？dp[1][2]&#x3D;5+9&#x3D;14;dp[2][3]&#x3D;14+4&#x3D;18;dp[3][4]&#x3D;18+4&#x3D;22;这样加起来的值就是14+18+22&#x3D;54。很明显，54就是所求的最大值。<br><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNjQ5MTUzLzIwMTQxMi8xMzE1NDYyMTA0MDQ1MzkucG5n" alt="img"></p>
<p><img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMwLmNuYmxvZ3MuY29tL2Jsb2cvNjQ5MTUzLzIwMTQxMi8xMzE2MDUyNzMzNzg0MDUucG5n" alt="img"></p>
<p>如图，如果我相求圈着的这个三个的值，我完全可以有图上这两种分割，并且分割出来的值是已经知道的了。</p>
<p>动态规划的思想：先两两合并，在三三合并，最后再NN合并，在合并过程中，较大的区间可以拆分成已经的小区间进行计算，省时又省力。比如，我可以在三三合并的时候可以拆分成一一还有二三相加。即把当前阶段的合并方法细分成前一阶段已计算出的方法，选择其中的最优方案。</p>
<p>具体来说我们应该定义一个数组dp[i,j]用来表示合并方法，i表示从编号为i的石头开始合并，j表示所求区间的结尾，sum表示的是石头的数量。</p>
<p>对于上面的例子来说，</p>
<p>　　 第一阶段：dp[1][1],dp[2][2],dp[3][3],dp[4][4] 因为一开始还没有合并，所以这些值应该全部为0。</p>
<p> 　　 第二阶段：两两合并过程如下，其中sum(i,j)表示石头的数量，即从i开始数j个数的和</p>
<pre><code>          dp[1,2]=dp[1,1]+dp[2,2]+sum[1,2];
</code></pre>
<p>　　　　dp[2,3]&#x3D;dp[2,2]+dp[3,3]+sum[2,3];</p>
<p>　　　　dp[3,4]&#x3D;dp[3,3]+dp[4,4]+sum[4,4];</p>
<pre><code>第三阶段：三三合并可以拆成两两合并，拆分方法有两种，前两个为一组或后两个为一组

 dp[1,3]=dp[1,2]+dp[3,3]+sum[1,3]或dp[1,3]=dp[1,1]+dp[2,3]+sum[1,3];取其最优
</code></pre>
<p>　dp[2,4]&#x3D;dp[2,2]+dp[3,4]+sun[2,4]或dp[2,4]&#x3D;dp[2,3]+dp[3,3]+sum[2,4];取其最优</p>
<pre><code>第四阶段：四四合并的拆分方法用三种，同理求出三种分法的得分，取其最优即可。以后第五阶段、第六阶段依次类推，最后在第六阶段中找出最优答案即可。
</code></pre>
<p>　 动态方程为dp[i][j]&#x3D;dp[i][k]+dp[k+1][j]+sum[i][j];</p>
<p>另一种：<br>一条直线上有N堆石子，现在要将所有石子合并成一堆，每次只能合并相邻的两堆，合并花费为新合成的一堆石子的数量，求最小的花费。</p>
<p>1堆，花费为0<br>2堆，花费为sum[2]<br>3堆，花费为min(a[1] + a[2], a[2] + a[3]) + sum[3]<br>如果我们有n堆，合并的最后一次操作一定是从两堆合并成一堆，</p>
<p>第一种模型就是将大区间从任意位置分成两个小区间<br>规定dp[i][j]为合并第i堆到第j堆的最小花费<br>DP方程为：<br>dp[i][j] &#x3D; min(dp[i][k] + dp[k+1][j]) + sum[j] - sum[i-1] (i &lt;&#x3D; k &lt; j)    sum[i]为前i项和</p>
<p>[P5569 <a href="https://www.luogu.com.cn/problem/P5569">SDOI2008] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[l][r]!=inf) <span class="keyword">return</span> f[l][r];</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> f[l][r]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;</span><br><span class="line">	f[l][r]=<span class="built_in">min</span>(f[l][r],<span class="built_in">dfs</span>(l,k)+<span class="built_in">dfs</span>(k+<span class="number">1</span>,r)+sum[r]-sum[l<span class="number">-1</span>]);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l][r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,inf,<span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/44/problem/POJ-3280">Cheapest Palindrome - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> w[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> add,out;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	cin &gt;&gt; add &gt;&gt; out;</span><br><span class="line">	w[c-<span class="string">&#x27;a&#x27;</span>]=<span class="built_in">min</span>(add,out);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=m;len++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==s[j]) dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> dp[i][j]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j]+w[s[i]-<span class="string">&#x27;a&#x27;</span>],dp[i][j<span class="number">-1</span>]+w[s[j]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">0</span>][m<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/44/problem/HDU-4632">Palindrome subsequence - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rush() int T;cin&gt;&gt;T;while(T--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sf(a) scanf(<span class="string">&quot;%lf\n&quot;</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sd(a) scanf(<span class="string">&quot;%d\n&quot;</span>,&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sdt(a,b) scanf(<span class="string">&quot;%d%d\n&quot;</span>,&amp;a,&amp;b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> go(a) while(cin&gt;&gt;a&amp;&amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ms(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf(a) printf(<span class="string">&quot;%.8lf&quot;</span>,a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exp 1e-8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> idata=<span class="number">2000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10007</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> maxx,minn,ans;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="type">int</span> dp[idata][idata];</span><br><span class="line"><span class="type">char</span> ch[idata];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    iostream::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">rush</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;ch+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++) dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">2</span>;u&lt;=len;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>,j=u;j&lt;=len;i++,j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//因为是子序列，所以dp[i][j],只有舍去端点才可以代表唯一的子序列</span></span><br><span class="line">                dp[i][j]=(mod+dp[i+<span class="number">1</span>][j]+dp[i][j<span class="number">-1</span>]-dp[i+<span class="number">1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">                <span class="comment">//当端点相同是，dp[i-1][j+1]中每一个子序列都可以形成一个新的，(i，j)也是一个</span></span><br><span class="line">                <span class="keyword">if</span>(ch[i]==ch[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]+=(dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                    dp[i][j]=(dp[i][j]+mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,++ans,dp[<span class="number">1</span>][len]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><p><a href="https://www.bilibili.com/video/BV1Ci4y1g7H5?spm_id_from=333.999.0.0">树形DP_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>首先我们们分析一下这道题，对于每一个人，它所做的决定对上司和下属都有影响，我们可以只看一方，也就是上司对下属的影响，因为这样的影响是相互的。</p>
<p>状态如果为f[i]表示第i个人的位置能获得最大的幸福行吗？</p>
<p>由于我们的选择具有后效性，因为你去或不去对下属有影响，那显然不行。遇到这种情况我们该怎么办？</p>
<p>#加一维</p>
<p>由于后效性实质上是我们对于状态的性质不够清楚，所以我们再加一维以实现就算你加还是不加我们都可以记录下来。所以状态其实是很好想的。想出状态后，容易推出方程为</p>
<p>dp[i][0]&#x3D;sum(max(dp[son][1],dp[son][0]));</p>
<p>显然，你不去，那下属就可以想去就去。</p>
<p>dp[i][1]&#x3D;sum(dp[son][0])+happy[i];</p>
<p>显然你去了那下属就一定不能去。</p>
<p>由此我们就可以愉快的DFS了。</p>
<p>#但是</p>
<p>如果我们的人数相当多且是一条链的时候就容易造成爆栈，那这我们有如何解决呢?方法有三</p>
<ol>
<li>开一个数组手动实现栈。</li>
<li>bfs后用for循环</li>
<li>拓扑排序</li>
</ol>
<p>第一个想必大家都会写，而且其与dfs相似，所以不再赘述。</p>
<p>那为啥会讲后两种呢？</p>
<p>因为有时候dfs并不好写，所以我们会把它转化为bfs+for或者拓扑，大家可以看一下，dfs和这两种写法的推导有的是不一样的。特别是和这题的拓扑写法，可以仔细看一下。</p>
<p>那么首先说下bfs</p>
<p>我们很容易发现树形dp它为什么一般会是dfs形式？因为树形dp的状态大多是一颗颗子树，它传递状态过程一般都是先求出最下层再往上更新。所以对于每一个点，我们在求解它的值的过程中，需要求出它每一个子节点的解。那有什么方法我们可以用数组和for循环实现这样的求解呢？没错，就是bfs过程中的<strong>队列</strong>。由于队列中的点都是先入的父亲节点后入的子节点，所以我们求解的时候只要把循环顺序反过来就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I love Remilia Scarlet forever!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> remilia int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_my_wife main</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> t64;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> happy[N], status[N][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// status[i][0] --&gt; 选i时以i为根的树的最大</span></span><br><span class="line"><span class="comment">// status[i][1] --&gt; 不选i时以i为根的树的最大</span></span><br><span class="line"><span class="type">bool</span> is_visited[N], is_root[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> current)</span> </span>&#123;</span><br><span class="line">    is_visited[current] = <span class="literal">true</span>;</span><br><span class="line">    status[current][<span class="number">1</span>] = happy[current];</span><br><span class="line">    status[current][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; e: tree[current]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> is_visited[e]) &#123;</span><br><span class="line">            is_visited[e] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不选current它的儿子都可以选</span></span><br><span class="line">            status[current][<span class="number">1</span>] += status[e][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 选current， 儿子选不选都可以</span></span><br><span class="line">            status[current][<span class="number">0</span>] += <span class="built_in">max</span>(status[e][<span class="number">1</span>], status[e][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">remilia <span class="title">is_my_wife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>) -&gt; <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; happy[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        is_root[a] = <span class="literal">true</span>;</span><br><span class="line">        tree[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">        tree[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(status[<span class="number">1</span>][<span class="number">0</span>], status[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树形DP的定义：动态规划本身就是多阶段决策问题，而树形结构具有更明显的多阶段决策性，树形dp问题的父状态和子状态对应一棵树和其所有子树，这种状态转移发生在一棵树和其所有子树之间的动态规划称为树形dp。</p>
<p>题意：有若干个结点，结点之间有路相连，构成树形结构，如果在一个结点上放置一个士兵，则与该结点相连的路就可以被监视，问：要监视所有的路，至少需要放置多少士兵？</p>
<p>每组数据第一行，给出一个整数n，然后接下来n行，每行首先以father:（cnt）的形式给出一个结点编号father和其子结点个数cnt，然后cnt个数分别代表cnt个子结点的编号。</p>
<p>思路：用树形dp，首先定义dp[i][2],用dp[i][0]和dp[i][1]分别表示在i号结点不放置士兵和放置士兵时，以i号结点为根的子树能覆盖其所有边（即：所有边都被监视）时所需的最小士兵数；</p>
<p>具体状态转移分为两类：</p>
<p>1、i号结点是叶子结点：dp[i][0]&#x3D;0,dp[i][1]&#x3D;1;</p>
<p>2、i号结点不是叶子结点：dp[i][0]&#x3D;dp[j][1]的和（j为i每个的子结点编号）</p>
<p> dp[i][1]&#x3D;min(dp[j][0],dp[j][1])的和+1；<br><a href="https://cdutetcoj.xyz/training/44/problem/POJ-1463">Strategic game - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1550</span>;</span><br><span class="line"><span class="type">int</span> n,dp[maxn][<span class="number">2</span>],pre[maxn],childCnt[maxn],root;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DpTree</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(childCnt[root]==<span class="number">0</span>)&#123;<span class="comment">//当前树根结点为叶子</span></span><br><span class="line">        dp[root][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp0=<span class="number">0</span>,dp1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//找根结点的孩子结点,往下深搜</span></span><br><span class="line">        <span class="keyword">if</span>(pre[i]==root)&#123;</span><br><span class="line">            <span class="built_in">DpTree</span>(i);</span><br><span class="line">            dp0+=dp[i][<span class="number">1</span>];<span class="comment">//在每次深搜到底后回溯时，计算以i为根的树，在当前根结点i不放士兵和放士兵时，当前树的所有边都覆盖时，所需的最小士兵数，并将其加到以root为根的两种情况（dp0和dp1）中</span></span><br><span class="line">            dp1+=<span class="built_in">min</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[root][<span class="number">0</span>]=dp0;</span><br><span class="line">    dp[root][<span class="number">1</span>]=dp1+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="comment">//    cin.tie(0);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        root=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(childCnt,<span class="number">-1</span>,<span class="built_in">sizeof</span>(childCnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> father,cnt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d:(%d)&quot;</span>,&amp;father,&amp;cnt);</span><br><span class="line">            childCnt[father]=cnt;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="number">-1</span>) root=father;<span class="comment">//首先默认第一个结点为整个树的根结点root</span></span><br><span class="line">            <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">                <span class="type">int</span> child;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;child);</span><br><span class="line">                pre[child]=father;</span><br><span class="line">                <span class="keyword">if</span>(child==root) root=father;<span class="comment">//当当前根结点为当前父结点的子结点时，更新root=当前父结点，这样不断更新维护，最后root就是整个树的根结点了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DpTree</span>(root);</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">min</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h2><p><a href="https://blog.csdn.net/weixin_43887873/article/details/122123550?ops_request_misc=%7B%22request_id%22:%22165928501316781683979749%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165928501316781683979749&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-122123550-null-null.142%5Ev35%5Epc_rank_34&utm_term=%E6%AC%A7%E6%8B%89%E5%9B%BE&spm=1018.2226.3001.4187"> 欧拉图-Hierholzer 算法_corelone2的博客-CSDN博客_hierholzer算法</a></p>
<p>应用：一笔画问题：一个点开始，一笔画完一个图。<br>欧拉图：从任意一个点开始，一笔画完一个图；<br>半欧拉图：从某一个点开始，一笔画完一个图；<br>欧拉通路：通过所有边恰好一次，且路过所有顶点的通路；<br>欧拉回路：通过所有边恰好一次，且路过所有顶点的回路；<br>欧拉图：具有欧拉回路的无向图&#x2F;有向图；<br>半欧拉图：具有欧拉通路的无向图&#x2F;有向图</p>
<ul>
<li>无向图：欧拉图中所有顶点的度数都是偶数；有向图：欧拉图中所有节点的<strong>入度和出度</strong>都相等；</li>
<li>有向图中的欧拉通路：<ul>
<li>欧拉通路的起点为入度比出度少1的节点，终点为入度比出度多1的节点，且这样的点都是唯一的；</li>
<li>任意节点开始都存在欧拉通路，那么此时也存在欧拉回路；</li>
</ul>
</li>
</ul>
<h3 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h3><ul>
<li>起点出发，进行深度优先搜索；</li>
<li>每次，从一个点沿着边到另一个点时，删除走过的边；</li>
<li>如果没有可以移动的边，则将当前节点加入到结果中，并返回。</li>
</ul>
<p>虽然，顺序的去思考时，我们不知道一个节点的哪个分支，即哪个邻接点会导致死胡同，没法继续移动，但是我们知道，只有那个入度和出度差为1的点会导致这样的结果。也就是说，对于非死胡同的节点，终将回到当前出发点。<br>可知，死胡同的点正常应该是最后走的，但是，由于我们是顺序访问的，所以遇到死胡同（没有邻居的点），就将当前节点存入结果，然后返回到上一层，最后我们会得到一个逆序的路径，所以最终我们需要对结果进行逆序。</p>
<ul>
<li>建邻接表（矩阵），入度表，出度表；</li>
<li>根据是通路还是回路判断是否需要找起始节点；</li>
<li>Hierholzer 算法找路径；</li>
<li>最后将得到的路逆序；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x];i;i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = to[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/43/problem/HDU-1878">欧拉回路 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> e[maxx][maxx];</span><br><span class="line"><span class="type">int</span> indegree[maxx];</span><br><span class="line"><span class="type">int</span> vis[maxx];</span><br><span class="line"><span class="type">int</span> outdegree[maxx];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//记录访问的顶点数</span></span><br><span class="line"><span class="type">int</span> mark;<span class="comment">//标记是否所有的顶点都是连通的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	mark=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="built_in">sizeof</span>(indegree));</span><br><span class="line">	<span class="built_in">memset</span>(outdegree,<span class="number">0</span>,<span class="built_in">sizeof</span>(outdegree));</span><br><span class="line">	<span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">if</span>(cnt==n&amp;&amp;mark==<span class="number">0</span>)&#123;</span><br><span class="line">		mark=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(e[u][i]==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="type">int</span> a,b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">			e[a][b]=e[b][a]=<span class="number">1</span>;</span><br><span class="line">			indegree[a]++;</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(indegree[i]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(mark==<span class="number">1</span>&amp;&amp;flag==<span class="number">1</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂-矩阵快速幂"><a href="#快速幂-矩阵快速幂" class="headerlink" title="快速幂&amp;&amp;矩阵快速幂"></a>快速幂&amp;&amp;矩阵快速幂</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p><a href="https://blog.csdn.net/qq_19782019/article/details/85621386?ops_request_misc=%7B%22request_id%22:%22165992513516782391816966%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165992513516782391816966&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85621386-null-null.142%5Ev39%5Epc_rank_v36,185%5Ev2%5Econtrol&utm_term=%E5%BF%AB%E9%80%9F%E5%B9%82&spm=1018.2226.3001.4187">快速幂算法（全网最详细地带你从零开始一步一步优化）_刘扬俊的博客-CSDN博客_快速幂算法</a></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190102161125415.png" alt="img"></p>
<p>暴力for:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * @param base 底数</span></span><br><span class="line"><span class="comment"> * @param power  指数</span></span><br><span class="line"><span class="comment"> * @return  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">normalPower</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base,<span class="type">long</span> <span class="type">long</span> power)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=power;i++)&#123;</span><br><span class="line">        result=result*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> base,power;</span><br><span class="line">    cin&gt;&gt;base&gt;&gt;power;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base=&quot;</span>&lt;&lt;base&lt;&lt;<span class="string">&quot; power=&quot;</span>&lt;&lt;power&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">normalPower</span>(base,power)&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常简单，but,输入样例：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190102164900548.png" alt="img"></p>
<p>输出结果居然为0！what？</p>
<p>f(x)&#x3D;a^x ， 随着x单位长度的递增，f(x)会呈“爆炸性”增长。</p>
<p>一张纸对折一次，厚度变成原来的2倍。再对折第二次，变为原来的2的2次方倍即4倍。以此类推，假设纸的厚度为0.1mm，则对折24次以后，长度超过1千米；对折39次达55000千米，超过地球赤道长度；对折42次达44万千米，超过地球至月球的距离；对折51次达22亿千米，超过地球至太阳的距离；对折82次为51113光年，超过银河系半径的长度。</p>
<p>因此，如果题目让你求2的100次方，貌似我们程序设计语言中最大的long lnog类型也无法承载这么大的数值，所以题目才不会要求你输出结果，因为结果可能会非常的大，大到没有任何类型可以承载。所以我们会发现上面的结果为什么是0，因为已经发生溢出了。</p>
<p>那为什么题目要求输出结果的最后三位数表示的整数呢？有的同学可能会问：求一个数的最后三位数表示的整数好办，只要用这个结果进行“取模”运算，让其对1000取模，得到的数就是这个数最后三位数表示的整数。（例如：12345的最后三位数表示的整数是：12345%1000&#x3D;345）。但是，你这结果都无法求出来，让我怎么进行“取模”运算呢？你这不是瞎闹吗？</p>
<p>别急，我们首先来了解一下“取模”运算的运算法则：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p （<span class="number">1</span>）</span><br><span class="line"></span><br><span class="line">(a - b) % p = (a % p - b % p ) % p （<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line">(a * b) % p = (a % p * b % p) % p （<span class="number">3</span>）</span><br></pre></td></tr></table></figure>

<p>会发现多个因子连续的乘积取模的结果等于每个因子取模后的乘积再取模的结果。也就是说，我们如果要求：</p>
<p>(a<em>b</em>c)%d&#x3D;(a%d<em>b%d</em>c%d)%d;</p>
<p>只需要在循环乘积的每一步都提前进行“取模”运算，而不是等到最后直接对结果“取模”，也能达到同样的效果。</p>
<p>所以，我们的代码可以变成这个样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的求幂函数</span></span><br><span class="line"><span class="comment"> * @param base 底数</span></span><br><span class="line"><span class="comment"> * @param power  指数</span></span><br><span class="line"><span class="comment"> * @return  求幂结果的最后3位数表示的整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">normalPower</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= power; i++) &#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">        result = result % <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result % <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> base, power;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; base &gt;&gt; power;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0</span> &amp;&amp; power == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">normalPower</span>(base, power) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能有效防止数据溢出了，但是我们来考虑一下这个算法的时间复杂度，假设我们求2的100次方，那么将会执行100次循环。如果我们分析一下这个算法，就会发现这个算法的时间复杂度为O(N),其中N为指数。</p>
<p>当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>^<span class="number">10</span>=<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尽量想办法把指数变小来，这里的指数为10</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>^<span class="number">10</span>=(<span class="number">3</span>*<span class="number">3</span>)*(<span class="number">3</span>*<span class="number">3</span>)*(<span class="number">3</span>*<span class="number">3</span>)*(<span class="number">3</span>*<span class="number">3</span>)*(<span class="number">3</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>^<span class="number">10</span>=(<span class="number">3</span>*<span class="number">3</span>)^<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>^<span class="number">10</span>=<span class="number">9</span>^<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>^<span class="number">5</span>=（<span class="number">9</span>^<span class="number">4</span>）*（<span class="number">9</span>^<span class="number">1</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>^<span class="number">5</span>=（<span class="number">81</span>^<span class="number">2</span>）*(<span class="number">9</span>^<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//把指数缩小一半，底数执行平方操作</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>^<span class="number">5</span>=（<span class="number">6561</span>^<span class="number">1</span>）*(<span class="number">9</span>^<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>^<span class="number">5</span>=（<span class="number">6561</span>^<span class="number">0</span>）*(<span class="number">9</span>^<span class="number">1</span>)*(<span class="number">6561</span>^<span class="number">1</span>)=<span class="number">1</span>*(<span class="number">9</span>^<span class="number">1</span>)*(<span class="number">6561</span>^<span class="number">1</span>)=(<span class="number">9</span>^<span class="number">1</span>)*(<span class="number">6561</span>^<span class="number">1</span>)=<span class="number">9</span>*<span class="number">6561</span>=<span class="number">59049</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;	</span><br><span class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll base,ll power)</span></span>&#123;</span><br><span class="line">	ll result=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(power&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(power%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//如果指数为偶数</span></span><br><span class="line">		power &gt;&gt;= <span class="number">1</span>;  <span class="comment">//指数缩小一半 </span></span><br><span class="line">		base = base*base%<span class="number">1000</span>;  <span class="comment">//底数变为原来的平方 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//如果指数为奇数</span></span><br><span class="line">		power=power<span class="number">-1</span>; <span class="comment">//把指数减去1，使其变成一个偶数 </span></span><br><span class="line">		result=result*base%<span class="number">1000</span>; <span class="comment">//把指数为奇数时分离出来的底数的一次方收集 </span></span><br><span class="line">		power &gt;&gt;= <span class="number">1</span>; <span class="comment">//指数变为了偶数，继续操作 </span></span><br><span class="line">		base=base*base%<span class="number">1000</span>; <span class="comment">//底数变为原来的平方 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为power是一个整数，例如当power是奇数5时,power-1&#x3D;4,power&#x2F;2&#x3D;2；而如果我们直接用power&#x2F;2&#x3D;5&#x2F;2&#x3D;2。在整型运算中得到的结果是一样的，因此，我们的代码可以压缩成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fast_Pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result = result * base % <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        power = power / <span class="number">2</span>;</span><br><span class="line">        base = (base * base) % <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> p; <span class="comment">//模 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fast_pow</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> m;</span><br><span class="line">	<span class="type">int</span> s=<span class="built_in">fast_pow</span>(m,n/<span class="number">2</span>,p);</span><br><span class="line">	<span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="keyword">return</span> m*s%p*s%p; <span class="comment">//判断奇偶，奇数返回1，等效于 n%2==1; </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> s*s%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">fast_pow</span>(m,n,<span class="number">10000</span><span class="comment">/*模*/</span>) &lt;&lt; endl; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>究极简化（二进制优化）</p>
<p>对于power&#x3D;power&#x2F;2来说，也可以用更快的“位运算”进行替代，我们只要把power的二进制表示向右移动1位就能变成原来的一半了。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190103144259337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5NzgyMDE5,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll a,ll b,llp)</span></span>&#123;</span><br><span class="line">    ll result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) result=result*a%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n,p;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt;p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fast_pow</span>(m,n,p) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/45/problem/POJ-1995">Raising Modulo Numbers - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll p,h;</span><br><span class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    ll s=a,rs=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            rs=rs%p*s%p%p;</span><br><span class="line">        &#125;</span><br><span class="line">        s=s%p*s%p%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;z);</span><br><span class="line">    <span class="keyword">while</span>(z--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;p,&amp;h);</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(h--)&#123;</span><br><span class="line">            ll a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            sum=(sum+<span class="built_in">fast_pow</span>(a,b))%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>(1)<strong>矩阵乘法</strong></p>
<p><strong>简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B&#x3D;C</strong></p>
<p><strong><img data-src="https://img-blog.csdn.net/20160728194108880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></strong></p>
<p><strong>其中c[i][j]为A的第i行与B的第j列对应乘积的和，即:<img data-src="https://img-blog.csdn.net/20160728194548574?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multi</span><span class="params">(<span class="type">int</span> a[][N],<span class="type">int</span> b[][N],<span class="type">int</span> n)</span><span class="comment">//n是矩阵大小，n&lt;N</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"> </span><br><span class="line">c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种写法:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multi</span><span class="params">(<span class="type">int</span> a[][N],<span class="type">int</span> b[][N],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"> </span><br><span class="line">c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种可以在第二重for判断if(a[i][k]&#x3D;&#x3D;0)continue;对于<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>有较多0的有一定效果。不过一般第一种写法就够了，这种知道就行。</strong></p>
<p><strong>显然矩阵乘法的复杂度是O(n^3);</strong></p>
<p><strong>n*n的矩阵(即方阵)，显然两个相乘是要一行和一列对应乘，那么矩阵乘法是需要A的行数与B的列数相等的(这是A*B的前提条件，可见矩阵的乘法是不满足交换律的)。</strong></p>
<p><strong>(1)*<em>矩阵快速幂*</em></strong></p>
<p><strong>就是算A^n;方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了</strong>*</p>
<p><strong>代码:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> tmp[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multi</span><span class="params">(<span class="type">int</span> a[][N],<span class="type">int</span> b[][N],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span> tmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line"> </span><br><span class="line">tmp[i][j]+=a[i][k]*b[k][j];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"> </span><br><span class="line">a[i][j]=tmp[i][j];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> res[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a[][N],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span> res);<span class="comment">//n是幂，N是矩阵大小</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) res[i][i]=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">multi</span>(res,a,N);<span class="comment">//res=res*a;复制直接在multi里面实现了；</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">multi</span>(a,a,N);<span class="comment">//a=a*a</span></span><br><span class="line"> </span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Mat</span></span><br><span class="line">&#123;</span><br><span class="line">    LL m[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">&#125;;<span class="comment">//存储结构体</span></span><br><span class="line">Mat a,e; <span class="comment">//a是输入的矩阵，e是输出的矩阵</span></span><br><span class="line"><span class="function">Mat <span class="title">Mul</span><span class="params">(Mat x,Mat y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            c.m[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)&#123;</span><br><span class="line">                c.m[i][j] = c.m[i][j]%mod + x.m[i][k]*y.m[k][j]%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">pow</span><span class="params">(Mat x,LL y)</span><span class="comment">//矩阵快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat ans = e;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans = <span class="built_in">Mul</span>(ans,x);</span><br><span class="line">        x = <span class="built_in">Mul</span>(x,x);</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://cdutetcoj.xyz/training/45/problem/5820">Fibonacci 前 n 项和 - CDUTETCOJ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">求斐波那契的前n项和对mod求余</span></span><br><span class="line"><span class="comment">打表可推导出s[n]=s[n-1]+s[n-2]+1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4</span>;</span><br><span class="line">ll base[N][N];</span><br><span class="line">ll tmp[N][N];</span><br><span class="line">ll n,mod;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span><span class="comment">//初始化构造的矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    base[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    base[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    base[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    base[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    base[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    base[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    base[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    base[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mult</span><span class="params">(ll x[N][N],ll y[N][N])</span><span class="comment">//矩阵相乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll tmp[N][N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line">            tmp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;N;k++)</span><br><span class="line">                tmp[i][j]=(tmp[i][j]+x[i][k]*y[k][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(x,tmp,<span class="built_in">sizeof</span>(tmp));<span class="comment">//复制函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll b)</span><span class="comment">//矩阵快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans[N][N];</span><br><span class="line">    <span class="built_in">memcpy</span>(ans,base,<span class="built_in">sizeof</span>(base));</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="built_in">mult</span>(ans,base);</span><br><span class="line">        <span class="built_in">mult</span>(base,base);</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>*ans[<span class="number">1</span>][<span class="number">2</span>]+<span class="number">2</span>*ans[<span class="number">2</span>][<span class="number">2</span>]+<span class="number">1</span>*ans[<span class="number">3</span>][<span class="number">2</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,n%mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">fpow</span>(n<span class="number">-3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐一些题目：</p>
<p>简单的：</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757">http://acm.hdu.edu.cn/showproblem.php?pid=1757</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575">http://acm.hdu.edu.cn/showproblem.php?pid=1575</a></p>
<p>不简单的：</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3483">http://acm.hdu.edu.cn/showproblem.php?pid=3483</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2855">http://acm.hdu.edu.cn/showproblem.php?pid=2855</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3658">http://acm.hdu.edu.cn/showproblem.php?pid=3658</a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4565">http://acm.hdu.edu.cn/showproblem.php?pid=4565</a></p>
<h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>唯一分解定理：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164140621.png" alt="image-20220808164140621"></p>
<p>证明：</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164155434.png" alt="image-20220808164155434"></p>
<p>定理：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164218288.png" alt="image-20220808164218288"></p>
<p>试除法分解质因数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[N],p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			p[++cnt]=i,c[cnt]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,c[cnt]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)  <span class="comment">//如果n是质数</span></span><br><span class="line">	&#123;</span><br><span class="line">		p[++cnt]=n,c[cnt]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">		cout &lt;&lt; p[i] &lt;&lt; <span class="string">&quot;^&quot;</span> &lt;&lt; c[i] &lt;&lt; endl;</span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p>定理：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164845101.png" alt="image-20220808164845101"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164856853.png" alt="image-20220808164856853"></p>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>定义：两个数 a和 b的最大公约数 是指同时整除 a和 b的最大因数记为gcd(a,b) 。 一个约定俗成的定理：任何非零整数和零的最大公约数为它本身。</p>
<p>性质：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164936556.png" alt="image-20220808164936556"></p>
<p> <strong>辗转相除法</strong>：</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808164958348.png" alt="image-20220808164958348"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更相减损术：</strong><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165315627.png" alt="image-20220808165315627"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165326603.png" alt="image-20220808165326603"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165335926.png" alt="image-20220808165335926"></p>
<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>定义 :两个数a和b的最小公倍数,是指同时被a和b整除的最小倍数，记为lcm（a，b）。特殊的，当 a 和b互素时, Icm(a, b) &#x3D; ab.</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165604467.png" alt="image-20220808165604467"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165628757.png" alt="image-20220808165628757"></p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808165706858.png" alt="image-20220808165706858"></p>
<p>筛法求欧拉函数 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">euler_one</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性质：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170136317.png" alt="image-20220808170136317"></p>
<h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>定义：若正整数 a和b 除以m 的余数相等，则称 a， b模m 同余，记作 a &#x3D; b (mod m)。 即a % m &#x3D; b % m 。</p>
<h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170617933.png" alt="image-20220808170617933"></p>
<h4 id="高次同余方程"><a href="#高次同余方程" class="headerlink" title="高次同余方程"></a>高次同余方程</h4><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171233277.png" alt="image-20220808171233277"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171240148.png" alt="image-20220808171240148"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>%p == b%p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;j=b%p;i&lt;k;i++)&#123;</span><br><span class="line">		hash[j]=i;</span><br><span class="line">		j=(ll)j*a%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ak=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) ak=(ll)ak*a%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;j=ak;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(hash.<span class="built_in">count</span>(j)) <span class="keyword">return</span> (ll)i*k-hash[j];</span><br><span class="line">		j=(ll)j*ak%p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170639938.png" alt="image-20220808170639938"></p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170926575.png" alt="image-20220808170926575"></p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170537497.png" alt="image-20220808170537497"></p>
<h4 id="费马小定理求逆元"><a href="#费马小定理求逆元" class="headerlink" title="费马小定理求逆元"></a>费马小定理求逆元</h4><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171035985.png" alt="image-20220808171035985"></p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170553473.png" alt="image-20220808170553473"></p>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>1.求解ax + by &#x3D; gcd(a,b)中的x和 y。</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170721253.png" alt="image-20220808170721253"></p>
<p>证明：<img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170740982.png" alt="image-20220808170740982"></p>
<p>2.求解ax + by &#x3D; c  gcd(a,b) | c 或 ax≡c(modb)</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170810374.png" alt="image-20220808170810374"><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170815673.png" alt="image-20220808170815673"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808170843355.png" alt="image-20220808170843355"></p>
<h4 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h4><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171102844.png" alt="image-20220808171102844"></p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171129905.png" alt="image-20220808171129905"></p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171136665.png" alt="image-20220808171136665"></p>
<p>扩展欧几里得求中国剩余定理 :</p>
<p><img data-src="C:\Users\QQQ\AppData\Roaming\Typora\typora-user-images\image-20220808171150545.png" alt="image-20220808171150545"></p>
<h2 id="周赛"><a href="#周赛" class="headerlink" title="周赛"></a>周赛</h2><h3 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h3><h4 id="哈密顿绕行世界问题（DFS-CDUTETCOJ"><a href="#哈密顿绕行世界问题（DFS-CDUTETCOJ" class="headerlink" title="哈密顿绕行世界问题（DFS )- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/problem/HDU-2181">哈密顿绕行世界问题（DFS )- CDUTETCOJ</a></h4><p><strong>题意：输出从第m个城市出发经过每个城市1次又回到m的所有路线,如有多条路线,按<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E5%85%B8%E5%BA%8F&spm=1001.2101.3001.7020">字典序</a>输出,每行1条路线.每行首先输出是第几条路线.然后个一个: 后列出经过的城市</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Map[<span class="number">25</span>];<span class="comment">//邻接表存地图 </span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> m,cnt;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cn==<span class="number">20</span>)<span class="comment">//dfs的南墙 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)<span class="comment">//判断是否可以回到起始城市 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(Map[ans[cn]][i]==m)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;:  &quot;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x = ans[cn];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Map[x].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[Map[x][i]])<span class="comment">//判断是否已经走过 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ans[++cn] = Map[x][i];</span><br><span class="line">			vis[Map[x][i]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(cn);</span><br><span class="line">			vis[Map[x][i]] = <span class="literal">false</span>;<span class="comment">//回溯 </span></span><br><span class="line">			cn--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)<span class="comment">//输入城市 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			Map[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));<span class="comment">//初始化 </span></span><br><span class="line">		</span><br><span class="line">		ans[<span class="number">1</span>] = m;</span><br><span class="line">		vis[m] = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="N-大整数运算-CDUTETCOJ"><a href="#N-大整数运算-CDUTETCOJ" class="headerlink" title="N!(大整数运算) - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/problem/HDU-1042">N!(大整数运算) - CDUTETCOJ</a></h4><p><strong>题意：对给出的n求n的阶乘，输入为读到文件末尾。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;<span class="comment">//位数开够</span></span><br><span class="line"><span class="type">int</span> num[maxn];</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mut</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">	num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        temp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len;j++)&#123;</span><br><span class="line">           num[j] = num[j]*i+temp;</span><br><span class="line">           temp = num[j]/<span class="number">10</span>;</span><br><span class="line">           num[j] = num[j]%<span class="number">10</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">            num[++len]= temp%<span class="number">10</span>;</span><br><span class="line">            temp = temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        cout &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">mut</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="comment">/*常规的大整数模板会超时或者超空间，因为阶乘的数过于大，常规模板使用的是十进制来存储数字，即数组的一位代表一个数字。这样做虽然便于理解，但是会使数组的长度过于长。所以本题使用万进制，即10000进1,这样数组就会非常小，节省了空间并且减少了循环次数。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>, carry, i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">     &#123;</span><br><span class="line">        a[j] = a[j] * i + carry;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt;= <span class="number">10000</span>) <span class="comment">//当前这位超过10000就进位</span></span><br><span class="line">       &#123;</span><br><span class="line">          carry = a[j] / <span class="number">10000</span>;</span><br><span class="line">          a[j] %= <span class="number">10000</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          carry = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) <span class="comment">// 最高位的进位</span></span><br><span class="line">        a[len++] = carry;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 万进制输出时不足四位的要补0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[len - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Median-（双重二分）-CDUTETCOJ"><a href="#Median-（双重二分）-CDUTETCOJ" class="headerlink" title="Median （双重二分）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/problem/POJ-3579">Median （双重二分）- CDUTETCOJ</a></h4><p><strong>题意: 给出n个数x1…xn, 求所有|xi - xj|中中位数的大小, 如果总数m为偶数, 则为(m+1)&#x2F;2</strong></p>
<p><em><em>思路：将x排序后, 我们首先<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&spm=1001.2101.3001.7020">二分查找</a>中位数k, 范围应该是0-a[n], 这一点不难想到, 同时通过数学知识可知m &#x3D; (n</em>(n-1)&#x2F;2 + 1)&#x2F;2, 那下一步的问题就是如何检验是否有m个&lt;&#x3D;k的|xi - xj|</em>*</p>
<p><strong>依然是假设+检验的思路, 因为中位数k已经确定(上一层二分中假设), 我们可以枚举j的下标(j &gt;&#x3D; i), 同时二分查找i的下标, x[i] &#x3D; x[j]-k, 我们不断累积j-i的和其实就是|xi - xj|的数量, 发现大于m跳出即可</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ms(x, n) memset(x,n,sizeof(x));</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, x[maxn];</span><br><span class="line">LL m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findi</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//在[1,r]范围内查找&gt;s的第一个下标</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[mid]&gt;=s) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//检验k为中位数时是否有大于等于m个&lt;=k的|a[i]-a[j]|</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查找j, 通过枚举i同时累加|a[i]-a[j]|小于m的数量, &gt;=k则跳出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        sum += (LL)j - <span class="built_in">findi</span>(x[j]-k, j);</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">        m = (LL)(n*(n<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">//中位数下标</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(x+<span class="number">1</span>, x+<span class="number">1</span>+n);</span><br><span class="line">        <span class="comment">//二分查找中位数</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = x[n];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Northcott-Game-（尼姆博弈）-CDUTETCOJ"><a href="#Northcott-Game-（尼姆博弈）-CDUTETCOJ" class="headerlink" title="Northcott Game （尼姆博弈）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/problem/HDU-1730">Northcott Game （尼姆博弈）- CDUTETCOJ</a></h4><p><strong>题意:</strong><br><strong>有一个n行m列的棋盘,每一行都有一个黑子和白子.黑子先手,每次玩家可以移动己方任意棋子到同一行的任何一个空格上，当然这过程中不许越过该行的敌方棋子.双方轮流移动，直到某一方无法行动为止，移动最后一步的玩家获胜。</strong></p>
<p><strong>两个棋子之间的距离就是石子数,将每一个距离异或起来即可</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            res^=<span class="built_in">abs</span>(u-v)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res)</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;I WIN!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;BAD LUCK!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="水果-（map嵌套）-CDUTETCOJ"><a href="#水果-（map嵌套）-CDUTETCOJ" class="headerlink" title="水果 （map嵌套）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/problem/HDU-1263">水果 （map嵌套）- CDUTETCOJ</a></h4><p><strong>题意:</strong><br><strong>t组样列，每组样列n行，每一行包含水果名称、产地、销量。输出每个产地每种水果的销量，产地按照字典序小的先输出，水果也按照字典序小的先输出，每组样列之前有一个空行，最后一个没有空行。</strong></p>
<p><strong>map会自动对键进行排序(数字按照从小到大，字符按照字典序)，而我们有产</strong><br><strong>地、水果名称和销量三个关系的映射，于是我们用嵌套的map即可。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t; <span class="comment">//t组样列</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">map&lt;string,map&lt;string,<span class="type">int</span>&gt; &gt; ma; <span class="comment">//第一个键表示产地，第二个键表示水果名称，值表示销量</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; s1 &gt;&gt; num; <span class="comment">//输入水果名称，产地，销量</span></span><br><span class="line">ma[s1][s]+=num; <span class="comment">//更新这个产地的水果x销量</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span>(map&lt;string,map&lt;string,<span class="type">int</span>&gt; &gt;::iterator</span><br><span class="line">i=ma.<span class="built_in">begin</span>();i!=ma.<span class="built_in">end</span>();i++)&#123; <span class="comment">//迭代器访问产地</span></span><br><span class="line">cout &lt;&lt; i-&gt;first &lt;&lt; endl; <span class="comment">//输出这个产地</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator j=i-&gt;second.<span class="built_in">begin</span>();j!=i-&gt;second.<span class="built_in">end</span>();j++)&#123; <span class="comment">//迭代器访问这个产地的水果</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;   |----&quot;</span>&lt;&lt; j-&gt;first &lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt; j-&gt;second &lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt; endl; <span class="comment">//输出水果和销量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t) cout &lt;&lt; endl; <span class="comment">//样列之间有换行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h3><h4 id="Best-Cow-Fences-（前缀和-浮点二分）-CDUTETCOJ"><a href="#Best-Cow-Fences-（前缀和-浮点二分）-CDUTETCOJ" class="headerlink" title="Best Cow Fences （前缀和+浮点二分）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/A">Best Cow Fences （前缀和+浮点二分）- CDUTETCOJ</a></h4><p>题意：给定一个长度为 n 的非负整数序列 A ，求一个平均数最大的，长度不小于 F 的子段</p>
<p>思路：</p>
<pre><code>1.对于二分，二分是二分性而不是单调性 只要满足可以找到一个值一半满足一半不满足即可 而不用满足单调性

2.因此，对于本题，我们二分枚举区间个数不小于f的区间和的平均数。以下注意点：
 
a.对于一段区间，每个数减去区间的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数。
 
我们直接用前缀和来统计每个区间，来达到快速判断一个区间里的平均值是否大于或小于我们二分枚举的平均数。
 
b.若我们枚举长度至少为f的区间最优时，即[l,r]，那么就是保证a[l−1]要尽量地小，然后a[r]要尽量地大，所以说
 
我们就需要枚举这个l，但是这样的话时间复杂度就上去了。我们发现，每一次r变大后，l的取值范围从[1,l]变成了[1,l+1]，
 
因此我们定义一个minc去每次存储l变化后[1,l]的最优极小值
 
c.最后结果向下取整，因此我们取的是r，而不是l。若是取l，可能会因为精度差，达不到结果。
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">double</span> dex[maxn],num[maxn];</span><br><span class="line"><span class="type">int</span> n,f;</span><br><span class="line"><span class="type">double</span> ans,minx;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">check</span><span class="params">(<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">	ans=<span class="number">-1</span>,minx=<span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=f; i&lt;=n; i++)&#123;</span><br><span class="line">	    minx=<span class="built_in">min</span>(minx,dex[i-f]);</span><br><span class="line">	    ans=<span class="built_in">max</span>(ans,dex[i]-minx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;f);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=<span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">0.00001</span>)&#123;</span><br><span class="line">	    <span class="type">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		num[i]=a[i]-mid;</span><br><span class="line">		dex[i]=dex[i<span class="number">-1</span>]+num[i];</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(f)&gt;=<span class="number">0</span>)</span><br><span class="line">			l=mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> s=(<span class="type">int</span>)(<span class="number">1000</span>*r);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mike-and-Feet-CDUTETCOJ（线段树）"><a href="#Mike-and-Feet-CDUTETCOJ（线段树）" class="headerlink" title="Mike and Feet - CDUTETCOJ（线段树）"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/B">Mike and Feet - CDUTETCOJ（线段树）</a></h4><p>题意：给n个数，问连续区间长度为1,2,3,4,….n 所对应的区间长度最小值中的最大值是多少。</p>
<p>用L(i)和R(i)记录以第i个数为最小值所能扩展的左右边界，则可以用a(i)去尝试更新ans(1)到ans(R(i)-L(i)+1)，<br>因为在区间[L(i),R(i)]内包含a(i)的区间最小值都为a(i)。<br>先用每个a(i)更新ans(R(i)-L(i)+1)，最后递推一下就行了：ans(i)&#x3D;max(ans(i),ans(i+1))，理由同上(大区间包含小区间)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> l[maxm],r[maxm];</span><br><span class="line"><span class="type">int</span> a[maxm];</span><br><span class="line"><span class="type">int</span> ans[maxm];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">0</span>]=a[n+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=a[j])j=l[j];</span><br><span class="line">        l[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=a[j])j=r[j];</span><br><span class="line">        r[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        l[i]++;</span><br><span class="line">        r[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> len=r[i]-l[i]+<span class="number">1</span>;</span><br><span class="line">        ans[len]=<span class="built_in">max</span>(ans[len],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        ans[i]=<span class="built_in">max</span>(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T9（字典树-DFS）-CDUTETCOJ"><a href="#T9（字典树-DFS）-CDUTETCOJ" class="headerlink" title="T9（字典树+DFS） - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/C">T9（字典树+DFS） - CDUTETCOJ</a></h4><p>题意：模拟手机九宫格输入法，输入w个字符串并给出每个字符串出现的次数，然后输入p组查询，每组的查询由一串数字组成，每输入一个数字输出到当前为止最有可能的字符串（如果不存在就输出MANUALLY），出现次数越多的字符串可能性越大。</p>
<p>题解：看题意肯定是要在字典树上操作的，但是与一般字典树不同的是这里多了一项出现次数。并且查询的时候一个数字可能同时代表几个字母，要找出其中出现次数最多的一个。所以首先在字典树建树时我们就要把每个单词中的每次字母出现次数都加上当前这个单词出现的次数。然后用dfs进行查找，我们遍历这个数字所代表的手机键包含的所有字符，如果在字典树中出现过就继续递归往下找，直到找到题目所要求的的长度，找到其中出现次数最大的一个字符，并输出根节点到这个字符的所有字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> phone[][<span class="number">4</span>] = &#123;&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;,&#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;,&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;,&#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;,&#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;,&#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;,&#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;,&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> num[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,w;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">105</span>],s[<span class="number">105</span>],str[<span class="number">105</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先做好预处理，phone表示手机上九键表示的字母，num表示（除1外）每个数字上包含几个字母，</span></span><br><span class="line"><span class="comment">w保存每个字符在字典树每层出现的频率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt;<span class="comment">///cnt记录每个字母出现的频率</span></span><br><span class="line">    Trie *child[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">Trie</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            child[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie *root,*current,*temp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> ss[],<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     current = root;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(ss);i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(current-&gt;child[ss[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> Trie;</span><br><span class="line">            current-&gt;child[ss[i] - <span class="string">&#x27;a&#x27;</span>] = temp;</span><br><span class="line">            current = current-&gt;child[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            (current-&gt;cnt)+=k;<span class="comment">///在出入时记录好每个字符出现的频率</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            current = current-&gt;child[ss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            (current-&gt;cnt)+=k;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> len,Trie *tr)</span></span></span><br><span class="line"><span class="function"><span class="comment">///DFS查找的思路是遍历这个数字包含的所有字符，如果在字典树中出现就继续递归往下找，</span></span></span><br><span class="line"><span class="function"><span class="comment">///直到找到题目所要求的长度，找到其中权重最大一个字符，并输出从根节点到这个字符所表示的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st == len)<span class="comment">///找到题目所要求长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tr-&gt;cnt&gt;w)&#123;</span><br><span class="line">            w = tr-&gt;cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">                ans[i] = s[i];</span><br><span class="line">            ans[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> L = str[st] - <span class="string">&#x27;2&#x27;</span>;<span class="comment">///因为包含字母的数字是从2开始的，所以这里要减去‘2’</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num[L];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c = phone[L][i];</span><br><span class="line">        <span class="keyword">if</span>(tr-&gt;child[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="literal">NULL</span>)&#123;<span class="comment">///因为找到权重最大的字符时，它前边的字符必须可能在以前输入数字时有出现的可能，所以这里我们要控制某个数字包含的字母只有在字典书中的字符才往下递归</span></span><br><span class="line">            s[st] = c;</span><br><span class="line">            <span class="built_in">dfs</span>(st+<span class="number">1</span>,len,tr-&gt;child[c-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Trie;</span><br><span class="line">        <span class="type">int</span> n,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="type">char</span> str1[<span class="number">105</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,str1,&amp;k);</span><br><span class="line">            <span class="built_in">insert</span>(str1,k);<span class="comment">///字典树插入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d:\n&quot;</span>,++c);</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;<span class="comment">///因为最后一个1忽略不计，所以这里小于len就可以了</span></span><br><span class="line">                w = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(<span class="number">0</span>,j,root);</span><br><span class="line">                <span class="keyword">if</span>(w&gt;<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;MANUALLY\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Panda（线段树）-CDUTETCOJ"><a href="#Panda（线段树）-CDUTETCOJ" class="headerlink" title="Panda（线段树） - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/D">Panda（线段树） - CDUTETCOJ</a></h4><p>题意：</p>
<p>给出一个只包含w和b的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>，要求支持一下两种操作：1，统计区间[a,b]中wbw的数量。2，修改a[p]的值为v。</p>
<p>分析：</p>
<p>线段树，sum[o]为结点o的wbw的数量。</p>
<p>在建树时，对与o结点的sum[o]&#x3D;sum[2<em>o]+sum[2</em>o+1];如果两个结点连接处有wbw则将sum[o]++;更新的过程类似于建树的过程。</p>
<p>在查询[ql,qr]区间的wbw数量时，当两个区间合并时若连接处有wbw则_sum++；注意这里和建树和更新时候的区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">50000</span>+<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>*maxn];</span><br><span class="line"><span class="type">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        num[o]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*o,L,M);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">2</span>*o+<span class="number">1</span>,M+<span class="number">1</span>,R);</span><br><span class="line">    num[o]=num[<span class="number">2</span>*o]+num[<span class="number">2</span>*o+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(R-L&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[M]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;s[M<span class="number">-1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;M-L&gt;=<span class="number">1</span>)</span><br><span class="line">            num[o]++;</span><br><span class="line">        <span class="keyword">if</span>(s[M]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">2</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;R-M&gt;=<span class="number">2</span>)</span><br><span class="line">            num[o]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p;<span class="comment">//A[p]=v</span></span><br><span class="line"><span class="type">char</span> v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        s[L]=v;</span><br><span class="line">        num[o]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;=M)<span class="built_in">update</span>(<span class="number">2</span>*o,L,M);</span><br><span class="line">    <span class="keyword">if</span>(p&gt;M)<span class="built_in">update</span>(<span class="number">2</span>*o+<span class="number">1</span>,M+<span class="number">1</span>,R);</span><br><span class="line">    num[o]=num[<span class="number">2</span>*o]+num[<span class="number">2</span>*o+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(R-L&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[M]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;s[M<span class="number">-1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;M-L&gt;=<span class="number">1</span>)</span><br><span class="line">            num[o]++;</span><br><span class="line">        <span class="keyword">if</span>(s[M]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">2</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;R-M&gt;=<span class="number">2</span>)</span><br><span class="line">            num[o]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ql,qr,_sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=L&amp;&amp;qr&gt;=R)&#123;</span><br><span class="line">        _sum+=num[o];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=M)<span class="built_in">query</span>(<span class="number">2</span>*o,L,M);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;M)<span class="built_in">query</span>(<span class="number">2</span>*o+<span class="number">1</span>,M+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=M&amp;&amp;qr&gt;M)&#123;</span><br><span class="line">        <span class="keyword">if</span>(R-L&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[M]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;s[M<span class="number">-1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;M-ql&gt;=<span class="number">1</span>&amp;&amp;M-L&gt;=<span class="number">1</span>)<span class="comment">//注意这里</span></span><br><span class="line">                _sum++;</span><br><span class="line">            <span class="keyword">if</span>(s[M]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">2</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;s[M+<span class="number">1</span>]==<span class="string">&#x27;b&#x27;</span>&amp;&amp;qr-M&gt;=<span class="number">2</span>&amp;&amp;R-M&gt;=<span class="number">2</span>)</span><br><span class="line">                _sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tra</span><span class="params">(<span class="type">int</span> o,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;L&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;R&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[o]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(L==R)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> M=L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">tra</span>(<span class="number">2</span>*o,L,M);</span><br><span class="line">    <span class="built_in">tra</span>(<span class="number">2</span>*o+<span class="number">1</span>,M+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=T;k++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//tra(1,0,n-1);</span></span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;ql,&amp;qr);</span><br><span class="line">                _sum=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">                cout&lt;&lt;_sum&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;p,&amp;v);</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">//tra(1,0,n-1);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Monitor（二维前缀和）-CDUTETCOJ"><a href="#Monitor（二维前缀和）-CDUTETCOJ" class="headerlink" title="Monitor（二维前缀和） - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/E">Monitor（二维前缀和） - CDUTETCOJ</a></h4><p>题意：n*m&lt;&#x3D;1e7 的矩阵 给p个红框范围（左上角+右下角）表示监控器覆盖的范围，给q个蓝框范围（左上角+右下角）表示询问</p>
<p>思路：</p>
<p> 先求出监控器覆盖范围的差分数组，对差分数组求前缀和，处理重叠部分，加上原来的矩阵（这里原来矩阵为全零所以不用加），在求一次前缀和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">7</span>; <span class="comment">//数组最大 </span></span><br><span class="line"><span class="comment">//n*m &lt;= 1e7  二维转一维 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; n || j &gt; m) <span class="keyword">return</span>;</span><br><span class="line">	v[(i<span class="number">-1</span>)*m + j] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || j &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> v[(i<span class="number">-1</span>)*m+j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">		v.<span class="built_in">resize</span>(n*m+<span class="number">7</span>); <span class="comment">//!!!</span></span><br><span class="line">		<span class="comment">//v.assign(n*m+6, 0);</span></span><br><span class="line">		v.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> p, x1, x2, y1, y2;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;p); </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">			<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">			<span class="comment">//差分数组 </span></span><br><span class="line">			<span class="built_in">add</span>(x1, y1, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">add</span>(x1, y2 + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">add</span>(x2 + <span class="number">1</span>, y1, <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">add</span>(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">//对差分数组求前缀和 </span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">				v[(i<span class="number">-1</span>)*m + j] += (<span class="built_in">query</span>(i<span class="number">-1</span>, j) + <span class="built_in">query</span>(i, j<span class="number">-1</span>) - <span class="built_in">query</span>(i<span class="number">-1</span>, j<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//因为a数组初始值全为零所以a的后缀数组就是差分数组 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (v[(i<span class="number">-1</span>)*m + j] != <span class="number">0</span>) v[(i<span class="number">-1</span>)*m + j] = <span class="number">1</span>; <span class="comment">//处理重叠部分 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">//对前缀数组求前缀和 </span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">				v[(i<span class="number">-1</span>)*m + j] += (<span class="built_in">query</span>(i<span class="number">-1</span>, j) + <span class="built_in">query</span>(i, j<span class="number">-1</span>) - <span class="built_in">query</span>(i<span class="number">-1</span>, j<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="type">int</span> q;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">		<span class="keyword">while</span> (q--) &#123;</span><br><span class="line">			<span class="built_in">scanf</span> (<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">			<span class="type">int</span> sum = <span class="built_in">query</span>(x2, y2) - <span class="built_in">query</span>(x1<span class="number">-1</span>, y2) - <span class="built_in">query</span>(x2, y1<span class="number">-1</span>) + <span class="built_in">query</span>(x1<span class="number">-1</span>, y1<span class="number">-1</span>); </span><br><span class="line">			<span class="keyword">if</span> (sum == (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Zjnu-Stadium-（带权并查集-路径压缩）-CDUTETCOJ"><a href="#Zjnu-Stadium-（带权并查集-路径压缩）-CDUTETCOJ" class="headerlink" title="Zjnu Stadium （带权并查集+路径压缩）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1041/problem/F">Zjnu Stadium （带权并查集+路径压缩）- CDUTETCOJ</a></h4><p>题意：给出关于n个人座位的m个要求，每个要求由三个数A、B、C。表示B在A后面C个单位距离。需要你从这m个要求中，找出其中不能满足的个数。</p>
<p>思路：不正确的信息一定是当前与前面已知信息冲突，<br>比如 A ,B X 满足冲突条件是 A B，在已经有同根的关系下，并且dist[B]-distp[A] !&#x3D;X 就冲突。<br>首先找祖先的操作，x直接到其祖先的儿子，要把所有路过的父辈权值加过来。<br><strong>路径压缩时的图解</strong></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190906102007240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MjcyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190906102035205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MjcyOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxx=<span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> dis[maxx];</span><br><span class="line"><span class="type">int</span> pre[maxx];</span><br><span class="line"><span class="type">int</span> cot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">        dis[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=pre[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=pre[x];</span><br><span class="line">        pre[x]=<span class="built_in">find</span>(pre[x]);</span><br><span class="line">        dis[x]+=dis[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fy]=fx;</span><br><span class="line">        dis[fy]=dis[x]+z-dis[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[y]-dis[x]!=z) cot++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;m,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="built_in">join</span>(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h3><h4 id="Digit-Machine-CDUTETCOJ"><a href="#Digit-Machine-CDUTETCOJ" class="headerlink" title="Digit Machine - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/A">Digit Machine - CDUTETCOJ</a></h4><p><strong>水题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">105</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">3</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ans=a[ans];</span><br><span class="line">	&#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Preparing-for-Merge-Sort-（二分）-CDUTETCOJ"><a href="#Preparing-for-Merge-Sort-（二分）-CDUTETCOJ" class="headerlink" title="Preparing for Merge Sort （二分）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/B">Preparing for Merge Sort （二分）- CDUTETCOJ</a></h4><p>题意：给你一个长度为n的序列，用一个或几个递增序表示给定的序列。</p>
<p>解题思路：<br>（１）：for循环暴力模拟（一个小组一个小组的选取）——超时<br>（２）：每次选择序列中的当前元素，试探是否可以放置在之前已经分好的小组，若可以，放置更新，若不可以，开新的小组进行放置——（暴力查询放置小组——超时）——（通过数据查询临界情况优化暴力查询放置小组）——（临界情况优化＋二分优化查询放置小组）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)/<span class="number">2</span>; </span><br><span class="line">		<span class="keyword">if</span>(v[mid]&gt;m) l=mid+<span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;v[r] || !v.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		<span class="type">int</span> s=<span class="built_in">find</span>(m);</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="number">-1</span>) &#123;</span><br><span class="line">			dis[cnt].<span class="built_in">push_back</span>(m);</span><br><span class="line">			v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(),m);</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			v[s]=m;</span><br><span class="line">			dis[s].<span class="built_in">push_back</span>(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dis[i].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">			cout &lt;&lt; dis[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Slim-Span（最小生成树kruskal）-CDUTETCOJ"><a href="#Slim-Span（最小生成树kruskal）-CDUTETCOJ" class="headerlink" title="Slim Span（最小生成树kruskal） - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/C">Slim Span（最小生成树kruskal） - CDUTETCOJ</a></h4><p>题意：求生成树的最长边与最短边的差值的最小值</p>
<p>思路：保证每一条边最小，就只要枚举最小边开始，跑kruskal，最后一个值便是最大值，在<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020">枚举</a>最小边同时维护差值最小，不断更新最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 55555</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="type">int</span> n,m,fa[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.w!=b.w)<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">    <span class="keyword">if</span>(a.u!=b.u)<span class="keyword">return</span> a.u&lt;b.u;</span><br><span class="line">    <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="built_in">sort</span>(edge,edge+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m-n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">-1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)fa[j]=j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">find</span>(edge[j].u),y=<span class="built_in">find</span>(edge[j].v);</span><br><span class="line">            <span class="keyword">if</span>(x!=y)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                fa[x]=y;</span><br><span class="line">                <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=edge[j].w-edge[i].w;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">-1</span>)ans=<span class="built_in">min</span>(ans,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m),n||m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w);</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">kruskal</span>(n,m);</span><br><span class="line">        <span class="keyword">if</span>(ans==INF)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Multiples-of-Length（思维）-CDUTETCOJ"><a href="#Multiples-of-Length（思维）-CDUTETCOJ" class="headerlink" title="Multiples of Length（思维） - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/D">Multiples of Length（思维） - CDUTETCOJ</a></h4><p>题意：有 n 个数，现在有种操作：选取一个区间 [l,r] ，长度 len&#x3D;r-l+1 , 对于数组 a : a[l]~a[r] 将每一个数都加或减去 len 的倍数</p>
<p>这样的操作可以进行三次且必须进行三次，使得每个数都为 0</p>
<p>思路：先操作[2,n]区间，那么每个数加上( n − 1 ) ∗ a [ i ] (n-1)*a<a href="n%E2%88%921">i</a>∗a[i]，之后除了第一个数，每个数都成了n的倍数。<br>第二次操作[1,1]区间，将其变成0。<br>第三次操作[1,n]区间，第一个数输出0，其他数输出-a[i]。</p>
<p>注意要特判一个数的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 1\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 1\n0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1 1\n0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 %lld\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        ll now = a[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,now * (n - <span class="number">1</span>));</span><br><span class="line">        a[i] += now * (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,-a[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 %lld\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mirror-Grid-CDUTETCOJ"><a href="#Mirror-Grid-CDUTETCOJ" class="headerlink" title="Mirror Grid - CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/E">Mirror Grid - CDUTETCOJ</a></h4><p><a href="https://blog.csdn.net/gpc_123/article/details/125774512?spm=1001.2014.3001.5502"> Mirror Grid_梦中醉卧惊起的博客-CSDN博客</a></p>
<p>给一个n * n 只有0 或 1组成的单元格，给定操作：翻转0或1。输出最少操作次数使得每个单元格每次翻转0°, 90°,180° 和 270°后仍不变.</p>
<p>由题意可知这个<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>必须是中心对称图形,所以遍历这个矩形的每一层,查看每次0多还是1多即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn][<span class="number">105</span>];</span><br><span class="line"><span class="type">char</span> s;		</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i ++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				cin &gt;&gt; s;</span><br><span class="line">				a[i][j]=s-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">			<span class="type">int</span> w=a[i][j]+a[j][n-i+<span class="number">1</span>]+a[n-i+<span class="number">1</span>][n-j+<span class="number">1</span>]+a[n-j+<span class="number">1</span>][i];</span><br><span class="line">			sum+=<span class="built_in">min</span>(w,<span class="number">4</span>-w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hawk-and-Chicken-（tarjan）-CDUTETCOJ"><a href="#Hawk-and-Chicken-（tarjan）-CDUTETCOJ" class="headerlink" title="Hawk-and-Chicken （tarjan）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/F">Hawk-and-Chicken （tarjan）- CDUTETCOJ</a></h4><p>题意：每个孩子手里有一些手帕可以给别的孩子来投票，然后给出孩子门投票的结果，问最后得到最多的选票是多少，以及都有谁得到了这个选票数。有一点需注意，加入A投给了B，B又投给了C，那么此时C是得到了两个选票的，也就是说选票在传递过程中是累加的。</p>
<p>思路：先用Tarjin算法缩点，然后求出每个强连通块的人数，找出传递链开始的地方深搜，找出获得的最大票数<strong>（深搜前要把所有的边逆过来建一个新的图）。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _for(i, a) for(int i = 0; i &lt; (a); i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _rep(i, a, b) for(int i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;<span class="comment">//链式向前星</span></span><br><span class="line">	<span class="type">int</span> u, v, next, id;</span><br><span class="line">&#125;G[<span class="number">30005</span>], g[<span class="number">30005</span>];</span><br><span class="line"><span class="type">int</span> headG[maxn], cntG;<span class="comment">//原链表</span></span><br><span class="line"><span class="type">int</span> headg[maxn], cntg;<span class="comment">//逆链表</span></span><br><span class="line"><span class="type">int</span> dfn[maxn], low[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> scccnt;<span class="comment">//强连通块的数量</span></span><br><span class="line"><span class="type">int</span> sccno[maxn];<span class="comment">//强连通块的序号</span></span><br><span class="line"><span class="type">int</span> num[maxn];<span class="comment">//每个强连通块的人数-以强连通块的序号为索引</span></span><br><span class="line"><span class="type">int</span> num1[maxn];<span class="comment">//目前为止连起来的人数-以强连通块的序号为索引</span></span><br><span class="line"><span class="type">int</span> tclock;</span><br><span class="line"><span class="type">int</span> indegree[maxn];<span class="comment">//强连通块的入度</span></span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(edge G[], <span class="type">int</span> head[], <span class="type">int</span> &amp;cnt, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">	G[cnt].u = u;</span><br><span class="line">	G[cnt].v = v;</span><br><span class="line">	G[cnt].id = cnt;</span><br><span class="line">	G[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tclock = scccnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mem</span>(headG, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">mem</span>(headg, <span class="number">-1</span>);</span><br><span class="line">	cntg = cntG = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mem</span>(dfn, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(low, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(num, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(num1, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(sccno, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(indegree, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(G, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">mem</span>(g, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjin</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;<span class="comment">//缩点</span></span><br><span class="line">	dfn[u] = low[u] = ++tclock;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = headG[u]; i != <span class="number">-1</span>; i = G[i].next) &#123;</span><br><span class="line">		<span class="type">int</span> v = G[i].v;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">			<span class="built_in">tarjin</span>(v);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!sccno[v]) &#123;</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">		<span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">		scccnt++;</span><br><span class="line">		<span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">			v = q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			sccno[v] = scccnt;</span><br><span class="line">			num[scccnt]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum = num[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = headg[u]; i != <span class="number">-1</span>; i = g[i].next) &#123;</span><br><span class="line">		<span class="type">int</span> v = g[i].v;</span><br><span class="line">		<span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">			sum += <span class="built_in">dfs</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	_rep(cas, <span class="number">1</span>, T) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		_for(i, m) &#123;</span><br><span class="line">			<span class="type">int</span> u, v;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">			<span class="built_in">add_edge</span>(G, headG, cntG, u + <span class="number">1</span>, v + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		_rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">				<span class="built_in">tarjin</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		_rep(u, <span class="number">1</span>, n) &#123;<span class="comment">//把边全部逆着存一遍，为下面的深搜做准备；并且求出每个连通块的入度（针对逆边）</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = headG[u]; i != <span class="number">-1</span>; i = G[i].next) &#123;</span><br><span class="line">				<span class="type">int</span> v = G[i].v;</span><br><span class="line">				<span class="keyword">if</span> (sccno[u] != sccno[v]) &#123;</span><br><span class="line">					<span class="built_in">add_edge</span>(g, headg, cntg, sccno[v], sccno[u]);</span><br><span class="line">					indegree[sccno[u]]++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> _max = <span class="number">-1</span>;</span><br><span class="line">		_rep(i, <span class="number">1</span>, scccnt) &#123;</span><br><span class="line">			<span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;<span class="comment">//之所以只看入度为0的连通块，是因为它处在一条链的末尾，前面积攒的票都能传到他这里，所以只看入度为0的点就能求出最大的票数。</span></span><br><span class="line">				<span class="built_in">mem</span>(vis, <span class="number">0</span>);</span><br><span class="line">				num1[i] = <span class="built_in">dfs</span>(i);</span><br><span class="line">				_max = <span class="built_in">max</span>(_max, num1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, cas, _max - <span class="number">1</span>);</span><br><span class="line">		<span class="type">bool</span> f = <span class="number">1</span>;</span><br><span class="line">		_rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num1[sccno[i]] == _max) &#123;</span><br><span class="line">				<span class="keyword">if</span> (f) &#123;</span><br><span class="line">					f = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Misha-Grisha-and-Underground-（LCA）-CDUTETCOJ"><a href="#Misha-Grisha-and-Underground-（LCA）-CDUTETCOJ" class="headerlink" title="Misha, Grisha and Underground （LCA）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/G">Misha, Grisha and Underground （LCA）- CDUTETCOJ</a></h4><p>令a为汇合点，那么答案就是<code>(dis(a,b) + dis(a,c) - dis(b,c)) / 2 + 1</code>，dis用lca求出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFS</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFS</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LFS</span>(<span class="type">int</span> N) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">        n = N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adde</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[ecnt].to = to;</span><br><span class="line">        e[ecnt].w = w;</span><br><span class="line">        e[ecnt].next = head[from];</span><br><span class="line">        head[from] = ecnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addde</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">adde</span>(a, b, w);</span><br><span class="line">        <span class="built_in">adde</span>(b, a, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to, next, w;</span><br><span class="line">    &#125; e[MAXN * <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> head[MAXN];</span><br><span class="line">    <span class="type">int</span> ecnt;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LCA</span> : <span class="keyword">public</span> LFS&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   	<span class="type">int</span> dep[MAXN];</span><br><span class="line">    <span class="built_in">LCA</span>(<span class="type">int</span> n) : <span class="built_in">LFS</span>(n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> rt = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">dfs</span>(rt, <span class="number">1</span>, <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">querylca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[a] &gt; dep[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="type">int</span> h = dep[b] - dep[a];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">				b = f[b][i];</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[a][i] == f[b][i]) <span class="keyword">continue</span>;</span><br><span class="line">            a = f[a][i];</span><br><span class="line">            b = f[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">querydis</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    	<span class="type">int</span> lca = <span class="built_in">querylca</span>(a,b);</span><br><span class="line">    	<span class="keyword">return</span> dep[a] + dep[b] - dep[lca]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> f[MAXN][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> d, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        dep[u] = d;</span><br><span class="line">        f[u][<span class="number">0</span>] = fa;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">            f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = e[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dep[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, d + <span class="number">1</span>, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> X = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        w |= ch == <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        X = (X &lt;&lt; <span class="number">3</span>) + (X &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w ? -X : X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(LCA* tree,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> disab = tree-&gt;<span class="built_in">querydis</span>(a,b);</span><br><span class="line">	<span class="type">int</span> disac = tree-&gt;<span class="built_in">querydis</span>(a,c);</span><br><span class="line">	<span class="type">int</span> disbc = tree-&gt;<span class="built_in">querydis</span>(b,c);</span><br><span class="line">	<span class="keyword">return</span> (disab + disac - disbc) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,q;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	LCA* tree = <span class="keyword">new</span> <span class="built_in">LCA</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		tree-&gt;<span class="built_in">addde</span>(i,a,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	tree-&gt;<span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		ans = <span class="built_in">max</span>(<span class="built_in">solve</span>(tree,a,b,c),<span class="built_in">max</span>(<span class="built_in">solve</span>(tree,b,a,c),<span class="built_in">solve</span>(tree,c,a,b)));</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Invitation-Cards-（链式前向星-最短路）-CDUTETCOJ"><a href="#Invitation-Cards-（链式前向星-最短路）-CDUTETCOJ" class="headerlink" title="Invitation Cards （链式前向星+最短路）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/H">Invitation Cards （链式前向星+最短路）- CDUTETCOJ</a></h4><p>题意：输入一个 t 表示 t 组数据，对于每组数据，输入n和m，表示有n个顶点和m条<strong>有向边</strong>，你需要输出所有人往返路径和的最小值。（保证每个点都可以往返源点1）</p>
<p>链式前向星存图 + 反向建图 + spfa，题目中提到了往返一次，说明这道题建图时建正反两个，这里使用链式前向星存图，跑两次spfa最后取{min(dis[i] + dis1[i])} 即可，注意数据范围可能很大，开long long 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e4</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N], idx;</span><br><span class="line"><span class="type">int</span> h1[N], ne1[N], e1[N], idx1;</span><br><span class="line">ll w[N], w1[N];</span><br><span class="line">ll dis[N], dis1[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> T, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, ll c)</span><span class="comment">//正向反向各建一个图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b;</span><br><span class="line">	w[idx] = c;</span><br><span class="line">	ne[idx] = h[a];</span><br><span class="line">	h[a] = idx++;</span><br><span class="line"></span><br><span class="line">	e1[idx1] = a;</span><br><span class="line">	w1[idx1] = c;</span><br><span class="line">	ne1[idx1] = h1[b];</span><br><span class="line">	h1[b] = idx1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//多组数据不要忘记初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	idx = idx1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="built_in">memset</span>(h1, <span class="number">-1</span>, <span class="keyword">sizeof</span> h1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="type">int</span> &gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">	vis[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		vis[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span> (dis[t] + w[i] &lt; dis[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[j] = dis[t] + w[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[j])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					vis[j] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">respfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis1, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis1);</span><br><span class="line">	dis1[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="type">int</span> &gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">	vis[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		vis[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h1[t]; ~i; i = ne1[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = e1[i];</span><br><span class="line">			<span class="keyword">if</span> (dis1[t] + w1[i] &lt; dis1[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dis1[j] = dis1[t] + w1[i];</span><br><span class="line">				<span class="keyword">if</span> (!vis[j])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(j);</span><br><span class="line">					vis[j] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (T --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (m --)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a, b;</span><br><span class="line">			ll c;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">			<span class="built_in">add</span>(a, b, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">spfa</span>(<span class="number">1</span>);<span class="comment">//建好图之后跑两遍spfa即可</span></span><br><span class="line">		<span class="built_in">respfa</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		ll ans = <span class="number">0</span>;<span class="comment">//最后答案会爆int</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += dis[i] + dis1[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Godsend-（博弈）-CDUTETCOJ"><a href="#Godsend-（博弈）-CDUTETCOJ" class="headerlink" title="Godsend （博弈）- CDUTETCOJ"></a><a href="https://cdutetcoj.xyz/contest/1042/problem/I">Godsend （博弈）- CDUTETCOJ</a></h4><p>题意：给出长度为n的数组，两个人做游戏。第一个人每次只能取出和为奇数的连续子串，第二个人每次只能取出和为偶数的连续子串。每人取出之后，剩余子串相互连接。最后谁无法行动失败。</p>
<p>思路：。1.首先如果所有数之和为奇数，第一个人直接获胜。 2.所有数字之和为偶数，但是这些数中没有奇数子串，也就是说没有奇数，此时第二个人获胜。 3.所有数字之和为偶数，并且数组中存在奇数，则第一个人必胜。 因为：此时第一个人拿走这个奇数之后，剩下的所有数之和必然为奇数（偶数-奇数&#x3D;奇数），若剩下的数字中存在偶数子串，则第二个人坚持一回合（若没偶数，二出局），然后，由于剩余所有数字之和为奇数，所以第一个人一次拿完（二仍然出局）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vis=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        vis=<span class="number">1</span>;</span><br><span class="line">        sum+=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!vis&amp;&amp;sum%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h3><h4 id="CCPC-Training-Class-HDU-6894-Virtual-Judge-csgrandeur-cn"><a href="#CCPC-Training-Class-HDU-6894-Virtual-Judge-csgrandeur-cn" class="headerlink" title="CCPC Training Class - HDU 6894 - Virtual Judge (csgrandeur.cn)"></a><a href="https://vjudge.csgrandeur.cn/problem/HDU-6894">CCPC Training Class - HDU 6894 - Virtual Judge (csgrandeur.cn)</a></h4><p>题意：对于字符串s，定义Lborderi 为“s最长的不为s的前缀使得该前缀是s的后缀”，定义D(i) &#x3D; D(Lborderi)+1，当s为空则D(i) &#x3D; 0。</p>
<p>思路：字母中串中出现最多的字母的<strong>个数</strong>是输出结果（你会说有些字母出现的次数一样啊，老子就不信你这套，客官~别急，听我慢慢道来）这里有些字母出现的次数相同，这就记一次就行了，作为最后的结果输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T, tmp = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            ++a[s[i] - <span class="string">&#x27;a&#x27;</span>]; </span><br><span class="line">            ans = <span class="built_in">max</span>(ans, a[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,++tmp,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3x3-Convolution-HDU-6898-Virtual-Judge-csgrandeur-cn"><a href="#3x3-Convolution-HDU-6898-Virtual-Judge-csgrandeur-cn" class="headerlink" title="3x3 Convolution - HDU 6898 - Virtual Judge (csgrandeur.cn)"></a><a href="https://vjudge.csgrandeur.cn/problem/HDU-6898">3x3 Convolution - HDU 6898 - Virtual Judge (csgrandeur.cn)</a></h4><p>题意：给一个两个矩阵A，K求矩阵C；</p>
<p>思路：无穷次后要么是原来的矩阵要么是全0矩阵，只要左边有比1个多的非0元素，则结果必为全0矩阵，否则就输出原矩阵</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">int</span> ans[maxn][maxn];</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> k[<span class="number">4</span>][<span class="number">4</span>],a[maxn][maxn],b[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(k,<span class="number">0</span>,<span class="built_in">sizeof</span>(k));</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) cin&gt;&gt;a[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                cin&gt;&gt;k[i][j];</span><br><span class="line">                sum += k[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == k[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) ans[i][j] = a[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                cout&lt;&lt;ans[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j != n) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shaolin-HDU-4585-Virtual-Judge-csgrandeur-cn"><a href="#Shaolin-HDU-4585-Virtual-Judge-csgrandeur-cn" class="headerlink" title="Shaolin - HDU 4585 - Virtual Judge (csgrandeur.cn)"></a><a href="https://vjudge.csgrandeur.cn/problem/HDU-4585">Shaolin - HDU 4585 - Virtual Judge (csgrandeur.cn)</a></h4><p>题意：僧侣的id都是按升序输入的（等同于他们的来挑战的顺序），战斗的原则是他会在已经来到的僧侣中选一个战斗力跟他相近的僧侣进行战斗，如果出现两个与他战斗力差值相同的情况下，我们输出id小的那个。</p>
<p>思路：map映射快速输入+查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DoubleQ</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        m[<span class="number">1000000000</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> grade , id;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;id , &amp;grade);</span><br><span class="line">            m[grade] = id;</span><br><span class="line">            map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; :: iterator temp = m.<span class="built_in">find</span>(grade);</span><br><span class="line">            <span class="keyword">if</span>(temp == m.<span class="built_in">begin</span>())</span><br><span class="line">                res = (++temp)-&gt;second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map&lt;<span class="type">int</span> , <span class="type">int</span>&gt; :: iterator temp2 = temp;</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>((++temp)-&gt;first - grade) &gt;= <span class="built_in">abs</span>((--temp2)-&gt;first - grade) )</span><br><span class="line">                    res = temp2-&gt;second;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = temp-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id , res);</span><br><span class="line">        &#125;</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codeforces.com/gym/101917/problem/G">Problem - G - Codeforces</a></p>
<p>求最大公约数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> a,b,c,d,e,f;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> fz,fm;</span><br><span class="line">		fz=a*d*f+c*b*f+e*d*b;</span><br><span class="line">		fm=b*d*f;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> pi=_gpc(fz,fm);</span><br><span class="line">		fz/=pi;</span><br><span class="line">		fm/=pi;</span><br><span class="line">		cout &lt;&lt; fz &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; fm &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Problem-H-Codeforces"><a href="#Problem-H-Codeforces" class="headerlink" title="Problem - H - Codeforces"></a><a href="https://codeforces.com/gym/103388/problem/H">Problem - H - Codeforces</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> flog = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    	<span class="type">int</span> u;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[u]);</span><br><span class="line">	b[i] = a[u];</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b[i] != a[i])&#123;</span><br><span class="line">	flog = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">if</span>(flog==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
